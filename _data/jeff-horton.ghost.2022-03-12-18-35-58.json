{"db":[{"meta":{"exported_on":1647110158261,"version":"4.7.0"},"data":{"posts":[{"id":"59dbffdd33f8721992d35a27","uuid":"15550f43-5a8b-4508-b9db-1f3879c3842e","title":"The Final Battle","slug":"the-final-battle","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"So it had all come to this. A much reduced Halpi 23rd was due to be deployed to the front line at the Edge of the Abyss. What forces Morrolan had left he formed into a single block to anchor the right flank he was assigned to. Supporting them were Herneas's Rangers, along with Bannick Kholearm and Craggoth.\\n\\nThe noxious fumes clung to the ground, breathing was difficult. This would be a hard fight. Holding the center was a force of salamanders. Beyond them a detachment of humans, here to seek revenge for their homeland. Against Morrolan were more of the fiends from the Abyss, and there were also some of the Dwarves hated kin, and an army built from the bones of those who had already fallen.\\n\\n![Final-Battle-Morrolan-1](/content/images/2017/10/Final-Battle-Morrolan-1.jpg)\\n*The reduced Halpi 23rd form up in the frontline against the Abyss.*\\n\\nMorrolan cautiously advanced to hold a bottleneck between some form of Abyssal shrine that blocked the right flank, and the Salamanders holding a hill on Morrolan's left. The rangers were laying down good covering fire, and one of the smaller abyssal units was routed from that alone.\\n\\nThe abyssal mages were returning fire with fire and lightning from the volcanic clouds that shrouded the field in near darkness. One of the winged champions of the Abyss was sent to dispatch the rangers, but they held firm and cut it down.\\n\\n![Final-Battle-Morrolan-2](/content/images/2017/10/Final-Battle-Morrolan-2.jpg)\\n*Artakl is caught, as the Dwarves lay down a hail of fire.*\\n\\nMeanwhile in the Dwarves' centre, an assassin sent by the Salamanders was caught by the Abyssals and cut down. Craggoth charged in, smashing the fiends with his huge rocky fists, and Bannick was not far behind, his huge mining drill throwing chunks of the Abyssals flying.\\n\\nThey took down one unit easily and Craggoth easily took the counter charge from the Abyssal reserves, their blades barely chipping his colossal form. Morrolan held his forces, anchoring the Dwarven line and guarding Craggoth from being surrounded.\\n\\n![Final-Battle-Morrolan-3](/content/images/2017/10/Final-Battle-Morrolan-3.jpg)\\n*Bannick and Craggoth charge in side by side, as the Halpi 23rd guard their flank.*\\n\\nThe Rangers recovered from the assault by the winged champion and resumed covering fire on the flank. The Efreet was eventually forced to ground, and they were freed to support the centre.\\n\\nCraggoth and Bannick continued to cut a blood swathe through the Abyssal ranks, and the Halpi 23rd eventually got stuck in to grinding down the abyssal horde. Unfortunately not before that horde had piled into the Salamanders main force, and breaking them.\\n\\nThis was a minor set back in a battle that was decisively in the favour of the Green Lady's forces. Their center had crumbled, but both flanks were dominated by good with minimal losses. There were a few Abyssal Dwarves and fiends still left in the centre, but they were quickly surrounded from the flanks, and could do nothing but flee back to the rift that has spawned them.\\n\\n![Final-Battle-Morrolan-4](/content/images/2017/10/Final-Battle-Morrolan-4.jpg)\\n*The Dwarves mass against the remaining abyssal forces.*\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>So it had all come to this. A much reduced Halpi 23rd was due to be deployed to the front line at the Edge of the Abyss. What forces Morrolan had left he formed into a single block to anchor the right flank he was assigned to. Supporting them were Herneas's Rangers, along with Bannick Kholearm and Craggoth.</p>\n<p>The noxious fumes clung to the ground, breathing was difficult. This would be a hard fight. Holding the center was a force of salamanders. Beyond them a detachment of humans, here to seek revenge for their homeland. Against Morrolan were more of the fiends from the Abyss, and there were also some of the Dwarves hated kin, and an army built from the bones of those who had already fallen.</p>\n<p><img src=\"/content/images/2017/10/Final-Battle-Morrolan-1.jpg\" alt=\"Final-Battle-Morrolan-1\" loading=\"lazy\"><br>\n<em>The reduced Halpi 23rd form up in the frontline against the Abyss.</em></p>\n<p>Morrolan cautiously advanced to hold a bottleneck between some form of Abyssal shrine that blocked the right flank, and the Salamanders holding a hill on Morrolan's left. The rangers were laying down good covering fire, and one of the smaller abyssal units was routed from that alone.</p>\n<p>The abyssal mages were returning fire with fire and lightning from the volcanic clouds that shrouded the field in near darkness. One of the winged champions of the Abyss was sent to dispatch the rangers, but they held firm and cut it down.</p>\n<p><img src=\"/content/images/2017/10/Final-Battle-Morrolan-2.jpg\" alt=\"Final-Battle-Morrolan-2\" loading=\"lazy\"><br>\n<em>Artakl is caught, as the Dwarves lay down a hail of fire.</em></p>\n<p>Meanwhile in the Dwarves' centre, an assassin sent by the Salamanders was caught by the Abyssals and cut down. Craggoth charged in, smashing the fiends with his huge rocky fists, and Bannick was not far behind, his huge mining drill throwing chunks of the Abyssals flying.</p>\n<p>They took down one unit easily and Craggoth easily took the counter charge from the Abyssal reserves, their blades barely chipping his colossal form. Morrolan held his forces, anchoring the Dwarven line and guarding Craggoth from being surrounded.</p>\n<p><img src=\"/content/images/2017/10/Final-Battle-Morrolan-3.jpg\" alt=\"Final-Battle-Morrolan-3\" loading=\"lazy\"><br>\n<em>Bannick and Craggoth charge in side by side, as the Halpi 23rd guard their flank.</em></p>\n<p>The Rangers recovered from the assault by the winged champion and resumed covering fire on the flank. The Efreet was eventually forced to ground, and they were freed to support the centre.</p>\n<p>Craggoth and Bannick continued to cut a blood swathe through the Abyssal ranks, and the Halpi 23rd eventually got stuck in to grinding down the abyssal horde. Unfortunately not before that horde had piled into the Salamanders main force, and breaking them.</p>\n<p>This was a minor set back in a battle that was decisively in the favour of the Green Lady's forces. Their center had crumbled, but both flanks were dominated by good with minimal losses. There were a few Abyssal Dwarves and fiends still left in the centre, but they were quickly surrounded from the flanks, and could do nothing but flee back to the rift that has spawned them.</p>\n<p><img src=\"/content/images/2017/10/Final-Battle-Morrolan-4.jpg\" alt=\"Final-Battle-Morrolan-4\" loading=\"lazy\"><br>\n<em>The Dwarves mass against the remaining abyssal forces.</em></p>\n<!--kg-card-end: markdown-->","comment_id":"59dbffdd33f8721992d35a27","plaintext":"So it had all come to this. A much reduced Halpi 23rd was due to be deployed to\nthe front line at the Edge of the Abyss. What forces Morrolan had left he formed\ninto a single block to anchor the right flank he was assigned to. Supporting\nthem were Herneas's Rangers, along with Bannick Kholearm and Craggoth.\n\nThe noxious fumes clung to the ground, breathing was difficult. This would be a\nhard fight. Holding the center was a force of salamanders. Beyond them a\ndetachment of humans, here to seek revenge for their homeland. Against Morrolan\nwere more of the fiends from the Abyss, and there were also some of the Dwarves\nhated kin, and an army built from the bones of those who had already fallen.\n\n\nThe reduced Halpi 23rd form up in the frontline against the Abyss.\n\nMorrolan cautiously advanced to hold a bottleneck between some form of Abyssal\nshrine that blocked the right flank, and the Salamanders holding a hill on\nMorrolan's left. The rangers were laying down good covering fire, and one of the\nsmaller abyssal units was routed from that alone.\n\nThe abyssal mages were returning fire with fire and lightning from the volcanic\nclouds that shrouded the field in near darkness. One of the winged champions of\nthe Abyss was sent to dispatch the rangers, but they held firm and cut it down.\n\n\nArtakl is caught, as the Dwarves lay down a hail of fire.\n\nMeanwhile in the Dwarves' centre, an assassin sent by the Salamanders was caught\nby the Abyssals and cut down. Craggoth charged in, smashing the fiends with his\nhuge rocky fists, and Bannick was not far behind, his huge mining drill throwing\nchunks of the Abyssals flying.\n\nThey took down one unit easily and Craggoth easily took the counter charge from\nthe Abyssal reserves, their blades barely chipping his colossal form. Morrolan\nheld his forces, anchoring the Dwarven line and guarding Craggoth from being\nsurrounded.\n\n\nBannick and Craggoth charge in side by side, as the Halpi 23rd guard their\nflank.\n\nThe Rangers recovered from the assault by the winged champion and resumed\ncovering fire on the flank. The Efreet was eventually forced to ground, and they\nwere freed to support the centre.\n\nCraggoth and Bannick continued to cut a blood swathe through the Abyssal ranks,\nand the Halpi 23rd eventually got stuck in to grinding down the abyssal horde.\nUnfortunately not before that horde had piled into the Salamanders main force,\nand breaking them.\n\nThis was a minor set back in a battle that was decisively in the favour of the\nGreen Lady's forces. Their center had crumbled, but both flanks were dominated\nby good with minimal losses. There were a few Abyssal Dwarves and fiends still\nleft in the centre, but they were quickly surrounded from the flanks, and could\ndo nothing but flee back to the rift that has spawned them.\n\n\nThe Dwarves mass against the remaining abyssal forces.","feature_image":"__GHOST_URL__/content/images/2017/10/edges-of-the-abyss-map-large.jpg","featured":1,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-10-09T23:01:49.000Z","updated_at":"2017-10-10T21:23:16.000Z","published_at":"2017-10-01T11:00:00.000Z","custom_excerpt":"So it had all come to this. A much reduced Halpi 23rd was due to be deployed to the front line at the Edge of the Abyss.\n\nKing Morrolan's final report from Mantic's Edge of the Abyss Kings of War Campaign.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"59dcc98533f8721992d35a2d","uuid":"c5423630-39c6-4093-8915-e83eefde2daf","title":"None Shall Pass","slug":"none-shall-pass","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"King Morrolan surveyed the troops before him. The Halpi 23rd, newly formed from green recruits to counter the Abyssal advance. They had a few days of battle drills before marching north to the front lines. Suddenly a small pebble bounced off his helmet, he looked around and saw a surprisingly nimble dwarf picking their way down the rocky slope of the pass.\\n\\nMorrolan went to meet the stranger, who bowed and presented a scroll. Noticing Herneas's seal he hastily scanned the letter.\\n\\n\\\"I have been tracking some goblin raiders along the coast for 2 days now. The river you hold is supplying half the training camps, so here is where we make our stand. I have two detachments of my finest rangers to cover the Southern ridge, you must hold the pass. - Herneas.\\\"\\n\\n![IMG_20170914_203742-667](/content/images/2017/10/IMG_20170914_203742-667.jpg)\\n*The Dwarves form up*\\n\\nMorrolan ordered the 23rd into the standard formation. As they closed ranks the howls of wolves was already echoing through the pass. Squinting Morrolan saw a pack, barely controlled by the goblins clinging onto their backs, in disarray as a rain of dwarven steel fell on them from the rangers on the ridge.\\n\\nThen he saw the rest of them, there seemed to be two main rabbles, and a bunch of contraptions that looked ready to fall apart. Surly these would be no match for Dwarves, green recruits or not. Then he noticed the Trolls, huge lumbering brutes in the woods at the base of the pass. Perhaps there would be tales to tell of this day.\\n\\nShooting at the wolves seemed to have blown the hunters' cover, and the bulk of the goblins were heading for the ridge, so Morrolan ordered his force forwards to support. The main bulwark of his force squared up against the rabble that seemed to be heading for the pass, released their dogs, and stood as an impenetrable wall that the goblins broke upon.\\n\\n![IMG_20170914_213430-667](/content/images/2017/10/IMG_20170914_213430-667.jpg)\\n*Battle is joined*\\n\\nThe rangers had done well, the goblins advance was faltering, but eventually they did reach the ridge and fighting broke out. Dzuuri, leader of the the formation's left flank, and over-eager to prove himself led a charge to support them. The unit was making good progress smashing up the goblins' contraptions, until the largest of the trolls smashed into them and they scattered into the hills. Knowing that the brute couldn't be left to pick his fights, Morrolan went after it himself. It got one good blow, that even dented his shield, but it was no match for his skill, and he cut it down as it backed away from his deft hammer blows.\\n\\n![IMG_20170914_222922-667](/content/images/2017/10/IMG_20170914_222922-667.jpg)\\n*Crags flees, as Morrolan cuts down the troll bruiser*\\n\\nSurveying the battle all was looking well. The rangers had killed or dispersed the goblins in the hills, and the rest of the trolls were being impaled on the spears of his main force. The goblins' machines were now not much more than firewood. Some huge blobs of teeth seemed to have been released by the fleeing goblins and were causing chaos on the far right flank, but soon the Dwarves with the longest spears were starting to herd them down into the Valley.\\n\\nThe Halpi 23rd had been tested, and showed their Mettle. Tonight they would drink to their victory.\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>King Morrolan surveyed the troops before him. The Halpi 23rd, newly formed from green recruits to counter the Abyssal advance. They had a few days of battle drills before marching north to the front lines. Suddenly a small pebble bounced off his helmet, he looked around and saw a surprisingly nimble dwarf picking their way down the rocky slope of the pass.</p>\n<p>Morrolan went to meet the stranger, who bowed and presented a scroll. Noticing Herneas's seal he hastily scanned the letter.</p>\n<p>&quot;I have been tracking some goblin raiders along the coast for 2 days now. The river you hold is supplying half the training camps, so here is where we make our stand. I have two detachments of my finest rangers to cover the Southern ridge, you must hold the pass. - Herneas.&quot;</p>\n<p><img src=\"/content/images/2017/10/IMG_20170914_203742-667.jpg\" alt=\"IMG_20170914_203742-667\" loading=\"lazy\"><br>\n<em>The Dwarves form up</em></p>\n<p>Morrolan ordered the 23rd into the standard formation. As they closed ranks the howls of wolves was already echoing through the pass. Squinting Morrolan saw a pack, barely controlled by the goblins clinging onto their backs, in disarray as a rain of dwarven steel fell on them from the rangers on the ridge.</p>\n<p>Then he saw the rest of them, there seemed to be two main rabbles, and a bunch of contraptions that looked ready to fall apart. Surly these would be no match for Dwarves, green recruits or not. Then he noticed the Trolls, huge lumbering brutes in the woods at the base of the pass. Perhaps there would be tales to tell of this day.</p>\n<p>Shooting at the wolves seemed to have blown the hunters' cover, and the bulk of the goblins were heading for the ridge, so Morrolan ordered his force forwards to support. The main bulwark of his force squared up against the rabble that seemed to be heading for the pass, released their dogs, and stood as an impenetrable wall that the goblins broke upon.</p>\n<p><img src=\"/content/images/2017/10/IMG_20170914_213430-667.jpg\" alt=\"IMG_20170914_213430-667\" loading=\"lazy\"><br>\n<em>Battle is joined</em></p>\n<p>The rangers had done well, the goblins advance was faltering, but eventually they did reach the ridge and fighting broke out. Dzuuri, leader of the the formation's left flank, and over-eager to prove himself led a charge to support them. The unit was making good progress smashing up the goblins' contraptions, until the largest of the trolls smashed into them and they scattered into the hills. Knowing that the brute couldn't be left to pick his fights, Morrolan went after it himself. It got one good blow, that even dented his shield, but it was no match for his skill, and he cut it down as it backed away from his deft hammer blows.</p>\n<p><img src=\"/content/images/2017/10/IMG_20170914_222922-667.jpg\" alt=\"IMG_20170914_222922-667\" loading=\"lazy\"><br>\n<em>Crags flees, as Morrolan cuts down the troll bruiser</em></p>\n<p>Surveying the battle all was looking well. The rangers had killed or dispersed the goblins in the hills, and the rest of the trolls were being impaled on the spears of his main force. The goblins' machines were now not much more than firewood. Some huge blobs of teeth seemed to have been released by the fleeing goblins and were causing chaos on the far right flank, but soon the Dwarves with the longest spears were starting to herd them down into the Valley.</p>\n<p>The Halpi 23rd had been tested, and showed their Mettle. Tonight they would drink to their victory.</p>\n<!--kg-card-end: markdown-->","comment_id":"59dcc98533f8721992d35a2d","plaintext":"King Morrolan surveyed the troops before him. The Halpi 23rd, newly formed from\ngreen recruits to counter the Abyssal advance. They had a few days of battle\ndrills before marching north to the front lines. Suddenly a small pebble bounced\noff his helmet, he looked around and saw a surprisingly nimble dwarf picking\ntheir way down the rocky slope of the pass.\n\nMorrolan went to meet the stranger, who bowed and presented a scroll. Noticing\nHerneas's seal he hastily scanned the letter.\n\n\"I have been tracking some goblin raiders along the coast for 2 days now. The\nriver you hold is supplying half the training camps, so here is where we make\nour stand. I have two detachments of my finest rangers to cover the Southern\nridge, you must hold the pass. - Herneas.\"\n\n\nThe Dwarves form up\n\nMorrolan ordered the 23rd into the standard formation. As they closed ranks the\nhowls of wolves was already echoing through the pass. Squinting Morrolan saw a\npack, barely controlled by the goblins clinging onto their backs, in disarray as\na rain of dwarven steel fell on them from the rangers on the ridge.\n\nThen he saw the rest of them, there seemed to be two main rabbles, and a bunch\nof contraptions that looked ready to fall apart. Surly these would be no match\nfor Dwarves, green recruits or not. Then he noticed the Trolls, huge lumbering\nbrutes in the woods at the base of the pass. Perhaps there would be tales to\ntell of this day.\n\nShooting at the wolves seemed to have blown the hunters' cover, and the bulk of\nthe goblins were heading for the ridge, so Morrolan ordered his force forwards\nto support. The main bulwark of his force squared up against the rabble that\nseemed to be heading for the pass, released their dogs, and stood as an\nimpenetrable wall that the goblins broke upon.\n\n\nBattle is joined\n\nThe rangers had done well, the goblins advance was faltering, but eventually\nthey did reach the ridge and fighting broke out. Dzuuri, leader of the the\nformation's left flank, and over-eager to prove himself led a charge to support\nthem. The unit was making good progress smashing up the goblins' contraptions,\nuntil the largest of the trolls smashed into them and they scattered into the\nhills. Knowing that the brute couldn't be left to pick his fights, Morrolan went\nafter it himself. It got one good blow, that even dented his shield, but it was\nno match for his skill, and he cut it down as it backed away from his deft\nhammer blows.\n\n\nCrags flees, as Morrolan cuts down the troll bruiser\n\nSurveying the battle all was looking well. The rangers had killed or dispersed\nthe goblins in the hills, and the rest of the trolls were being impaled on the\nspears of his main force. The goblins' machines were now not much more than\nfirewood. Some huge blobs of teeth seemed to have been released by the fleeing\ngoblins and were causing chaos on the far right flank, but soon the Dwarves with\nthe longest spears were starting to herd them down into the Valley.\n\nThe Halpi 23rd had been tested, and showed their Mettle. Tonight they would\ndrink to their victory.","feature_image":"__GHOST_URL__/content/images/2017/10/rhyn-dufaris-map-large.jpg","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-10-10T13:22:13.000Z","updated_at":"2017-10-10T21:12:10.000Z","published_at":"2017-09-15T22:30:00.000Z","custom_excerpt":"A report tracking King Morrolan and the Halpi 23rds' first battle of the Edge of the Abyss campaign.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"59dd35d933f8721992d35a3b","uuid":"d15c637e-596a-49d3-ac94-dc648e7f077e","title":"Massacre in the Glades","slug":"massacre-in-the-glades","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Things had been going well for the Halpi 23rd. They'd marched north through the mountains with little resistance. Herneas's scouts had started using their overnight camps as a base of operations, and the extra intelligence had been useful.\\n\\nIt was about a week into their march north, they were preparing to break camp when an Elven mage appeared in Morrolan's command tent, with orders for Herneas.\\n\\n\\\"You are requested to support our forces in the Twilight Glades, we are being overrun by abyssal fiends, your rangers would be a great asset.\\\"\\n\\nAfter a brief discussion, it was decided that both Herneas and Morrolan would brought through the elven ways to defend the Glades. The journey was nightmarish, and his troops were definitely shaken when they appeared. Morrolan had little time to rally his forces as they were beset by abyssal horrors almost as soon as they appeared.\\n\\n![DSC_1059](/content/images/2017/10/DSC_1059.jpg)\\n*The horde of Lower Abyssals is broken, but the rest of the Abyss is bearing down*\\n\\nMorrolan took on the giant Archfiend, he manage to put up a good fight, but one of it's burning claws caught his helmet, and Morrolan blacked out.\\n\\nHe came too in a makeshift camp. The scattered Dwarves had managed to escape and start to reform, treat their wounded and build some rudimentary defenses. The Abyssals had been left to take the portals as the Halpi 23rd was decisively routed.\\n\\n![DSC_1068](/content/images/2017/10/DSC_1068.jpg)\\n*The battle ends. Herneas looks on, unable as the Bulwalkers are surrounded, but not destroyed. The abyssals hold two portals, and contest the only one that the Dwarves could hold.*\\n- - - -\\n\\nAfter a few days of recovery the Herneas's Rangers and Morrolan's Halpi 23rd were battle ready once more. Ranger's scouts were reporting that they had somehow been followed by the goblin king they had defeated in the mountains. The goblin rabble were now marching towards one of the portal nexuses, so Morrolan and Herneas moved their forces to intercept.\\n\\n![DSC_1070](/content/images/2017/10/DSC_1070.jpg)\\n*Battle is joined, except for the cowardly flea bag riders.*\\n\\nThe fight against the trolls was bloody, but eventually the brutes were no match for the Dwarves skill and tenacity. The dogs seemed to have worried the wolf riders, they hesitated and that was enough for Morrolan and one unit of iron clad to break that flank one unit at a time.\\n\\nThis freed the Bulwarker core of the 23rd to turn to deal with the giant and the king. Eventually all the goblins were dead or scattered. The rabble of archers were still dealing out death and held one of the portals. The remaining Dwarves hunkered down to weather the storm. They were too few to advance and break the goblins, but their armour could withstand the arrows until the goblins' quivers were empty.\\n\\nAs the sun set the two forces retreated from the field, leaving many dead behind on both sides. The Halpi 23rd were almost spent. They were sent back through the waves to recuperate on home ground.\\n\\n![DSC_1076](/content/images/2017/10/DSC_1076.jpg)\\n*The much deminished forces on both sides fight to a stalemate.*\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>Things had been going well for the Halpi 23rd. They'd marched north through the mountains with little resistance. Herneas's scouts had started using their overnight camps as a base of operations, and the extra intelligence had been useful.</p>\n<p>It was about a week into their march north, they were preparing to break camp when an Elven mage appeared in Morrolan's command tent, with orders for Herneas.</p>\n<p>&quot;You are requested to support our forces in the Twilight Glades, we are being overrun by abyssal fiends, your rangers would be a great asset.&quot;</p>\n<p>After a brief discussion, it was decided that both Herneas and Morrolan would brought through the elven ways to defend the Glades. The journey was nightmarish, and his troops were definitely shaken when they appeared. Morrolan had little time to rally his forces as they were beset by abyssal horrors almost as soon as they appeared.</p>\n<p><img src=\"/content/images/2017/10/DSC_1059.jpg\" alt=\"DSC_1059\" loading=\"lazy\"><br>\n<em>The horde of Lower Abyssals is broken, but the rest of the Abyss is bearing down</em></p>\n<p>Morrolan took on the giant Archfiend, he manage to put up a good fight, but one of it's burning claws caught his helmet, and Morrolan blacked out.</p>\n<p>He came too in a makeshift camp. The scattered Dwarves had managed to escape and start to reform, treat their wounded and build some rudimentary defenses. The Abyssals had been left to take the portals as the Halpi 23rd was decisively routed.</p>\n<p><img src=\"/content/images/2017/10/DSC_1068.jpg\" alt=\"DSC_1068\" loading=\"lazy\"><br>\n<em>The battle ends. Herneas looks on, unable as the Bulwalkers are surrounded, but not destroyed. The abyssals hold two portals, and contest the only one that the Dwarves could hold.</em></p>\n<hr>\n<p>After a few days of recovery the Herneas's Rangers and Morrolan's Halpi 23rd were battle ready once more. Ranger's scouts were reporting that they had somehow been followed by the goblin king they had defeated in the mountains. The goblin rabble were now marching towards one of the portal nexuses, so Morrolan and Herneas moved their forces to intercept.</p>\n<p><img src=\"/content/images/2017/10/DSC_1070.jpg\" alt=\"DSC_1070\" loading=\"lazy\"><br>\n<em>Battle is joined, except for the cowardly flea bag riders.</em></p>\n<p>The fight against the trolls was bloody, but eventually the brutes were no match for the Dwarves skill and tenacity. The dogs seemed to have worried the wolf riders, they hesitated and that was enough for Morrolan and one unit of iron clad to break that flank one unit at a time.</p>\n<p>This freed the Bulwarker core of the 23rd to turn to deal with the giant and the king. Eventually all the goblins were dead or scattered. The rabble of archers were still dealing out death and held one of the portals. The remaining Dwarves hunkered down to weather the storm. They were too few to advance and break the goblins, but their armour could withstand the arrows until the goblins' quivers were empty.</p>\n<p>As the sun set the two forces retreated from the field, leaving many dead behind on both sides. The Halpi 23rd were almost spent. They were sent back through the waves to recuperate on home ground.</p>\n<p><img src=\"/content/images/2017/10/DSC_1076.jpg\" alt=\"DSC_1076\" loading=\"lazy\"><br>\n<em>The much deminished forces on both sides fight to a stalemate.</em></p>\n<!--kg-card-end: markdown-->","comment_id":"59dd35d933f8721992d35a3b","plaintext":"Things had been going well for the Halpi 23rd. They'd marched north through the\nmountains with little resistance. Herneas's scouts had started using their\novernight camps as a base of operations, and the extra intelligence had been\nuseful.\n\nIt was about a week into their march north, they were preparing to break camp\nwhen an Elven mage appeared in Morrolan's command tent, with orders for Herneas.\n\n\"You are requested to support our forces in the Twilight Glades, we are being\noverrun by abyssal fiends, your rangers would be a great asset.\"\n\nAfter a brief discussion, it was decided that both Herneas and Morrolan would\nbrought through the elven ways to defend the Glades. The journey was\nnightmarish, and his troops were definitely shaken when they appeared. Morrolan\nhad little time to rally his forces as they were beset by abyssal horrors almost\nas soon as they appeared.\n\n\nThe horde of Lower Abyssals is broken, but the rest of the Abyss is bearing down\n\nMorrolan took on the giant Archfiend, he manage to put up a good fight, but one\nof it's burning claws caught his helmet, and Morrolan blacked out.\n\nHe came too in a makeshift camp. The scattered Dwarves had managed to escape and\nstart to reform, treat their wounded and build some rudimentary defenses. The\nAbyssals had been left to take the portals as the Halpi 23rd was decisively\nrouted.\n\n\nThe battle ends. Herneas looks on, unable as the Bulwalkers are surrounded, but\nnot destroyed. The abyssals hold two portals, and contest the only one that the\nDwarves could hold.\n\n\n--------------------------------------------------------------------------------\n\nAfter a few days of recovery the Herneas's Rangers and Morrolan's Halpi 23rd\nwere battle ready once more. Ranger's scouts were reporting that they had\nsomehow been followed by the goblin king they had defeated in the mountains. The\ngoblin rabble were now marching towards one of the portal nexuses, so Morrolan\nand Herneas moved their forces to intercept.\n\n\nBattle is joined, except for the cowardly flea bag riders.\n\nThe fight against the trolls was bloody, but eventually the brutes were no match\nfor the Dwarves skill and tenacity. The dogs seemed to have worried the wolf\nriders, they hesitated and that was enough for Morrolan and one unit of iron\nclad to break that flank one unit at a time.\n\nThis freed the Bulwarker core of the 23rd to turn to deal with the giant and the\nking. Eventually all the goblins were dead or scattered. The rabble of archers\nwere still dealing out death and held one of the portals. The remaining Dwarves\nhunkered down to weather the storm. They were too few to advance and break the\ngoblins, but their armour could withstand the arrows until the goblins' quivers\nwere empty.\n\nAs the sun set the two forces retreated from the field, leaving many dead behind\non both sides. The Halpi 23rd were almost spent. They were sent back through the\nwaves to recuperate on home ground.\n\n\nThe much deminished forces on both sides fight to a stalemate.","feature_image":"__GHOST_URL__/content/images/2017/10/twilight-glades-map-large.jpg","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-10-10T21:04:25.000Z","updated_at":"2017-10-10T21:18:25.000Z","published_at":"2017-09-25T21:06:00.000Z","custom_excerpt":"The Halpi 23rd go to help out in the Twilight Glades, where they try to defend the forest from Abyssals. \n\nSomehow Crags and his Goblins follow, and a bloody rematch is fought.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a2d994ad39b4937e727d70d","uuid":"49f5fbc8-56d8-40c3-9b67-241079d1fa89","title":"Corruption Checksum","slug":"aoc17-day-2-corruption-checksum","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 2](http://adventofcode.com/2017/day/2)\\n\\n## Part 1 \\n\\nI'm given a tab separated spreadsheet and need to calculate a checksum by \\nfinding the difference between the minimum and maximum of each line, and then \\nsumming those values.\\n\\nFirst I'll make the input into something usable:\\n\\n```scala\\nval part1input = \\\"\\\"\\\"5 1 9 5\\n                   |7 5 3\\n                   |2 4 6 8\\\"\\\"\\\".stripMargin\\n// part1input: String =\\n// 5 1 9 5\\n// 7 5 3\\n// 2 4 6 8\\n\\ndef parseRows(sheet: Seq[String]): Seq[Seq[Int]] =\\n    sheet.map(\\n      l => l.split(\\\"\\\\\\\\s\\\").map(s => s.toInt).toSeq\\n    )\\n// parseRows: (sheet: Seq[String])Seq[Seq[Int]]\\n\\nval part1sheet: Seq[Seq[Int]] = \\n  parseRows(part1input.lines.toSeq)\\n// part1sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 1, 9, 5), ?)\\n```\\n\\nNow I can try to calculate a checksum...\\n\\n```scala\\ndef calcRowChecksum(row: Seq[Int]): Int = {\\n    val (rowMin, rowMax) = row.foldLeft((Int.MaxValue, Int.MinValue)){\\n      case ((min, max), cell) => (Math.min(min, cell), Math.max(max, cell))\\n    }\\n    \\n    rowMax - rowMin\\n}\\n// calcRowChecksum: (row: Seq[Int])Int\\n\\ndef calcSheetChecksum(sheet: Seq[Seq[Int]]): Int = \\n  sheet.map(calcRowChecksum).sum\\n// calcSheetChecksum: (sheet: Seq[Seq[Int]])Int\\n```\\n\\n...and check my working using the examples in the puzzle:\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day2Part1Test extends FunSuite with Matchers {\\n  \\n  test(\\\"Can calculate per row checksums\\\") {\\n    calcRowChecksum(part1sheet(0)) shouldBe 8\\n    calcRowChecksum(part1sheet(1)) shouldBe 4\\n    calcRowChecksum(part1sheet(2)) shouldBe 6\\n  }\\n  \\n  test(\\\"Can calculate whole sheet checksums\\\") { \\n    calcSheetChecksum(part1sheet) shouldBe 18\\n  }\\n}\\n// defined class Day2Part1Test\\n\\n(new Day2Part1Test).execute()\\n// Day2Part1Test:\\n// - Can calculate per row checksums\\n// - Can calculate whole sheet checksums\\n```\\n\\nFinally I can pass in the puzzle input and get an answer.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval puzzleSheet = parseRows(\\n  Source.fromResource(\\\"day2input.txt\\\").getLines().toSeq\\n)\\n// puzzleSheet: Seq[Seq[Int]] = Stream(WrappedArray(3751, 3769, 2769, 2039, 2794, 240, 3579, 1228, 4291, 220, 324, 3960, 211, 1346, 237, 1586), ?)\\n\\ncalcSheetChecksum(puzzleSheet)\\n// res1: Int = 36174\\n```\\n\\n## Part 2\\n\\nIt turns out what I actually need to do is find the two evenly divisible \\nnumbers on each row, and sum the common factor.\\n\\n```scala\\ndef findDivisor(needle: Int, haystack: Seq[Int]): Option[Int] = haystack match {\\n  case Nil => None\\n  case h +: _ if (needle % h) == 0 => Some(needle / h)\\n  case h +: _ if (h % needle) == 0 => Some(h / needle)\\n  case _ +: rest => findDivisor(needle, rest)\\n}\\n// findDivisor: (needle: Int, haystack: Seq[Int])Option[Int]\\n\\ndef findFactor(row: Seq[Int]): Int = row match {\\n  case Nil => 0 // Should never occur with out input\\n  case h +: t => \\n    val maybeDivisor = findDivisor(h, t)\\n    \\n    // Would normally use getOrElse but the compiler can't detect that as\\n    // tail recursive\\n    if(maybeDivisor.isDefined) maybeDivisor.get\\n    else findFactor(t)\\n}\\n// findFactor: (row: Seq[Int])Int\\n\\ndef sumFactors(sheet: Seq[Seq[Int]]) = sheet.map(findFactor).sum\\n// sumFactors: (sheet: Seq[Seq[Int]])Int\\n```\\n\\nThere is different test input for this, and some more examples:\\n\\n```scala\\nval part2input = \\\"\\\"\\\"5 9 2 8\\n                   |9 4 7 3\\n                   |3 8 6 5\\\"\\\"\\\".stripMargin\\n// part2input: String =\\n// 5 9 2 8\\n// 9 4 7 3\\n// 3 8 6 5\\n\\nval part2sheet: Seq[Seq[Int]] = \\n  parseRows(part2input.lines.toSeq)\\n// part2sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 9, 2, 8), ?)\\n\\nclass Day2Part2Test extends FunSuite with Matchers {\\n  \\n  test(\\\"Can calculate per row factors\\\") {\\n    findFactor(part2sheet(0)) shouldBe 4\\n    findFactor(part2sheet(1)) shouldBe 3\\n    findFactor(part2sheet(2)) shouldBe 2\\n  }\\n  \\n  test(\\\"Can calculate the sum of the sheet's factors\\\") { \\n    sumFactors(part2sheet) shouldBe 9\\n  }\\n}\\n// defined class Day2Part2Test\\n\\n(new Day2Part2Test).execute()\\n// Day2Part2Test:\\n// - Can calculate per row factors\\n// - Can calculate the sum of the sheet's factors\\n```\\n\\nPutting it all together\\n\\n```scala\\nsumFactors(puzzleSheet)\\n// res3: Int = 244\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/2\">Advent of Code 2017 - Day 2</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>I'm given a tab separated spreadsheet and need to calculate a checksum by<br>\nfinding the difference between the minimum and maximum of each line, and then<br>\nsumming those values.</p>\n<p>First I'll make the input into something usable:</p>\n<pre><code class=\"language-scala\">val part1input = &quot;&quot;&quot;5 1 9 5\n                   |7 5 3\n                   |2 4 6 8&quot;&quot;&quot;.stripMargin\n// part1input: String =\n// 5 1 9 5\n// 7 5 3\n// 2 4 6 8\n\ndef parseRows(sheet: Seq[String]): Seq[Seq[Int]] =\n    sheet.map(\n      l =&gt; l.split(&quot;\\\\s&quot;).map(s =&gt; s.toInt).toSeq\n    )\n// parseRows: (sheet: Seq[String])Seq[Seq[Int]]\n\nval part1sheet: Seq[Seq[Int]] = \n  parseRows(part1input.lines.toSeq)\n// part1sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 1, 9, 5), ?)\n</code></pre>\n<p>Now I can try to calculate a checksum...</p>\n<pre><code class=\"language-scala\">def calcRowChecksum(row: Seq[Int]): Int = {\n    val (rowMin, rowMax) = row.foldLeft((Int.MaxValue, Int.MinValue)){\n      case ((min, max), cell) =&gt; (Math.min(min, cell), Math.max(max, cell))\n    }\n    \n    rowMax - rowMin\n}\n// calcRowChecksum: (row: Seq[Int])Int\n\ndef calcSheetChecksum(sheet: Seq[Seq[Int]]): Int = \n  sheet.map(calcRowChecksum).sum\n// calcSheetChecksum: (sheet: Seq[Seq[Int]])Int\n</code></pre>\n<p>...and check my working using the examples in the puzzle:</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day2Part1Test extends FunSuite with Matchers {\n  \n  test(&quot;Can calculate per row checksums&quot;) {\n    calcRowChecksum(part1sheet(0)) shouldBe 8\n    calcRowChecksum(part1sheet(1)) shouldBe 4\n    calcRowChecksum(part1sheet(2)) shouldBe 6\n  }\n  \n  test(&quot;Can calculate whole sheet checksums&quot;) { \n    calcSheetChecksum(part1sheet) shouldBe 18\n  }\n}\n// defined class Day2Part1Test\n\n(new Day2Part1Test).execute()\n// Day2Part1Test:\n// - Can calculate per row checksums\n// - Can calculate whole sheet checksums\n</code></pre>\n<p>Finally I can pass in the puzzle input and get an answer.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval puzzleSheet = parseRows(\n  Source.fromResource(&quot;day2input.txt&quot;).getLines().toSeq\n)\n// puzzleSheet: Seq[Seq[Int]] = Stream(WrappedArray(3751, 3769, 2769, 2039, 2794, 240, 3579, 1228, 4291, 220, 324, 3960, 211, 1346, 237, 1586), ?)\n\ncalcSheetChecksum(puzzleSheet)\n// res1: Int = 36174\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>It turns out what I actually need to do is find the two evenly divisible<br>\nnumbers on each row, and sum the common factor.</p>\n<pre><code class=\"language-scala\">def findDivisor(needle: Int, haystack: Seq[Int]): Option[Int] = haystack match {\n  case Nil =&gt; None\n  case h +: _ if (needle % h) == 0 =&gt; Some(needle / h)\n  case h +: _ if (h % needle) == 0 =&gt; Some(h / needle)\n  case _ +: rest =&gt; findDivisor(needle, rest)\n}\n// findDivisor: (needle: Int, haystack: Seq[Int])Option[Int]\n\ndef findFactor(row: Seq[Int]): Int = row match {\n  case Nil =&gt; 0 // Should never occur with out input\n  case h +: t =&gt; \n    val maybeDivisor = findDivisor(h, t)\n    \n    // Would normally use getOrElse but the compiler can't detect that as\n    // tail recursive\n    if(maybeDivisor.isDefined) maybeDivisor.get\n    else findFactor(t)\n}\n// findFactor: (row: Seq[Int])Int\n\ndef sumFactors(sheet: Seq[Seq[Int]]) = sheet.map(findFactor).sum\n// sumFactors: (sheet: Seq[Seq[Int]])Int\n</code></pre>\n<p>There is different test input for this, and some more examples:</p>\n<pre><code class=\"language-scala\">val part2input = &quot;&quot;&quot;5 9 2 8\n                   |9 4 7 3\n                   |3 8 6 5&quot;&quot;&quot;.stripMargin\n// part2input: String =\n// 5 9 2 8\n// 9 4 7 3\n// 3 8 6 5\n\nval part2sheet: Seq[Seq[Int]] = \n  parseRows(part2input.lines.toSeq)\n// part2sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 9, 2, 8), ?)\n\nclass Day2Part2Test extends FunSuite with Matchers {\n  \n  test(&quot;Can calculate per row factors&quot;) {\n    findFactor(part2sheet(0)) shouldBe 4\n    findFactor(part2sheet(1)) shouldBe 3\n    findFactor(part2sheet(2)) shouldBe 2\n  }\n  \n  test(&quot;Can calculate the sum of the sheet's factors&quot;) { \n    sumFactors(part2sheet) shouldBe 9\n  }\n}\n// defined class Day2Part2Test\n\n(new Day2Part2Test).execute()\n// Day2Part2Test:\n// - Can calculate per row factors\n// - Can calculate the sum of the sheet's factors\n</code></pre>\n<p>Putting it all together</p>\n<pre><code class=\"language-scala\">sumFactors(puzzleSheet)\n// res3: Int = 244\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a2d994ad39b4937e727d70d","plaintext":"A solution for Advent of Code 2017 - Day 2 [http://adventofcode.com/2017/day/2]\n\nPart 1\nI'm given a tab separated spreadsheet and need to calculate a checksum by\nfinding the difference between the minimum and maximum of each line, and then\nsumming those values.\n\nFirst I'll make the input into something usable:\n\nval part1input = \"\"\"5 1 9 5\n                   |7 5 3\n                   |2 4 6 8\"\"\".stripMargin\n// part1input: String =\n// 5 1 9 5\n// 7 5 3\n// 2 4 6 8\n\ndef parseRows(sheet: Seq[String]): Seq[Seq[Int]] =\n    sheet.map(\n      l => l.split(\"\\\\s\").map(s => s.toInt).toSeq\n    )\n// parseRows: (sheet: Seq[String])Seq[Seq[Int]]\n\nval part1sheet: Seq[Seq[Int]] = \n  parseRows(part1input.lines.toSeq)\n// part1sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 1, 9, 5), ?)\n\n\nNow I can try to calculate a checksum...\n\ndef calcRowChecksum(row: Seq[Int]): Int = {\n    val (rowMin, rowMax) = row.foldLeft((Int.MaxValue, Int.MinValue)){\n      case ((min, max), cell) => (Math.min(min, cell), Math.max(max, cell))\n    }\n    \n    rowMax - rowMin\n}\n// calcRowChecksum: (row: Seq[Int])Int\n\ndef calcSheetChecksum(sheet: Seq[Seq[Int]]): Int = \n  sheet.map(calcRowChecksum).sum\n// calcSheetChecksum: (sheet: Seq[Seq[Int]])Int\n\n\n...and check my working using the examples in the puzzle:\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day2Part1Test extends FunSuite with Matchers {\n  \n  test(\"Can calculate per row checksums\") {\n    calcRowChecksum(part1sheet(0)) shouldBe 8\n    calcRowChecksum(part1sheet(1)) shouldBe 4\n    calcRowChecksum(part1sheet(2)) shouldBe 6\n  }\n  \n  test(\"Can calculate whole sheet checksums\") { \n    calcSheetChecksum(part1sheet) shouldBe 18\n  }\n}\n// defined class Day2Part1Test\n\n(new Day2Part1Test).execute()\n// Day2Part1Test:\n// - Can calculate per row checksums\n// - Can calculate whole sheet checksums\n\n\nFinally I can pass in the puzzle input and get an answer.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval puzzleSheet = parseRows(\n  Source.fromResource(\"day2input.txt\").getLines().toSeq\n)\n// puzzleSheet: Seq[Seq[Int]] = Stream(WrappedArray(3751, 3769, 2769, 2039, 2794, 240, 3579, 1228, 4291, 220, 324, 3960, 211, 1346, 237, 1586), ?)\n\ncalcSheetChecksum(puzzleSheet)\n// res1: Int = 36174\n\n\nPart 2\nIt turns out what I actually need to do is find the two evenly divisible\nnumbers on each row, and sum the common factor.\n\ndef findDivisor(needle: Int, haystack: Seq[Int]): Option[Int] = haystack match {\n  case Nil => None\n  case h +: _ if (needle % h) == 0 => Some(needle / h)\n  case h +: _ if (h % needle) == 0 => Some(h / needle)\n  case _ +: rest => findDivisor(needle, rest)\n}\n// findDivisor: (needle: Int, haystack: Seq[Int])Option[Int]\n\ndef findFactor(row: Seq[Int]): Int = row match {\n  case Nil => 0 // Should never occur with out input\n  case h +: t => \n    val maybeDivisor = findDivisor(h, t)\n    \n    // Would normally use getOrElse but the compiler can't detect that as\n    // tail recursive\n    if(maybeDivisor.isDefined) maybeDivisor.get\n    else findFactor(t)\n}\n// findFactor: (row: Seq[Int])Int\n\ndef sumFactors(sheet: Seq[Seq[Int]]) = sheet.map(findFactor).sum\n// sumFactors: (sheet: Seq[Seq[Int]])Int\n\n\nThere is different test input for this, and some more examples:\n\nval part2input = \"\"\"5 9 2 8\n                   |9 4 7 3\n                   |3 8 6 5\"\"\".stripMargin\n// part2input: String =\n// 5 9 2 8\n// 9 4 7 3\n// 3 8 6 5\n\nval part2sheet: Seq[Seq[Int]] = \n  parseRows(part2input.lines.toSeq)\n// part2sheet: Seq[Seq[Int]] = Stream(WrappedArray(5, 9, 2, 8), ?)\n\nclass Day2Part2Test extends FunSuite with Matchers {\n  \n  test(\"Can calculate per row factors\") {\n    findFactor(part2sheet(0)) shouldBe 4\n    findFactor(part2sheet(1)) shouldBe 3\n    findFactor(part2sheet(2)) shouldBe 2\n  }\n  \n  test(\"Can calculate the sum of the sheet's factors\") { \n    sumFactors(part2sheet) shouldBe 9\n  }\n}\n// defined class Day2Part2Test\n\n(new Day2Part2Test).execute()\n// Day2Part2Test:\n// - Can calculate per row factors\n// - Can calculate the sum of the sheet's factors\n\n\nPutting it all together\n\nsumFactors(puzzleSheet)\n// res3: Int = 244","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-1.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-10T20:30:02.000Z","updated_at":"2017-12-13T22:51:26.000Z","published_at":"2017-12-09T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 2","codeinjection_head":"<link rel=\"stylesheet\"\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script> ","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a2e503c9136d71a373352c6","uuid":"cbef31f5-e5b7-4966-a9d6-76decfda4321","title":"Hex Ed","slug":"aoc-2017-part-11-hex-ed","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 11](http://adventofcode.com/2017/day/11)\\n\\n## Part 1\\n\\nI need to find the shortest path to the origin on an infinite hex grid after following a sequence of directions. So I set up some representations of a coordinate and a direction.\\n\\n```scala\\ncase class Coordinate(x: Int, y: Int, z: Int) \\n// defined class Coordinate\\n\\nsealed trait Direction {\\n  def transform (coordinate: Coordinate): Coordinate\\n}\\n// defined trait Direction\\n\\ncase object N extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(x = c.x + 1, z = c.z - 1)\\n}\\n// defined object N\\n\\ncase object NE extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(x = c.x + 1, y = c.y - 1)\\n}\\n// defined object NE\\n\\ncase object SE extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(y = c.y - 1, z = c.z + 1)\\n}\\n// defined object SE\\n\\ncase object S extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(x = c.x - 1, z = c.z + 1)\\n}\\n// defined object S\\n\\ncase object SW extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(x = c.x - 1, y = c.y + 1)\\n}\\n// defined object SW\\n\\ncase object NW extends Direction {\\n  override def transform(c: Coordinate): Coordinate = \\n    c.copy(y = c.y + 1, z = c.z - 1)\\n}\\n// defined object NW\\n```\\n\\nParsing the input is just mapping strings to the relevant case object:\\n\\n```scala\\ndef parsePath(path: String): Seq[Direction] = \\n  path.split(',').toSeq.collect {\\n    case \\\"n\\\" => N\\n    case \\\"ne\\\" => NE\\n    case \\\"se\\\" => SE\\n    case \\\"s\\\" => S\\n    case \\\"sw\\\" => SW\\n    case \\\"nw\\\" => NW\\n  }\\n// parsePath: (path: String)Seq[Direction]\\n```\\n\\nNow I can actually write some logic. I must admit I didn't really have an\\nintuition for this problem, but I found a random blog post that helped, \\n[Hexagon grids: coordinate systems and distance calculations](http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/)\\n\\n```scala\\ndef distanceBetween(a: Coordinate, b: Coordinate): Int =\\n  Seq(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)).max\\n// distanceBetween: (a: Coordinate, b: Coordinate)Int\\n\\nval origin = Coordinate(0, 0, 0)\\n// origin: Coordinate = Coordinate(0,0,0)\\n\\ndef homeDistance(path: Seq[Direction]): Int = {\\n  val destination = path.foldLeft(origin) {\\n    case (c, d) => d.transform(c)\\n  }\\n  \\n  distanceBetween(destination, origin)\\n}\\n// homeDistance: (path: Seq[Direction])Int\\n\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day11Part1Test extends FunSuite with Matchers {\\n  test(\\\"Can find distance from origin\\\") {\\n    homeDistance(parsePath(\\\"ne,ne,ne\\\")) shouldBe 3\\n    homeDistance(parsePath(\\\"ne,ne,sw,sw\\\")) shouldBe 0\\n    homeDistance(parsePath(\\\"ne,ne,s,s\\\")) shouldBe 2\\n    homeDistance(parsePath(\\\"ne,n,nw\\\")) shouldBe 2\\n    homeDistance(parsePath(\\\"se,sw,se,sw,sw\\\")) shouldBe 3\\n  }\\n}\\n// defined class Day11Part1Test\\n\\n(new Day11Part1Test).execute()\\n// Day11Part1Test:\\n// - Can find distance from origin\\n``` \\n\\nI'm now able to find a solution for the puzzle input\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval puzzlePath = parsePath(\\n  Source.fromResource(\\\"day11input.txt\\\").mkString(\\\"\\\").trim\\n)\\n// puzzlePath: Seq[Direction] = ArrayBuffer(SE, S, S, SW, SW, SW, SW, SW, SW, NW, NW, NW, SE, N, NW, NW, NW, N, N, NW, N, N, N, NE, N, NE, NE, NW, SE, N, NE, NE, N, NE, NE, NE, SW, NE, NE, N, NE, SE, SE, NE, NE, S, NE, S, NE, NW, SE, NE, NE, NE, SE, SE, SE, SE, S, SE, SE, SE, SE, NW, SE, SE, SE, SE, SE, N, S, SE, SE, SE, SE, NE, SE, S, SE, SE, S, S, NE, SE, SE, S, SE, NW, NW, NW, NE, SW, S, NW, S, SW, S, NW, S, S, NW, S, S, SW, N, S, S, SW, SW, SW, SE, N, NE, NE, S, S, SE, SW, N, S, S, SW, SW, SW, SW, S, S, NW, S, S, S, SW, S, SE, SW, SW, S, SW, SW, N, SW, S, SW, NW, SW, SW, SW, SW, SW, NE, NE, SW, NW, NW, NE, SW, NW, NW, NW, SW, SW, SW, SW, NE, SW, SW, SW, SW, SW, NW, SW, SW, SW, NE, SW, SW, SW, S, SE, NW, NW, NW, NW, SW, N, NW, NW, SW, NW, SE, NW, SW, SW, NE, SW, NW, SW, NW, NW, NW, NW, ...\\n\\nhomeDistance(puzzlePath)\\n// res2: Int = 764\\n``` \\n## Part 2 \\n\\nThis is much easier, given part one. I now need to find the maximum distance \\nfrom the origin at any point along the path. This can be done just composing \\nmethods from the Scala collections library. \\n\\n```scala\\ndef maxDistance(path: Seq[Direction]): Int = {\\n  val breadcrumbs = path.scanLeft(origin) {\\n    case (c, d) => d.transform(c)\\n  }\\n\\n  breadcrumbs.map(c => distanceBetween(c, origin)).max\\n}\\n// maxDistance: (path: Seq[Direction])Int\\n```\\n\\nWhich can be tested and then run.\\n\\n````scala\\n\\nclass Day11Part2Test extends FunSuite with Matchers {\\n  test(\\\"Can find max distance from origin\\\") {\\n    maxDistance(parsePath(\\\"ne,ne,ne\\\")) shouldBe 3\\n    maxDistance(parsePath(\\\"ne,ne,sw,sw\\\")) shouldBe 2\\n    maxDistance(parsePath(\\\"ne,ne,sw,sw,se,se,se,nw,nw,nw\\\")) shouldBe 3\\n    maxDistance(parsePath(\\\"ne,ne,s,s\\\")) shouldBe 2\\n    maxDistance(parsePath(\\\"ne,n,nw\\\")) shouldBe 2\\n    maxDistance(parsePath(\\\"se,sw,se,sw,sw\\\")) shouldBe 3\\n  }\\n}\\n\\n(new Day11Part2Test).execute()\\n\\nmaxDistance(puzzlePath)\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/11\">Advent of Code 2017 - Day 11</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>I need to find the shortest path to the origin on an infinite hex grid after following a sequence of directions. So I set up some representations of a coordinate and a direction.</p>\n<pre><code class=\"language-scala\">case class Coordinate(x: Int, y: Int, z: Int) \n// defined class Coordinate\n\nsealed trait Direction {\n  def transform (coordinate: Coordinate): Coordinate\n}\n// defined trait Direction\n\ncase object N extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x + 1, z = c.z - 1)\n}\n// defined object N\n\ncase object NE extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x + 1, y = c.y - 1)\n}\n// defined object NE\n\ncase object SE extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(y = c.y - 1, z = c.z + 1)\n}\n// defined object SE\n\ncase object S extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x - 1, z = c.z + 1)\n}\n// defined object S\n\ncase object SW extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x - 1, y = c.y + 1)\n}\n// defined object SW\n\ncase object NW extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(y = c.y + 1, z = c.z - 1)\n}\n// defined object NW\n</code></pre>\n<p>Parsing the input is just mapping strings to the relevant case object:</p>\n<pre><code class=\"language-scala\">def parsePath(path: String): Seq[Direction] = \n  path.split(',').toSeq.collect {\n    case &quot;n&quot; =&gt; N\n    case &quot;ne&quot; =&gt; NE\n    case &quot;se&quot; =&gt; SE\n    case &quot;s&quot; =&gt; S\n    case &quot;sw&quot; =&gt; SW\n    case &quot;nw&quot; =&gt; NW\n  }\n// parsePath: (path: String)Seq[Direction]\n</code></pre>\n<p>Now I can actually write some logic. I must admit I didn't really have an<br>\nintuition for this problem, but I found a random blog post that helped,<br>\n<a href=\"http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/\">Hexagon grids: coordinate systems and distance calculations</a></p>\n<pre><code class=\"language-scala\">def distanceBetween(a: Coordinate, b: Coordinate): Int =\n  Seq(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)).max\n// distanceBetween: (a: Coordinate, b: Coordinate)Int\n\nval origin = Coordinate(0, 0, 0)\n// origin: Coordinate = Coordinate(0,0,0)\n\ndef homeDistance(path: Seq[Direction]): Int = {\n  val destination = path.foldLeft(origin) {\n    case (c, d) =&gt; d.transform(c)\n  }\n  \n  distanceBetween(destination, origin)\n}\n// homeDistance: (path: Seq[Direction])Int\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day11Part1Test extends FunSuite with Matchers {\n  test(&quot;Can find distance from origin&quot;) {\n    homeDistance(parsePath(&quot;ne,ne,ne&quot;)) shouldBe 3\n    homeDistance(parsePath(&quot;ne,ne,sw,sw&quot;)) shouldBe 0\n    homeDistance(parsePath(&quot;ne,ne,s,s&quot;)) shouldBe 2\n    homeDistance(parsePath(&quot;ne,n,nw&quot;)) shouldBe 2\n    homeDistance(parsePath(&quot;se,sw,se,sw,sw&quot;)) shouldBe 3\n  }\n}\n// defined class Day11Part1Test\n\n(new Day11Part1Test).execute()\n// Day11Part1Test:\n// - Can find distance from origin\n</code></pre>\n<p>I'm now able to find a solution for the puzzle input</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval puzzlePath = parsePath(\n  Source.fromResource(&quot;day11input.txt&quot;).mkString(&quot;&quot;).trim\n)\n// puzzlePath: Seq[Direction] = ArrayBuffer(SE, S, S, SW, SW, SW, SW, SW, SW, NW, NW, NW, SE, N, NW, NW, NW, N, N, NW, N, N, N, NE, N, NE, NE, NW, SE, N, NE, NE, N, NE, NE, NE, SW, NE, NE, N, NE, SE, SE, NE, NE, S, NE, S, NE, NW, SE, NE, NE, NE, SE, SE, SE, SE, S, SE, SE, SE, SE, NW, SE, SE, SE, SE, SE, N, S, SE, SE, SE, SE, NE, SE, S, SE, SE, S, S, NE, SE, SE, S, SE, NW, NW, NW, NE, SW, S, NW, S, SW, S, NW, S, S, NW, S, S, SW, N, S, S, SW, SW, SW, SE, N, NE, NE, S, S, SE, SW, N, S, S, SW, SW, SW, SW, S, S, NW, S, S, S, SW, S, SE, SW, SW, S, SW, SW, N, SW, S, SW, NW, SW, SW, SW, SW, SW, NE, NE, SW, NW, NW, NE, SW, NW, NW, NW, SW, SW, SW, SW, NE, SW, SW, SW, SW, SW, NW, SW, SW, SW, NE, SW, SW, SW, S, SE, NW, NW, NW, NW, SW, N, NW, NW, SW, NW, SE, NW, SW, SW, NE, SW, NW, SW, NW, NW, NW, NW, ...\n\nhomeDistance(puzzlePath)\n// res2: Int = 764\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>This is much easier, given part one. I now need to find the maximum distance<br>\nfrom the origin at any point along the path. This can be done just composing<br>\nmethods from the Scala collections library.</p>\n<pre><code class=\"language-scala\">def maxDistance(path: Seq[Direction]): Int = {\n  val breadcrumbs = path.scanLeft(origin) {\n    case (c, d) =&gt; d.transform(c)\n  }\n\n  breadcrumbs.map(c =&gt; distanceBetween(c, origin)).max\n}\n// maxDistance: (path: Seq[Direction])Int\n</code></pre>\n<p>Which can be tested and then run.</p>\n<pre><code class=\"language-scala\">\nclass Day11Part2Test extends FunSuite with Matchers {\n  test(&quot;Can find max distance from origin&quot;) {\n    maxDistance(parsePath(&quot;ne,ne,ne&quot;)) shouldBe 3\n    maxDistance(parsePath(&quot;ne,ne,sw,sw&quot;)) shouldBe 2\n    maxDistance(parsePath(&quot;ne,ne,sw,sw,se,se,se,nw,nw,nw&quot;)) shouldBe 3\n    maxDistance(parsePath(&quot;ne,ne,s,s&quot;)) shouldBe 2\n    maxDistance(parsePath(&quot;ne,n,nw&quot;)) shouldBe 2\n    maxDistance(parsePath(&quot;se,sw,se,sw,sw&quot;)) shouldBe 3\n  }\n}\n\n(new Day11Part2Test).execute()\n\nmaxDistance(puzzlePath)\n```</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a2e503c9136d71a373352c6","plaintext":"A solution for Advent of Code 2017 - Day 11\n[http://adventofcode.com/2017/day/11]\n\nPart 1\nI need to find the shortest path to the origin on an infinite hex grid after\nfollowing a sequence of directions. So I set up some representations of a\ncoordinate and a direction.\n\ncase class Coordinate(x: Int, y: Int, z: Int) \n// defined class Coordinate\n\nsealed trait Direction {\n  def transform (coordinate: Coordinate): Coordinate\n}\n// defined trait Direction\n\ncase object N extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x + 1, z = c.z - 1)\n}\n// defined object N\n\ncase object NE extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x + 1, y = c.y - 1)\n}\n// defined object NE\n\ncase object SE extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(y = c.y - 1, z = c.z + 1)\n}\n// defined object SE\n\ncase object S extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x - 1, z = c.z + 1)\n}\n// defined object S\n\ncase object SW extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(x = c.x - 1, y = c.y + 1)\n}\n// defined object SW\n\ncase object NW extends Direction {\n  override def transform(c: Coordinate): Coordinate = \n    c.copy(y = c.y + 1, z = c.z - 1)\n}\n// defined object NW\n\n\nParsing the input is just mapping strings to the relevant case object:\n\ndef parsePath(path: String): Seq[Direction] = \n  path.split(',').toSeq.collect {\n    case \"n\" => N\n    case \"ne\" => NE\n    case \"se\" => SE\n    case \"s\" => S\n    case \"sw\" => SW\n    case \"nw\" => NW\n  }\n// parsePath: (path: String)Seq[Direction]\n\n\nNow I can actually write some logic. I must admit I didn't really have an\nintuition for this problem, but I found a random blog post that helped,\nHexagon grids: coordinate systems and distance calculations\n[http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/]\n\ndef distanceBetween(a: Coordinate, b: Coordinate): Int =\n  Seq(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)).max\n// distanceBetween: (a: Coordinate, b: Coordinate)Int\n\nval origin = Coordinate(0, 0, 0)\n// origin: Coordinate = Coordinate(0,0,0)\n\ndef homeDistance(path: Seq[Direction]): Int = {\n  val destination = path.foldLeft(origin) {\n    case (c, d) => d.transform(c)\n  }\n  \n  distanceBetween(destination, origin)\n}\n// homeDistance: (path: Seq[Direction])Int\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day11Part1Test extends FunSuite with Matchers {\n  test(\"Can find distance from origin\") {\n    homeDistance(parsePath(\"ne,ne,ne\")) shouldBe 3\n    homeDistance(parsePath(\"ne,ne,sw,sw\")) shouldBe 0\n    homeDistance(parsePath(\"ne,ne,s,s\")) shouldBe 2\n    homeDistance(parsePath(\"ne,n,nw\")) shouldBe 2\n    homeDistance(parsePath(\"se,sw,se,sw,sw\")) shouldBe 3\n  }\n}\n// defined class Day11Part1Test\n\n(new Day11Part1Test).execute()\n// Day11Part1Test:\n// - Can find distance from origin\n\n\nI'm now able to find a solution for the puzzle input\n\nimport scala.io.Source\n// import scala.io.Source\n\nval puzzlePath = parsePath(\n  Source.fromResource(\"day11input.txt\").mkString(\"\").trim\n)\n// puzzlePath: Seq[Direction] = ArrayBuffer(SE, S, S, SW, SW, SW, SW, SW, SW, NW, NW, NW, SE, N, NW, NW, NW, N, N, NW, N, N, N, NE, N, NE, NE, NW, SE, N, NE, NE, N, NE, NE, NE, SW, NE, NE, N, NE, SE, SE, NE, NE, S, NE, S, NE, NW, SE, NE, NE, NE, SE, SE, SE, SE, S, SE, SE, SE, SE, NW, SE, SE, SE, SE, SE, N, S, SE, SE, SE, SE, NE, SE, S, SE, SE, S, S, NE, SE, SE, S, SE, NW, NW, NW, NE, SW, S, NW, S, SW, S, NW, S, S, NW, S, S, SW, N, S, S, SW, SW, SW, SE, N, NE, NE, S, S, SE, SW, N, S, S, SW, SW, SW, SW, S, S, NW, S, S, S, SW, S, SE, SW, SW, S, SW, SW, N, SW, S, SW, NW, SW, SW, SW, SW, SW, NE, NE, SW, NW, NW, NE, SW, NW, NW, NW, SW, SW, SW, SW, NE, SW, SW, SW, SW, SW, NW, SW, SW, SW, NE, SW, SW, SW, S, SE, NW, NW, NW, NW, SW, N, NW, NW, SW, NW, SE, NW, SW, SW, NE, SW, NW, SW, NW, NW, NW, NW, ...\n\nhomeDistance(puzzlePath)\n// res2: Int = 764\n\n\nPart 2\nThis is much easier, given part one. I now need to find the maximum distance\nfrom the origin at any point along the path. This can be done just composing\nmethods from the Scala collections library.\n\ndef maxDistance(path: Seq[Direction]): Int = {\n  val breadcrumbs = path.scanLeft(origin) {\n    case (c, d) => d.transform(c)\n  }\n\n  breadcrumbs.map(c => distanceBetween(c, origin)).max\n}\n// maxDistance: (path: Seq[Direction])Int\n\n\nWhich can be tested and then run.\n\n\nclass Day11Part2Test extends FunSuite with Matchers {\n  test(\"Can find max distance from origin\") {\n    maxDistance(parsePath(\"ne,ne,ne\")) shouldBe 3\n    maxDistance(parsePath(\"ne,ne,sw,sw\")) shouldBe 2\n    maxDistance(parsePath(\"ne,ne,sw,sw,se,se,se,nw,nw,nw\")) shouldBe 3\n    maxDistance(parsePath(\"ne,ne,s,s\")) shouldBe 2\n    maxDistance(parsePath(\"ne,n,nw\")) shouldBe 2\n    maxDistance(parsePath(\"se,sw,se,sw,sw\")) shouldBe 3\n  }\n}\n\n(new Day11Part2Test).execute()\n\nmaxDistance(puzzlePath)\n```","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-3.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-11T09:30:36.000Z","updated_at":"2017-12-20T00:39:28.000Z","published_at":"2017-12-18T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 11","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3088e09136d71a373352d2","uuid":"569391a0-b10e-42d5-a4b7-8745ece831ca","title":"Spiral Memory","slug":"aoc-2017-day-3-spiral-memory","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 3](http://adventofcode.com/2017/day/3)\\n\\n## Part 1 \\n\\nFor this I was required to find the shortest [Manhattan Distance](https://en.wikipedia.org/wiki/Taxicab_geometry) to the origin from the 347991th square to be filled when allocating sequentially in a spiral pattern.\\n\\nGiven the intuition that the grid fills in rings with edges length 2n - 1, and a shortest path can be achieved by travelling to the center of the current ring,then walking to the center through the inner rings the distance can be determined using a simple formula.\\n\\n```scala\\ndef calcDistance(pos: Int): Int = {\\n  // prevent / 0 errors\\n  if(pos == 1) return 0\\n\\n  val ring: Int = Math.ceil(Math.sqrt(pos.toFloat)).toInt / 2 \\n  val sidePos: Int = ((Math.pow(ring * 2 + 1, 2) - pos).toInt % (ring * 2)) - ring\\n  \\n  ring + Math.abs(sidePos)\\n}\\n// calcDistance: (pos: Int)Int\\n```   \\n\\nI have a feeling that for part two, my plan to use a formula rather than just building the grid may leave me having to implement the grid anyway for the variant on the theme. First I need to check my maths with the provided examples; there is a lot of potential to get rounding and out-by-one errors here.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day3Part1Test extends FunSuite with Matchers {\\n  test(\\\"Can calculate distance\\\"){\\n    calcDistance(1) shouldBe 0\\n    calcDistance(12) shouldBe 3\\n    calcDistance(23) shouldBe 2\\n    calcDistance(1024) shouldBe 31\\n  }\\n}\\n// defined class Day3Part1Test\\n\\n(new Day3Part1Test).execute()\\n// Day3Part1Test:\\n// - Can calculate distance\\n``` \\n\\nGiven those work I can plug in the puzzle location\\n\\n```scala\\ncalcDistance(347991)\\n// res1: Int = 480\\n```\\n\\n## Part 2\\n\\nFor this the grid is filled by summing the adjacent grid squares. I couldn't intuit way to calculate it based on the geometry as above, so just decided to build the grid. \\n\\nGiven that the number will more than double as it rounds each corner of the spiral, 347991 log<sub>16</sub> rings (6) should be enough. For ease of calculation I'm summing all adjacent squares, so I'll need an extra ring (7) to prevent overflow there. This means the puzzle should fit in a 13 x 13 grid (2n - 1), with the origin at (6,6).\\n\\nTo keep track of how to progress around the spiral path, I'll generate a sequence of movements for each ring when the previous ring is completed. \\n\\nThe steps for each cell are:\\n1. Calculate the current value by summing adjacent cells, minimum 1 for the seed cell.\\n2. Check if the target has been exceeded?\\n    * Yes: Calculation complete: return the value\\n    * No : Iterate with the calculated value in the current cell \\n3. Iterate to the next position, calculating the sequence of moves for the next ring if the previous one has been exhausted.\\n\\n```scala\\ndef calcSweepValue(target: Int): Int = {\\n  val adjacentCells = Seq(\\n    (-1, -1), ( 0, -1), ( 1, -1),\\n    (-1,  0),           ( 1,  0),\\n    (-1,  1), ( 0,  1), ( 1,  1)\\n  )\\n  \\n  def buildDirections(ring: Int): Seq[(Int, Int)] =\\n    Seq(\\n      Seq.fill(2 * ring - 1)((0, -1)),\\n      Seq.fill(2 * ring)((-1, 0)),\\n      Seq.fill(2 * ring)((0, 1)),\\n      Seq.fill(2 * ring)((1, 0))\\n    ).flatten\\n \\n  \\n  def iter(matrix: Vector[Vector[Int]], \\n           pos: (Int, Int), \\n           directions: Seq[(Int,Int)],\\n           ring: Int): Int = {\\n    val (x, y) = pos\\n    val currentValue: Int = \\n      Math.max(\\n        adjacentCells.foldLeft(0){\\n            case (acc, (px, py)) => acc + matrix(x + px)(y + py)\\n        },\\n        1\\n      )\\n    \\n    directions match {\\n      case _ if currentValue > target => \\n        currentValue\\n      case Nil => \\n        iter(\\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\\n          (x + 1, y),\\n          buildDirections(ring),\\n          ring + 1\\n        )\\n      case (dx, dy) +: ds =>\\n        iter(\\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\\n          (x + dx, y + dy),\\n          ds,\\n          ring\\n        )\\n    }\\n  }\\n  \\n  iter(\\n    Vector.fill(13, 13)(0),\\n    (6, 6),\\n    Seq(),\\n    1\\n  )\\n}\\n// calcSweepValue: (target: Int)Int\\n```\\n\\nI built some tests from the diagram of the grid start on the puzzle page. \\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day3Part2Test extends FunSuite with Matchers {\\n  test(\\\"Can calculate next inserted value after target\\\"){\\n    calcSweepValue(1) shouldBe 2\\n    calcSweepValue(3) shouldBe 4\\n    calcSweepValue(24) shouldBe 25\\n    calcSweepValue(25) shouldBe 26\\n    calcSweepValue(26) shouldBe 54\\n    calcSweepValue(800) shouldBe 806\\n  }\\n}\\n// defined class Day3Part2Test\\n\\n(new Day3Part2Test).execute()\\n// Day3Part2Test:\\n// - Can calculate next inserted value after target\\n``` \\n\\nWith those passing, I can now complete the puzzle.\\n\\n```scala\\n  calcSweepValue(347991)\\n// res3: Int = 349975\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/3\">Advent of Code 2017 - Day 3</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>For this I was required to find the shortest <a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\">Manhattan Distance</a> to the origin from the 347991th square to be filled when allocating sequentially in a spiral pattern.</p>\n<p>Given the intuition that the grid fills in rings with edges length 2n - 1, and a shortest path can be achieved by travelling to the center of the current ring,then walking to the center through the inner rings the distance can be determined using a simple formula.</p>\n<pre><code class=\"language-scala\">def calcDistance(pos: Int): Int = {\n  // prevent / 0 errors\n  if(pos == 1) return 0\n\n  val ring: Int = Math.ceil(Math.sqrt(pos.toFloat)).toInt / 2 \n  val sidePos: Int = ((Math.pow(ring * 2 + 1, 2) - pos).toInt % (ring * 2)) - ring\n  \n  ring + Math.abs(sidePos)\n}\n// calcDistance: (pos: Int)Int\n</code></pre>\n<p>I have a feeling that for part two, my plan to use a formula rather than just building the grid may leave me having to implement the grid anyway for the variant on the theme. First I need to check my maths with the provided examples; there is a lot of potential to get rounding and out-by-one errors here.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day3Part1Test extends FunSuite with Matchers {\n  test(&quot;Can calculate distance&quot;){\n    calcDistance(1) shouldBe 0\n    calcDistance(12) shouldBe 3\n    calcDistance(23) shouldBe 2\n    calcDistance(1024) shouldBe 31\n  }\n}\n// defined class Day3Part1Test\n\n(new Day3Part1Test).execute()\n// Day3Part1Test:\n// - Can calculate distance\n</code></pre>\n<p>Given those work I can plug in the puzzle location</p>\n<pre><code class=\"language-scala\">calcDistance(347991)\n// res1: Int = 480\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For this the grid is filled by summing the adjacent grid squares. I couldn't intuit way to calculate it based on the geometry as above, so just decided to build the grid.</p>\n<p>Given that the number will more than double as it rounds each corner of the spiral, 347991 log<sub>16</sub> rings (6) should be enough. For ease of calculation I'm summing all adjacent squares, so I'll need an extra ring (7) to prevent overflow there. This means the puzzle should fit in a 13 x 13 grid (2n - 1), with the origin at (6,6).</p>\n<p>To keep track of how to progress around the spiral path, I'll generate a sequence of movements for each ring when the previous ring is completed.</p>\n<p>The steps for each cell are:</p>\n<ol>\n<li>Calculate the current value by summing adjacent cells, minimum 1 for the seed cell.</li>\n<li>Check if the target has been exceeded?\n<ul>\n<li>Yes: Calculation complete: return the value</li>\n<li>No : Iterate with the calculated value in the current cell</li>\n</ul>\n</li>\n<li>Iterate to the next position, calculating the sequence of moves for the next ring if the previous one has been exhausted.</li>\n</ol>\n<pre><code class=\"language-scala\">def calcSweepValue(target: Int): Int = {\n  val adjacentCells = Seq(\n    (-1, -1), ( 0, -1), ( 1, -1),\n    (-1,  0),           ( 1,  0),\n    (-1,  1), ( 0,  1), ( 1,  1)\n  )\n  \n  def buildDirections(ring: Int): Seq[(Int, Int)] =\n    Seq(\n      Seq.fill(2 * ring - 1)((0, -1)),\n      Seq.fill(2 * ring)((-1, 0)),\n      Seq.fill(2 * ring)((0, 1)),\n      Seq.fill(2 * ring)((1, 0))\n    ).flatten\n \n  \n  def iter(matrix: Vector[Vector[Int]], \n           pos: (Int, Int), \n           directions: Seq[(Int,Int)],\n           ring: Int): Int = {\n    val (x, y) = pos\n    val currentValue: Int = \n      Math.max(\n        adjacentCells.foldLeft(0){\n            case (acc, (px, py)) =&gt; acc + matrix(x + px)(y + py)\n        },\n        1\n      )\n    \n    directions match {\n      case _ if currentValue &gt; target =&gt; \n        currentValue\n      case Nil =&gt; \n        iter(\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\n          (x + 1, y),\n          buildDirections(ring),\n          ring + 1\n        )\n      case (dx, dy) +: ds =&gt;\n        iter(\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\n          (x + dx, y + dy),\n          ds,\n          ring\n        )\n    }\n  }\n  \n  iter(\n    Vector.fill(13, 13)(0),\n    (6, 6),\n    Seq(),\n    1\n  )\n}\n// calcSweepValue: (target: Int)Int\n</code></pre>\n<p>I built some tests from the diagram of the grid start on the puzzle page.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day3Part2Test extends FunSuite with Matchers {\n  test(&quot;Can calculate next inserted value after target&quot;){\n    calcSweepValue(1) shouldBe 2\n    calcSweepValue(3) shouldBe 4\n    calcSweepValue(24) shouldBe 25\n    calcSweepValue(25) shouldBe 26\n    calcSweepValue(26) shouldBe 54\n    calcSweepValue(800) shouldBe 806\n  }\n}\n// defined class Day3Part2Test\n\n(new Day3Part2Test).execute()\n// Day3Part2Test:\n// - Can calculate next inserted value after target\n</code></pre>\n<p>With those passing, I can now complete the puzzle.</p>\n<pre><code class=\"language-scala\">  calcSweepValue(347991)\n// res3: Int = 349975\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3088e09136d71a373352d2","plaintext":"A solution for Advent of Code 2017 - Day 3 [http://adventofcode.com/2017/day/3]\n\nPart 1\nFor this I was required to find the shortest Manhattan Distance\n[https://en.wikipedia.org/wiki/Taxicab_geometry] to the origin from the 347991th\nsquare to be filled when allocating sequentially in a spiral pattern.\n\nGiven the intuition that the grid fills in rings with edges length 2n - 1, and a\nshortest path can be achieved by travelling to the center of the current\nring,then walking to the center through the inner rings the distance can be\ndetermined using a simple formula.\n\ndef calcDistance(pos: Int): Int = {\n  // prevent / 0 errors\n  if(pos == 1) return 0\n\n  val ring: Int = Math.ceil(Math.sqrt(pos.toFloat)).toInt / 2 \n  val sidePos: Int = ((Math.pow(ring * 2 + 1, 2) - pos).toInt % (ring * 2)) - ring\n  \n  ring + Math.abs(sidePos)\n}\n// calcDistance: (pos: Int)Int\n\n\nI have a feeling that for part two, my plan to use a formula rather than just\nbuilding the grid may leave me having to implement the grid anyway for the\nvariant on the theme. First I need to check my maths with the provided examples;\nthere is a lot of potential to get rounding and out-by-one errors here.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day3Part1Test extends FunSuite with Matchers {\n  test(\"Can calculate distance\"){\n    calcDistance(1) shouldBe 0\n    calcDistance(12) shouldBe 3\n    calcDistance(23) shouldBe 2\n    calcDistance(1024) shouldBe 31\n  }\n}\n// defined class Day3Part1Test\n\n(new Day3Part1Test).execute()\n// Day3Part1Test:\n// - Can calculate distance\n\n\nGiven those work I can plug in the puzzle location\n\ncalcDistance(347991)\n// res1: Int = 480\n\n\nPart 2\nFor this the grid is filled by summing the adjacent grid squares. I couldn't\nintuit way to calculate it based on the geometry as above, so just decided to\nbuild the grid.\n\nGiven that the number will more than double as it rounds each corner of the\nspiral, 347991 log16 rings (6) should be enough. For ease of calculation I'm\nsumming all adjacent squares, so I'll need an extra ring (7) to prevent overflow\nthere. This means the puzzle should fit in a 13 x 13 grid (2n - 1), with the\norigin at (6,6).\n\nTo keep track of how to progress around the spiral path, I'll generate a\nsequence of movements for each ring when the previous ring is completed.\n\nThe steps for each cell are:\n\n 1. Calculate the current value by summing adjacent cells, minimum 1 for the\n    seed cell.\n 2. Check if the target has been exceeded? * Yes: Calculation complete: return\n       the value\n     * No : Iterate with the calculated\n       value in the current cell\n    \n    \n 3. Iterate to the next position, calculating the sequence of moves for the next\n    ring if the previous one has been exhausted.\n\ndef calcSweepValue(target: Int): Int = {\n  val adjacentCells = Seq(\n    (-1, -1), ( 0, -1), ( 1, -1),\n    (-1,  0),           ( 1,  0),\n    (-1,  1), ( 0,  1), ( 1,  1)\n  )\n  \n  def buildDirections(ring: Int): Seq[(Int, Int)] =\n    Seq(\n      Seq.fill(2 * ring - 1)((0, -1)),\n      Seq.fill(2 * ring)((-1, 0)),\n      Seq.fill(2 * ring)((0, 1)),\n      Seq.fill(2 * ring)((1, 0))\n    ).flatten\n \n  \n  def iter(matrix: Vector[Vector[Int]], \n           pos: (Int, Int), \n           directions: Seq[(Int,Int)],\n           ring: Int): Int = {\n    val (x, y) = pos\n    val currentValue: Int = \n      Math.max(\n        adjacentCells.foldLeft(0){\n            case (acc, (px, py)) => acc + matrix(x + px)(y + py)\n        },\n        1\n      )\n    \n    directions match {\n      case _ if currentValue > target => \n        currentValue\n      case Nil => \n        iter(\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\n          (x + 1, y),\n          buildDirections(ring),\n          ring + 1\n        )\n      case (dx, dy) +: ds =>\n        iter(\n          matrix.updated(x, matrix(x).updated(y, currentValue)),\n          (x + dx, y + dy),\n          ds,\n          ring\n        )\n    }\n  }\n  \n  iter(\n    Vector.fill(13, 13)(0),\n    (6, 6),\n    Seq(),\n    1\n  )\n}\n// calcSweepValue: (target: Int)Int\n\n\nI built some tests from the diagram of the grid start on the puzzle page.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day3Part2Test extends FunSuite with Matchers {\n  test(\"Can calculate next inserted value after target\"){\n    calcSweepValue(1) shouldBe 2\n    calcSweepValue(3) shouldBe 4\n    calcSweepValue(24) shouldBe 25\n    calcSweepValue(25) shouldBe 26\n    calcSweepValue(26) shouldBe 54\n    calcSweepValue(800) shouldBe 806\n  }\n}\n// defined class Day3Part2Test\n\n(new Day3Part2Test).execute()\n// Day3Part2Test:\n// - Can calculate next inserted value after target\n\n\nWith those passing, I can now complete the puzzle.\n\n  calcSweepValue(347991)\n// res3: Int = 349975","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-4.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-13T01:56:48.000Z","updated_at":"2017-12-13T22:56:06.000Z","published_at":"2017-12-10T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 3","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a31af2a9136d71a373352da","uuid":"94e76ca2-d11f-4c0d-ad18-8a2285ce5fb8","title":"Inverse Captcha","slug":"aoc2017-day-1-inverse-captcha","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 1](http://adventofcode.com/2017/day/1)\\n\\n... And we're off. I shall be briefly documenting my solutions to each of the puzzled in the 2017 Advent of Code. Whilst I'll be completing the puzzles on the day I'm planning to schedule the write-ups to appear one week later. \\n\\n## Part 1 \\n\\nThe aim is to fool a computer that I'm a computer, so I shall be talking to it with code. The challenge is to sum repeated digits in a long sequence of them. It is a challenge particularly suited to composing the built in functions of the Scala collections library to produce a simple(ish), solution that reads like a recipe. The only slight spanner in the works is the list is cyclical so the final digit needs to be checked against the first. \\n\\n```scala\\ndef sumDuplicates(digits: Seq[Int]): Int = (\\n  digits\\n    .zip(digits.tail :+ digits.head)\\n    .collect { case (a, b) if a == b => a }\\n    .sum\\n  )\\n// sumDuplicates: (digits: Seq[Int])Int\\n``` \\n> I'm intending to do a write up of the process used to generate the code samples in these write-ups, but the plugin I'm using doesn't work out statement termination as well as the full scala compiler. Hence you may see occasional superfluous parentheses as compiler hints.\\n\\nNow I should check my working; especially since the puzzle kindly included some test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day1Part1Test extends FunSuite with Matchers {\\n  test(\\\"can Sum Duplicates\\\") {\\n    sumDuplicates(\\\"1122\\\".map(_.asDigit)) shouldBe 3\\n    sumDuplicates(\\\"1111\\\".map(_.asDigit)) shouldBe 4\\n    sumDuplicates(\\\"1234\\\".map(_.asDigit)) shouldBe 0\\n    sumDuplicates(\\\"91212129\\\".map(_.asDigit)) shouldBe 9\\n    sumDuplicates(\\\"91222129\\\".map(_.asDigit)) shouldBe 13\\n  }\\n}\\n// defined class Day1Part1Test\\n\\n(new Day1Part1Test).execute()\\n// Day1Part1Test:\\n// - can Sum Duplicates\\n```\\n\\nPassing in my puzzle input, and the !captcha is partially fooled:\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input: Seq[Int] = Source.fromResource(\\\"day1input.txt\\\").mkString(\\\"\\\").trim.map(_.asDigit)\\n// input: Seq[Int] = Vector(4, 2, 8, 1, 2, 2, 4, 9, 8, 9, 9, 7, 5, 8, 7, 2, 8, 3, 9, 9, 6, 1, 1, 6, 9, 5, 1, 3, 9, 7, 9, 5, 7, 9, 3, 3, 5...\\n\\nsumDuplicates(input)\\n// res1: Int = 1034\\n```\\n\\n## Part 2\\n\\nThe second part is normally some form of extension of the first. In this case I now need to compare each digit to its mirror; the digit half-way round the circular list. I can pretty much reuse my initial solution, but change how the pairs are built. Additionally for each pair, the inverse pair will also match.\\n\\n```scala\\ndef sumMirrors(digits: Seq[Int]): Int = {\\n  val (first, second) =\\n    digits.splitAt(digits.length / 2)\\n  \\n  (first\\n    .zip(second)\\n    .collect { case (a, b) if a == b => a * 2 }\\n    .sum\\n  )\\n}\\n// sumMirrors: (digits: Seq[Int])Int\\n```\\n\\nAs before there are some test cases provided.\\n\\n```scala\\nclass Day1Part2Test extends FunSuite with Matchers {\\n  test(\\\"can Sum Mirrors\\\") {\\n      sumMirrors(\\\"1212\\\".map(_.asDigit)) shouldBe 6\\n      sumMirrors(\\\"1221\\\".map(_.asDigit)) shouldBe 0\\n      sumMirrors(\\\"123425\\\".map(_.asDigit)) shouldBe 4\\n      sumMirrors(\\\"123123\\\".map(_.asDigit)) shouldBe 12\\n      sumMirrors(\\\"12131415\\\".map(_.asDigit)) shouldBe 4\\n    }\\n}\\n// defined class Day1Part2Test\\n\\n(new Day1Part2Test).execute()\\n// Day1Part2Test:\\n// - can Sum Mirrors\\n```\\n\\nAnd the puzzle input is reused\\n\\n```scala\\nsumMirrors(input)\\n// res3: Int = 1356\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/1\">Advent of Code 2017 - Day 1</a></p>\n<p>... And we're off. I shall be briefly documenting my solutions to each of the puzzled in the 2017 Advent of Code. Whilst I'll be completing the puzzles on the day I'm planning to schedule the write-ups to appear one week later.</p>\n<h2 id=\"part1\">Part 1</h2>\n<p>The aim is to fool a computer that I'm a computer, so I shall be talking to it with code. The challenge is to sum repeated digits in a long sequence of them. It is a challenge particularly suited to composing the built in functions of the Scala collections library to produce a simple(ish), solution that reads like a recipe. The only slight spanner in the works is the list is cyclical so the final digit needs to be checked against the first.</p>\n<pre><code class=\"language-scala\">def sumDuplicates(digits: Seq[Int]): Int = (\n  digits\n    .zip(digits.tail :+ digits.head)\n    .collect { case (a, b) if a == b =&gt; a }\n    .sum\n  )\n// sumDuplicates: (digits: Seq[Int])Int\n</code></pre>\n<blockquote>\n<p>I'm intending to do a write up of the process used to generate the code samples in these write-ups, but the plugin I'm using doesn't work out statement termination as well as the full scala compiler. Hence you may see occasional superfluous parentheses as compiler hints.</p>\n</blockquote>\n<p>Now I should check my working; especially since the puzzle kindly included some test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day1Part1Test extends FunSuite with Matchers {\n  test(&quot;can Sum Duplicates&quot;) {\n    sumDuplicates(&quot;1122&quot;.map(_.asDigit)) shouldBe 3\n    sumDuplicates(&quot;1111&quot;.map(_.asDigit)) shouldBe 4\n    sumDuplicates(&quot;1234&quot;.map(_.asDigit)) shouldBe 0\n    sumDuplicates(&quot;91212129&quot;.map(_.asDigit)) shouldBe 9\n    sumDuplicates(&quot;91222129&quot;.map(_.asDigit)) shouldBe 13\n  }\n}\n// defined class Day1Part1Test\n\n(new Day1Part1Test).execute()\n// Day1Part1Test:\n// - can Sum Duplicates\n</code></pre>\n<p>Passing in my puzzle input, and the !captcha is partially fooled:</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input: Seq[Int] = Source.fromResource(&quot;day1input.txt&quot;).mkString(&quot;&quot;).trim.map(_.asDigit)\n// input: Seq[Int] = Vector(4, 2, 8, 1, 2, 2, 4, 9, 8, 9, 9, 7, 5, 8, 7, 2, 8, 3, 9, 9, 6, 1, 1, 6, 9, 5, 1, 3, 9, 7, 9, 5, 7, 9, 3, 3, 5...\n\nsumDuplicates(input)\n// res1: Int = 1034\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>The second part is normally some form of extension of the first. In this case I now need to compare each digit to its mirror; the digit half-way round the circular list. I can pretty much reuse my initial solution, but change how the pairs are built. Additionally for each pair, the inverse pair will also match.</p>\n<pre><code class=\"language-scala\">def sumMirrors(digits: Seq[Int]): Int = {\n  val (first, second) =\n    digits.splitAt(digits.length / 2)\n  \n  (first\n    .zip(second)\n    .collect { case (a, b) if a == b =&gt; a * 2 }\n    .sum\n  )\n}\n// sumMirrors: (digits: Seq[Int])Int\n</code></pre>\n<p>As before there are some test cases provided.</p>\n<pre><code class=\"language-scala\">class Day1Part2Test extends FunSuite with Matchers {\n  test(&quot;can Sum Mirrors&quot;) {\n      sumMirrors(&quot;1212&quot;.map(_.asDigit)) shouldBe 6\n      sumMirrors(&quot;1221&quot;.map(_.asDigit)) shouldBe 0\n      sumMirrors(&quot;123425&quot;.map(_.asDigit)) shouldBe 4\n      sumMirrors(&quot;123123&quot;.map(_.asDigit)) shouldBe 12\n      sumMirrors(&quot;12131415&quot;.map(_.asDigit)) shouldBe 4\n    }\n}\n// defined class Day1Part2Test\n\n(new Day1Part2Test).execute()\n// Day1Part2Test:\n// - can Sum Mirrors\n</code></pre>\n<p>And the puzzle input is reused</p>\n<pre><code class=\"language-scala\">sumMirrors(input)\n// res3: Int = 1356\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a31af2a9136d71a373352da","plaintext":"A solution for Advent of Code 2017 - Day 1 [http://adventofcode.com/2017/day/1]\n\n... And we're off. I shall be briefly documenting my solutions to each of the\npuzzled in the 2017 Advent of Code. Whilst I'll be completing the puzzles on the\nday I'm planning to schedule the write-ups to appear one week later.\n\nPart 1\nThe aim is to fool a computer that I'm a computer, so I shall be talking to it\nwith code. The challenge is to sum repeated digits in a long sequence of them.\nIt is a challenge particularly suited to composing the built in functions of the\nScala collections library to produce a simple(ish), solution that reads like a\nrecipe. The only slight spanner in the works is the list is cyclical so the\nfinal digit needs to be checked against the first.\n\ndef sumDuplicates(digits: Seq[Int]): Int = (\n  digits\n    .zip(digits.tail :+ digits.head)\n    .collect { case (a, b) if a == b => a }\n    .sum\n  )\n// sumDuplicates: (digits: Seq[Int])Int\n\n\n> I'm intending to do a write up of the process used to generate the code samples\nin these write-ups, but the plugin I'm using doesn't work out statement\ntermination as well as the full scala compiler. Hence you may see occasional\nsuperfluous parentheses as compiler hints.\n\n\nNow I should check my working; especially since the puzzle kindly included some\ntest cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day1Part1Test extends FunSuite with Matchers {\n  test(\"can Sum Duplicates\") {\n    sumDuplicates(\"1122\".map(_.asDigit)) shouldBe 3\n    sumDuplicates(\"1111\".map(_.asDigit)) shouldBe 4\n    sumDuplicates(\"1234\".map(_.asDigit)) shouldBe 0\n    sumDuplicates(\"91212129\".map(_.asDigit)) shouldBe 9\n    sumDuplicates(\"91222129\".map(_.asDigit)) shouldBe 13\n  }\n}\n// defined class Day1Part1Test\n\n(new Day1Part1Test).execute()\n// Day1Part1Test:\n// - can Sum Duplicates\n\n\nPassing in my puzzle input, and the !captcha is partially fooled:\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input: Seq[Int] = Source.fromResource(\"day1input.txt\").mkString(\"\").trim.map(_.asDigit)\n// input: Seq[Int] = Vector(4, 2, 8, 1, 2, 2, 4, 9, 8, 9, 9, 7, 5, 8, 7, 2, 8, 3, 9, 9, 6, 1, 1, 6, 9, 5, 1, 3, 9, 7, 9, 5, 7, 9, 3, 3, 5...\n\nsumDuplicates(input)\n// res1: Int = 1034\n\n\nPart 2\nThe second part is normally some form of extension of the first. In this case I\nnow need to compare each digit to its mirror; the digit half-way round the\ncircular list. I can pretty much reuse my initial solution, but change how the\npairs are built. Additionally for each pair, the inverse pair will also match.\n\ndef sumMirrors(digits: Seq[Int]): Int = {\n  val (first, second) =\n    digits.splitAt(digits.length / 2)\n  \n  (first\n    .zip(second)\n    .collect { case (a, b) if a == b => a * 2 }\n    .sum\n  )\n}\n// sumMirrors: (digits: Seq[Int])Int\n\n\nAs before there are some test cases provided.\n\nclass Day1Part2Test extends FunSuite with Matchers {\n  test(\"can Sum Mirrors\") {\n      sumMirrors(\"1212\".map(_.asDigit)) shouldBe 6\n      sumMirrors(\"1221\".map(_.asDigit)) shouldBe 0\n      sumMirrors(\"123425\".map(_.asDigit)) shouldBe 4\n      sumMirrors(\"123123\".map(_.asDigit)) shouldBe 12\n      sumMirrors(\"12131415\".map(_.asDigit)) shouldBe 4\n    }\n}\n// defined class Day1Part2Test\n\n(new Day1Part2Test).execute()\n// Day1Part2Test:\n// - can Sum Mirrors\n\n\nAnd the puzzle input is reused\n\nsumMirrors(input)\n// res3: Int = 1356","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-5.png","featured":1,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-13T22:52:26.000Z","updated_at":"2017-12-14T23:58:08.000Z","published_at":"2017-12-08T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 1","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a31b3959136d71a373352e1","uuid":"18e5f3fc-20de-4ab2-af2d-c1664d2aafba","title":"High-Entropy Passphrases","slug":"aoc-2017-day-4-high-entropy-passphrases","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"# High-Entropy Passphrases\\n\\nA solution for [Advent of Code 2017 - Day 4](http://adventofcode.com/2017/day/4)\\n\\n## Part 1\\n\\nToday's goal is to throw out a bunch of insecure passphrases. Specifically those with duplicate words. I can see Sets being my friend.\\n\\n```scala\\ndef iterSecure(words: List[String], seen: Set[String] = Set.empty): Boolean = (\\n  words match {\\n    case Nil => true\\n    case word :: _ if seen.contains(word) => false\\n    case word :: rest => iterSecure(rest, seen + word)\\n  }\\n)\\n// iterSecure: (words: List[String], seen: Set[String])Boolean\\n\\ndef isSecure(passphrase: String): Boolean = iterSecure(passphrase.split(\\\" \\\").toList, Set.empty)\\n// isSecure: (passphrase: String)Boolean\\n\\ndef countSecure(passphrases: Seq[String]): Int = passphrases.count(isSecure)\\n// countSecure: (passphrases: Seq[String])Int\\n```\\n\\nThe recursive `iterSecure` was originally written inside isSecure as just iter. A pattern I often use that keeps the implementation-only arguments in the recursion hidden from the outside world. It then turned out part two needed to call it in a subtly different way, so I lifted it out to a def.\\n\\nThere were some examples to use as test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day4Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can test a phrase is secure\\\") {\\n    isSecure(\\\"aa bb cc dd ee\\\") shouldBe true\\n    isSecure(\\\"aa bb cc dd aa\\\") shouldBe false\\n    isSecure(\\\"aa bb cc dd aaa\\\") shouldBe true\\n    isSecure(\\\"ab\\\") shouldBe true\\n    isSecure(\\\"a b\\\") shouldBe true\\n    isSecure(\\\"a a\\\") shouldBe false\\n    isSecure(\\\"a a a\\\") shouldBe false\\n\\n    isSecure(\\\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\\\") shouldBe true\\n    isSecure(\\\"xmuf znkhaes pggrlp zia znkhaes znkhaes\\\") shouldBe false\\n    isSecure(\\\"nti rxr bogebb zdwrin\\\") shouldBe true\\n    isSecure(\\\"sryookh unrudn zrkz jxhrdo gctlyz\\\") shouldBe true\\n    isSecure(\\\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\\\") shouldBe true\\n    isSecure(\\\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\\\") shouldBe true\\n\\n  }\\n\\n  test(\\\"can count secure phrases\\\") {\\n    countSecure(Seq(\\\"aa bb\\\")) shouldBe 1\\n    countSecure(Seq(\\\"aa bb\\\", \\\"aa bb\\\")) shouldBe 2\\n    countSecure(Seq(\\\"aa aa\\\", \\\"aa aa\\\")) shouldBe 0\\n    countSecure(Seq(\\\"aa aa\\\", \\\"aa bb\\\")) shouldBe 1\\n    countSecure(Seq(\\\"aa bb\\\")) shouldBe 1\\n\\n    countSecure(Seq(\\n      \\\"aa bb cc dd ee\\\",\\n      \\\"aa bb cc dd aa\\\",\\n      \\\"aa bb cc dd aaa\\\",\\n      \\\"ab\\\",\\n      \\\"a b\\\",\\n      \\\"a a\\\",\\n      \\\"a a a\\\"\\n    )) shouldBe 4\\n\\n    countSecure(Seq(\\n      \\\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\\\",\\n      \\\"xmuf znkhaes pggrlp zia znkhaes znkhaes\\\",\\n      \\\"nti rxr bogebb zdwrin\\\",\\n      \\\"sryookh unrudn zrkz jxhrdo gctlyz\\\",\\n      \\\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\\\",\\n      \\\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\\\"\\n    )) shouldBe 5\\n\\n  }\\n}\\n// defined class Day4Part1Test\\n\\n(new Day4Part1Test).execute()\\n// Day4Part1Test:\\n// - can test a phrase is secure\\n// - can count secure phrases\\n```\\n\\nI can now run against the test input\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = Source.fromResource(\\\"day4input.txt\\\").getLines().toSeq\\n// input: Seq[String] = Stream(sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp, ?)\\n\\ncountSecure(input)\\n// res1: Int = 383\\n```\\n\\n## Part 2\\n\\nFor part two, the validator now needs to reject duplicate anagrams as well. This can be achieved by sorting each word alphabetically, which reduces the problem to the same one solved in part one.\\n\\n```scala\\ndef isReallySecure(passphrase: String): \\n  Boolean = iterSecure(passphrase.split(\\\" \\\").toList.map(s => s.sorted))\\n// isReallySecure: (passphrase: String)Boolean\\n\\ndef countReallySecure(passphrases: Seq[String]): \\n  Int = passphrases.count(isReallySecure)\\n// countReallySecure: (passphrases: Seq[String])Int\\n```\\n\\nThere are some more test cases, and some of the previous ones can be reused with\\nslightly different answers\\n\\n```scala\\nclass Day4Part2Test extends FunSuite with Matchers {\\n  test(\\\"can test a phrase is *really* secure\\\") {\\n\\n    isReallySecure(\\\"aa bb cc dd ee\\\") shouldBe true\\n    isReallySecure(\\\"aa bb cc dd aa\\\") shouldBe false\\n    isReallySecure(\\\"aa bb cc dd aaa\\\") shouldBe true\\n    isReallySecure(\\\"ab\\\") shouldBe true\\n    isReallySecure(\\\"ab ba\\\") shouldBe false\\n    isReallySecure(\\\"a b\\\") shouldBe true\\n    isReallySecure(\\\"a a\\\") shouldBe false\\n    isReallySecure(\\\"a a a\\\") shouldBe false\\n\\n\\n    isReallySecure(\\\"abcde fghij\\\") shouldBe true\\n    isReallySecure(\\\"abcde xyz ecdab\\\") shouldBe false\\n    isReallySecure(\\\"a ab abc abd abf abj\\\") shouldBe true\\n    isReallySecure(\\\"iiii oiii ooii oooi oooo\\\") shouldBe true\\n    isReallySecure(\\\"oiii ioii iioi iiio\\\") shouldBe false\\n\\n\\n    isReallySecure(\\\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\\\") shouldBe true\\n    isReallySecure(\\\"xmuf znkhaes pggrlp zia znkhaes znkhaes\\\") shouldBe false\\n    isReallySecure(\\\"nti rxr bogebb zdwrin\\\") shouldBe true\\n    isReallySecure(\\\"sryookh unrudn zrkz jxhrdo gctlyz\\\") shouldBe true\\n    isReallySecure(\\\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\\\") shouldBe false\\n    isReallySecure(\\\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\\\") shouldBe true\\n  }\\n\\n  test(\\\"can count *really* secure phrases\\\") {\\n\\n    countReallySecure(Seq(\\n      \\\"aa bb cc dd ee\\\",\\n      \\\"aa bb cc dd aa\\\",\\n      \\\"aa bb cc dd aaa\\\",\\n      \\\"ab\\\",\\n      \\\"ab ba\\\",\\n      \\\"a b\\\",\\n      \\\"a a\\\",\\n      \\\"a a a\\\"\\n    )) shouldBe 4\\n\\n    countReallySecure(Seq(\\n      \\\"abcde fghij\\\",\\n      \\\"abcde xyz ecdab\\\",\\n      \\\"a ab abc abd abf abj\\\",\\n      \\\"iiii oiii ooii oooi oooo\\\",\\n      \\\"oiii ioii iioi iiio\\\"\\n    )) shouldBe 3\\n\\n    countReallySecure(Seq(\\n      \\\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\\\",\\n      \\\"xmuf znkhaes pggrlp zia znkhaes znkhaes\\\",\\n      \\\"nti rxr bogebb zdwrin\\\",\\n      \\\"sryookh unrudn zrkz jxhrdo gctlyz\\\",\\n      \\\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\\\",\\n      \\\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\\\"\\n    )) shouldBe 4\\n  }\\n}\\n// defined class Day4Part2Test\\n\\n(new Day4Part2Test).execute()\\n// Day4Part2Test:\\n// - can test a phrase is *really* secure\\n// - can count *really* secure phrases\\n```\\n\\nAll that is left is to run with the puzzle input\\n\\n```scala\\ncountReallySecure(input)\\n// res3: Int = 265\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><h1 id=\"highentropypassphrases\">High-Entropy Passphrases</h1>\n<p>A solution for <a href=\"http://adventofcode.com/2017/day/4\">Advent of Code 2017 - Day 4</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today's goal is to throw out a bunch of insecure passphrases. Specifically those with duplicate words. I can see Sets being my friend.</p>\n<pre><code class=\"language-scala\">def iterSecure(words: List[String], seen: Set[String] = Set.empty): Boolean = (\n  words match {\n    case Nil =&gt; true\n    case word :: _ if seen.contains(word) =&gt; false\n    case word :: rest =&gt; iterSecure(rest, seen + word)\n  }\n)\n// iterSecure: (words: List[String], seen: Set[String])Boolean\n\ndef isSecure(passphrase: String): Boolean = iterSecure(passphrase.split(&quot; &quot;).toList, Set.empty)\n// isSecure: (passphrase: String)Boolean\n\ndef countSecure(passphrases: Seq[String]): Int = passphrases.count(isSecure)\n// countSecure: (passphrases: Seq[String])Int\n</code></pre>\n<p>The recursive <code>iterSecure</code> was originally written inside isSecure as just iter. A pattern I often use that keeps the implementation-only arguments in the recursion hidden from the outside world. It then turned out part two needed to call it in a subtly different way, so I lifted it out to a def.</p>\n<p>There were some examples to use as test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day4Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can test a phrase is secure&quot;) {\n    isSecure(&quot;aa bb cc dd ee&quot;) shouldBe true\n    isSecure(&quot;aa bb cc dd aa&quot;) shouldBe false\n    isSecure(&quot;aa bb cc dd aaa&quot;) shouldBe true\n    isSecure(&quot;ab&quot;) shouldBe true\n    isSecure(&quot;a b&quot;) shouldBe true\n    isSecure(&quot;a a&quot;) shouldBe false\n    isSecure(&quot;a a a&quot;) shouldBe false\n\n    isSecure(&quot;sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp&quot;) shouldBe true\n    isSecure(&quot;xmuf znkhaes pggrlp zia znkhaes znkhaes&quot;) shouldBe false\n    isSecure(&quot;nti rxr bogebb zdwrin&quot;) shouldBe true\n    isSecure(&quot;sryookh unrudn zrkz jxhrdo gctlyz&quot;) shouldBe true\n    isSecure(&quot;bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken&quot;) shouldBe true\n    isSecure(&quot;flawt cpott xth ucwgg xce jcubx wvl qsysa nlg&quot;) shouldBe true\n\n  }\n\n  test(&quot;can count secure phrases&quot;) {\n    countSecure(Seq(&quot;aa bb&quot;)) shouldBe 1\n    countSecure(Seq(&quot;aa bb&quot;, &quot;aa bb&quot;)) shouldBe 2\n    countSecure(Seq(&quot;aa aa&quot;, &quot;aa aa&quot;)) shouldBe 0\n    countSecure(Seq(&quot;aa aa&quot;, &quot;aa bb&quot;)) shouldBe 1\n    countSecure(Seq(&quot;aa bb&quot;)) shouldBe 1\n\n    countSecure(Seq(\n      &quot;aa bb cc dd ee&quot;,\n      &quot;aa bb cc dd aa&quot;,\n      &quot;aa bb cc dd aaa&quot;,\n      &quot;ab&quot;,\n      &quot;a b&quot;,\n      &quot;a a&quot;,\n      &quot;a a a&quot;\n    )) shouldBe 4\n\n    countSecure(Seq(\n      &quot;sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp&quot;,\n      &quot;xmuf znkhaes pggrlp zia znkhaes znkhaes&quot;,\n      &quot;nti rxr bogebb zdwrin&quot;,\n      &quot;sryookh unrudn zrkz jxhrdo gctlyz&quot;,\n      &quot;bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken&quot;,\n      &quot;flawt cpott xth ucwgg xce jcubx wvl qsysa nlg&quot;\n    )) shouldBe 5\n\n  }\n}\n// defined class Day4Part1Test\n\n(new Day4Part1Test).execute()\n// Day4Part1Test:\n// - can test a phrase is secure\n// - can count secure phrases\n</code></pre>\n<p>I can now run against the test input</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = Source.fromResource(&quot;day4input.txt&quot;).getLines().toSeq\n// input: Seq[String] = Stream(sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp, ?)\n\ncountSecure(input)\n// res1: Int = 383\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For part two, the validator now needs to reject duplicate anagrams as well. This can be achieved by sorting each word alphabetically, which reduces the problem to the same one solved in part one.</p>\n<pre><code class=\"language-scala\">def isReallySecure(passphrase: String): \n  Boolean = iterSecure(passphrase.split(&quot; &quot;).toList.map(s =&gt; s.sorted))\n// isReallySecure: (passphrase: String)Boolean\n\ndef countReallySecure(passphrases: Seq[String]): \n  Int = passphrases.count(isReallySecure)\n// countReallySecure: (passphrases: Seq[String])Int\n</code></pre>\n<p>There are some more test cases, and some of the previous ones can be reused with<br>\nslightly different answers</p>\n<pre><code class=\"language-scala\">class Day4Part2Test extends FunSuite with Matchers {\n  test(&quot;can test a phrase is *really* secure&quot;) {\n\n    isReallySecure(&quot;aa bb cc dd ee&quot;) shouldBe true\n    isReallySecure(&quot;aa bb cc dd aa&quot;) shouldBe false\n    isReallySecure(&quot;aa bb cc dd aaa&quot;) shouldBe true\n    isReallySecure(&quot;ab&quot;) shouldBe true\n    isReallySecure(&quot;ab ba&quot;) shouldBe false\n    isReallySecure(&quot;a b&quot;) shouldBe true\n    isReallySecure(&quot;a a&quot;) shouldBe false\n    isReallySecure(&quot;a a a&quot;) shouldBe false\n\n\n    isReallySecure(&quot;abcde fghij&quot;) shouldBe true\n    isReallySecure(&quot;abcde xyz ecdab&quot;) shouldBe false\n    isReallySecure(&quot;a ab abc abd abf abj&quot;) shouldBe true\n    isReallySecure(&quot;iiii oiii ooii oooi oooo&quot;) shouldBe true\n    isReallySecure(&quot;oiii ioii iioi iiio&quot;) shouldBe false\n\n\n    isReallySecure(&quot;sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp&quot;) shouldBe true\n    isReallySecure(&quot;xmuf znkhaes pggrlp zia znkhaes znkhaes&quot;) shouldBe false\n    isReallySecure(&quot;nti rxr bogebb zdwrin&quot;) shouldBe true\n    isReallySecure(&quot;sryookh unrudn zrkz jxhrdo gctlyz&quot;) shouldBe true\n    isReallySecure(&quot;bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken&quot;) shouldBe false\n    isReallySecure(&quot;flawt cpott xth ucwgg xce jcubx wvl qsysa nlg&quot;) shouldBe true\n  }\n\n  test(&quot;can count *really* secure phrases&quot;) {\n\n    countReallySecure(Seq(\n      &quot;aa bb cc dd ee&quot;,\n      &quot;aa bb cc dd aa&quot;,\n      &quot;aa bb cc dd aaa&quot;,\n      &quot;ab&quot;,\n      &quot;ab ba&quot;,\n      &quot;a b&quot;,\n      &quot;a a&quot;,\n      &quot;a a a&quot;\n    )) shouldBe 4\n\n    countReallySecure(Seq(\n      &quot;abcde fghij&quot;,\n      &quot;abcde xyz ecdab&quot;,\n      &quot;a ab abc abd abf abj&quot;,\n      &quot;iiii oiii ooii oooi oooo&quot;,\n      &quot;oiii ioii iioi iiio&quot;\n    )) shouldBe 3\n\n    countReallySecure(Seq(\n      &quot;sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp&quot;,\n      &quot;xmuf znkhaes pggrlp zia znkhaes znkhaes&quot;,\n      &quot;nti rxr bogebb zdwrin&quot;,\n      &quot;sryookh unrudn zrkz jxhrdo gctlyz&quot;,\n      &quot;bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken&quot;,\n      &quot;flawt cpott xth ucwgg xce jcubx wvl qsysa nlg&quot;\n    )) shouldBe 4\n  }\n}\n// defined class Day4Part2Test\n\n(new Day4Part2Test).execute()\n// Day4Part2Test:\n// - can test a phrase is *really* secure\n// - can count *really* secure phrases\n</code></pre>\n<p>All that is left is to run with the puzzle input</p>\n<pre><code class=\"language-scala\">countReallySecure(input)\n// res3: Int = 265\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a31b3959136d71a373352e1","plaintext":"High-Entropy Passphrases\nA solution for Advent of Code 2017 - Day 4 [http://adventofcode.com/2017/day/4]\n\nPart 1\nToday's goal is to throw out a bunch of insecure passphrases. Specifically those\nwith duplicate words. I can see Sets being my friend.\n\ndef iterSecure(words: List[String], seen: Set[String] = Set.empty): Boolean = (\n  words match {\n    case Nil => true\n    case word :: _ if seen.contains(word) => false\n    case word :: rest => iterSecure(rest, seen + word)\n  }\n)\n// iterSecure: (words: List[String], seen: Set[String])Boolean\n\ndef isSecure(passphrase: String): Boolean = iterSecure(passphrase.split(\" \").toList, Set.empty)\n// isSecure: (passphrase: String)Boolean\n\ndef countSecure(passphrases: Seq[String]): Int = passphrases.count(isSecure)\n// countSecure: (passphrases: Seq[String])Int\n\n\nThe recursive iterSecure was originally written inside isSecure as just iter. A\npattern I often use that keeps the implementation-only arguments in the\nrecursion hidden from the outside world. It then turned out part two needed to\ncall it in a subtly different way, so I lifted it out to a def.\n\nThere were some examples to use as test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day4Part1Test extends FunSuite with Matchers {\n\n  test(\"can test a phrase is secure\") {\n    isSecure(\"aa bb cc dd ee\") shouldBe true\n    isSecure(\"aa bb cc dd aa\") shouldBe false\n    isSecure(\"aa bb cc dd aaa\") shouldBe true\n    isSecure(\"ab\") shouldBe true\n    isSecure(\"a b\") shouldBe true\n    isSecure(\"a a\") shouldBe false\n    isSecure(\"a a a\") shouldBe false\n\n    isSecure(\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\") shouldBe true\n    isSecure(\"xmuf znkhaes pggrlp zia znkhaes znkhaes\") shouldBe false\n    isSecure(\"nti rxr bogebb zdwrin\") shouldBe true\n    isSecure(\"sryookh unrudn zrkz jxhrdo gctlyz\") shouldBe true\n    isSecure(\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\") shouldBe true\n    isSecure(\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\") shouldBe true\n\n  }\n\n  test(\"can count secure phrases\") {\n    countSecure(Seq(\"aa bb\")) shouldBe 1\n    countSecure(Seq(\"aa bb\", \"aa bb\")) shouldBe 2\n    countSecure(Seq(\"aa aa\", \"aa aa\")) shouldBe 0\n    countSecure(Seq(\"aa aa\", \"aa bb\")) shouldBe 1\n    countSecure(Seq(\"aa bb\")) shouldBe 1\n\n    countSecure(Seq(\n      \"aa bb cc dd ee\",\n      \"aa bb cc dd aa\",\n      \"aa bb cc dd aaa\",\n      \"ab\",\n      \"a b\",\n      \"a a\",\n      \"a a a\"\n    )) shouldBe 4\n\n    countSecure(Seq(\n      \"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\",\n      \"xmuf znkhaes pggrlp zia znkhaes znkhaes\",\n      \"nti rxr bogebb zdwrin\",\n      \"sryookh unrudn zrkz jxhrdo gctlyz\",\n      \"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\",\n      \"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\"\n    )) shouldBe 5\n\n  }\n}\n// defined class Day4Part1Test\n\n(new Day4Part1Test).execute()\n// Day4Part1Test:\n// - can test a phrase is secure\n// - can count secure phrases\n\n\nI can now run against the test input\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = Source.fromResource(\"day4input.txt\").getLines().toSeq\n// input: Seq[String] = Stream(sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp, ?)\n\ncountSecure(input)\n// res1: Int = 383\n\n\nPart 2\nFor part two, the validator now needs to reject duplicate anagrams as well. This\ncan be achieved by sorting each word alphabetically, which reduces the problem\nto the same one solved in part one.\n\ndef isReallySecure(passphrase: String): \n  Boolean = iterSecure(passphrase.split(\" \").toList.map(s => s.sorted))\n// isReallySecure: (passphrase: String)Boolean\n\ndef countReallySecure(passphrases: Seq[String]): \n  Int = passphrases.count(isReallySecure)\n// countReallySecure: (passphrases: Seq[String])Int\n\n\nThere are some more test cases, and some of the previous ones can be reused with\nslightly different answers\n\nclass Day4Part2Test extends FunSuite with Matchers {\n  test(\"can test a phrase is *really* secure\") {\n\n    isReallySecure(\"aa bb cc dd ee\") shouldBe true\n    isReallySecure(\"aa bb cc dd aa\") shouldBe false\n    isReallySecure(\"aa bb cc dd aaa\") shouldBe true\n    isReallySecure(\"ab\") shouldBe true\n    isReallySecure(\"ab ba\") shouldBe false\n    isReallySecure(\"a b\") shouldBe true\n    isReallySecure(\"a a\") shouldBe false\n    isReallySecure(\"a a a\") shouldBe false\n\n\n    isReallySecure(\"abcde fghij\") shouldBe true\n    isReallySecure(\"abcde xyz ecdab\") shouldBe false\n    isReallySecure(\"a ab abc abd abf abj\") shouldBe true\n    isReallySecure(\"iiii oiii ooii oooi oooo\") shouldBe true\n    isReallySecure(\"oiii ioii iioi iiio\") shouldBe false\n\n\n    isReallySecure(\"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\") shouldBe true\n    isReallySecure(\"xmuf znkhaes pggrlp zia znkhaes znkhaes\") shouldBe false\n    isReallySecure(\"nti rxr bogebb zdwrin\") shouldBe true\n    isReallySecure(\"sryookh unrudn zrkz jxhrdo gctlyz\") shouldBe true\n    isReallySecure(\"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\") shouldBe false\n    isReallySecure(\"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\") shouldBe true\n  }\n\n  test(\"can count *really* secure phrases\") {\n\n    countReallySecure(Seq(\n      \"aa bb cc dd ee\",\n      \"aa bb cc dd aa\",\n      \"aa bb cc dd aaa\",\n      \"ab\",\n      \"ab ba\",\n      \"a b\",\n      \"a a\",\n      \"a a a\"\n    )) shouldBe 4\n\n    countReallySecure(Seq(\n      \"abcde fghij\",\n      \"abcde xyz ecdab\",\n      \"a ab abc abd abf abj\",\n      \"iiii oiii ooii oooi oooo\",\n      \"oiii ioii iioi iiio\"\n    )) shouldBe 3\n\n    countReallySecure(Seq(\n      \"sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp\",\n      \"xmuf znkhaes pggrlp zia znkhaes znkhaes\",\n      \"nti rxr bogebb zdwrin\",\n      \"sryookh unrudn zrkz jxhrdo gctlyz\",\n      \"bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken\",\n      \"flawt cpott xth ucwgg xce jcubx wvl qsysa nlg\"\n    )) shouldBe 4\n  }\n}\n// defined class Day4Part2Test\n\n(new Day4Part2Test).execute()\n// Day4Part2Test:\n// - can test a phrase is *really* secure\n// - can count *really* secure phrases\n\n\nAll that is left is to run with the puzzle input\n\ncountReallySecure(input)\n// res3: Int = 265","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-6.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-13T23:11:17.000Z","updated_at":"2017-12-14T21:39:41.000Z","published_at":"2017-12-11T05:00:00.000Z","custom_excerpt":"Advent of Code - Day 4","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a32ef0f9136d71a373352ea","uuid":"1fff0e8b-3aff-464d-b5c6-f993149667a0","title":"A Maze of Twisty Trampolines, All Alike","slug":"aoc-2017-day-5-a-maze-of-twisty-trampolines","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 5](http://adventofcode.com/2017/day/5)\\n\\n## Part 1\\n\\nI have a sequence of integers, to be interpreted as jump instructions. Starting at the first item, the task is to use the current value of my position as an offset to get to a new position. Incrementing the value in the current position before jumping. I need to return the number of jumps performed before a jump would take the current position out of the range of the sequence. \\n\\nIt seemed best just to simulate the steps. It is useful to note that the increment ensures that this will always (eventually) terminate for a finite sequence.\\n\\n```scala\\ndef countMoves(offsets: Seq[Int]): Int = {\\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\\n    if (!os.isDefinedAt(position)) count\\n    else iter(\\n      os.updated(position, os(position) + 1),\\n      count + 1,\\n      position = position + os(position)\\n    )\\n    \\n  iter(offsets.toVector)\\n}\\n// countMoves: (offsets: Seq[Int])Int\\n``` \\n\\nThere was only one example provided, but it is fairly simple to synthesise a few extra tests from very basic examples\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day5Part1Test extends FunSuite with Matchers {\\n  test(\\\"can count jumps\\\") {\\n    countMoves(Seq(0,3,0,1,-3)) shouldBe 5\\n    countMoves(Seq(1)) shouldBe 1\\n    countMoves(Seq(-1)) shouldBe 1\\n    countMoves(Seq(0)) shouldBe 2\\n  }\\n}\\n// defined class Day5Part1Test\\n\\n(new Day5Part1Test).execute()\\n// Day5Part1Test:\\n// - can count jumps\\n```\\n\\nThe actual input was much longer, and presented as one integer per line. The simulation was still quick enough not to notice a delay.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\ndef input = Source.fromResource(\\\"day5input.txt\\\").getLines().map(_.toInt).toSeq\\n// input: Seq[Int]\\n\\ncountMoves(input)\\n// res1: Int = 376976\\n```\\n\\n## Part 2\\n\\nThis was only a slight modification, now the algorithm converges on 2. Admittedly, it'll never reach this value, instead toggling between 2 and 3. The algorithm is still guaranteed to terminate as in the worst-case the sequence will eventually converge on 2s and 3s, which will shift the pointer off the end.\\n\\n```scala\\ndef countMovesWithConvergence(offsets: Seq[Int]): Int = {\\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\\n    if (!os.isDefinedAt(position)) count\\n    else {\\n      val offset = os(position)\\n      iter(\\n        os.updated(position, if (offset < 3) offset + 1 else offset - 1),\\n        count + 1,\\n        position = position + offset\\n      )\\n  }\\n  \\n  iter(offsets.toVector)\\n}\\n// countMovesWithConvergence: (offsets: Seq[Int])Int\\n```\\n\\nMost of the tests can be reused, and I added one extra as most of the existing\\ntests produced the same output despite the change.\\n\\n```scala\\nclass Day5Part2Test extends FunSuite with Matchers {\\n  test(\\\"can count jumps with convergence\\\") {\\n    countMovesWithConvergence(Seq(0,3,0,1,-3)) shouldBe 10\\n    countMovesWithConvergence(Seq(1)) shouldBe 1\\n    countMovesWithConvergence(Seq(-1)) shouldBe 1\\n    countMovesWithConvergence(Seq(0)) shouldBe 2\\n    countMovesWithConvergence(Seq(3, 1 , 2, -3)) shouldBe 4\\n  }\\n}\\n// defined class Day5Part2Test\\n\\n(new Day5Part2Test).execute()\\n// Day5Part2Test:\\n// - can count jumps with convergence\\n```\\n\\nThe change let to increase in jumps required by two orders of magnitude. There was about a 4 second delay when running it the first time after compilation. Given a couple of runs for optimisation, it was running both parts in less than 1.5 seconds.\\n\\n```scala\\n countMovesWithConvergence(input)\\n// res3: Int = 29227751\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/5\">Advent of Code 2017 - Day 5</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>I have a sequence of integers, to be interpreted as jump instructions. Starting at the first item, the task is to use the current value of my position as an offset to get to a new position. Incrementing the value in the current position before jumping. I need to return the number of jumps performed before a jump would take the current position out of the range of the sequence.</p>\n<p>It seemed best just to simulate the steps. It is useful to note that the increment ensures that this will always (eventually) terminate for a finite sequence.</p>\n<pre><code class=\"language-scala\">def countMoves(offsets: Seq[Int]): Int = {\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\n    if (!os.isDefinedAt(position)) count\n    else iter(\n      os.updated(position, os(position) + 1),\n      count + 1,\n      position = position + os(position)\n    )\n    \n  iter(offsets.toVector)\n}\n// countMoves: (offsets: Seq[Int])Int\n</code></pre>\n<p>There was only one example provided, but it is fairly simple to synthesise a few extra tests from very basic examples</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day5Part1Test extends FunSuite with Matchers {\n  test(&quot;can count jumps&quot;) {\n    countMoves(Seq(0,3,0,1,-3)) shouldBe 5\n    countMoves(Seq(1)) shouldBe 1\n    countMoves(Seq(-1)) shouldBe 1\n    countMoves(Seq(0)) shouldBe 2\n  }\n}\n// defined class Day5Part1Test\n\n(new Day5Part1Test).execute()\n// Day5Part1Test:\n// - can count jumps\n</code></pre>\n<p>The actual input was much longer, and presented as one integer per line. The simulation was still quick enough not to notice a delay.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\ndef input = Source.fromResource(&quot;day5input.txt&quot;).getLines().map(_.toInt).toSeq\n// input: Seq[Int]\n\ncountMoves(input)\n// res1: Int = 376976\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>This was only a slight modification, now the algorithm converges on 2. Admittedly, it'll never reach this value, instead toggling between 2 and 3. The algorithm is still guaranteed to terminate as in the worst-case the sequence will eventually converge on 2s and 3s, which will shift the pointer off the end.</p>\n<pre><code class=\"language-scala\">def countMovesWithConvergence(offsets: Seq[Int]): Int = {\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\n    if (!os.isDefinedAt(position)) count\n    else {\n      val offset = os(position)\n      iter(\n        os.updated(position, if (offset &lt; 3) offset + 1 else offset - 1),\n        count + 1,\n        position = position + offset\n      )\n  }\n  \n  iter(offsets.toVector)\n}\n// countMovesWithConvergence: (offsets: Seq[Int])Int\n</code></pre>\n<p>Most of the tests can be reused, and I added one extra as most of the existing<br>\ntests produced the same output despite the change.</p>\n<pre><code class=\"language-scala\">class Day5Part2Test extends FunSuite with Matchers {\n  test(&quot;can count jumps with convergence&quot;) {\n    countMovesWithConvergence(Seq(0,3,0,1,-3)) shouldBe 10\n    countMovesWithConvergence(Seq(1)) shouldBe 1\n    countMovesWithConvergence(Seq(-1)) shouldBe 1\n    countMovesWithConvergence(Seq(0)) shouldBe 2\n    countMovesWithConvergence(Seq(3, 1 , 2, -3)) shouldBe 4\n  }\n}\n// defined class Day5Part2Test\n\n(new Day5Part2Test).execute()\n// Day5Part2Test:\n// - can count jumps with convergence\n</code></pre>\n<p>The change let to increase in jumps required by two orders of magnitude. There was about a 4 second delay when running it the first time after compilation. Given a couple of runs for optimisation, it was running both parts in less than 1.5 seconds.</p>\n<pre><code class=\"language-scala\"> countMovesWithConvergence(input)\n// res3: Int = 29227751\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a32ef0f9136d71a373352ea","plaintext":"A solution for Advent of Code 2017 - Day 5 [http://adventofcode.com/2017/day/5]\n\nPart 1\nI have a sequence of integers, to be interpreted as jump instructions. Starting\nat the first item, the task is to use the current value of my position as an\noffset to get to a new position. Incrementing the value in the current position\nbefore jumping. I need to return the number of jumps performed before a jump\nwould take the current position out of the range of the sequence.\n\nIt seemed best just to simulate the steps. It is useful to note that the\nincrement ensures that this will always (eventually) terminate for a finite\nsequence.\n\ndef countMoves(offsets: Seq[Int]): Int = {\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\n    if (!os.isDefinedAt(position)) count\n    else iter(\n      os.updated(position, os(position) + 1),\n      count + 1,\n      position = position + os(position)\n    )\n    \n  iter(offsets.toVector)\n}\n// countMoves: (offsets: Seq[Int])Int\n\n\nThere was only one example provided, but it is fairly simple to synthesise a few\nextra tests from very basic examples\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day5Part1Test extends FunSuite with Matchers {\n  test(\"can count jumps\") {\n    countMoves(Seq(0,3,0,1,-3)) shouldBe 5\n    countMoves(Seq(1)) shouldBe 1\n    countMoves(Seq(-1)) shouldBe 1\n    countMoves(Seq(0)) shouldBe 2\n  }\n}\n// defined class Day5Part1Test\n\n(new Day5Part1Test).execute()\n// Day5Part1Test:\n// - can count jumps\n\n\nThe actual input was much longer, and presented as one integer per line. The\nsimulation was still quick enough not to notice a delay.\n\nimport scala.io.Source\n// import scala.io.Source\n\ndef input = Source.fromResource(\"day5input.txt\").getLines().map(_.toInt).toSeq\n// input: Seq[Int]\n\ncountMoves(input)\n// res1: Int = 376976\n\n\nPart 2\nThis was only a slight modification, now the algorithm converges on 2.\nAdmittedly, it'll never reach this value, instead toggling between 2 and 3. The\nalgorithm is still guaranteed to terminate as in the worst-case the sequence\nwill eventually converge on 2s and 3s, which will shift the pointer off the end.\n\ndef countMovesWithConvergence(offsets: Seq[Int]): Int = {\n  def iter(os: Vector[Int], count: Int = 0, position: Int = 0): Int =\n    if (!os.isDefinedAt(position)) count\n    else {\n      val offset = os(position)\n      iter(\n        os.updated(position, if (offset < 3) offset + 1 else offset - 1),\n        count + 1,\n        position = position + offset\n      )\n  }\n  \n  iter(offsets.toVector)\n}\n// countMovesWithConvergence: (offsets: Seq[Int])Int\n\n\nMost of the tests can be reused, and I added one extra as most of the existing\ntests produced the same output despite the change.\n\nclass Day5Part2Test extends FunSuite with Matchers {\n  test(\"can count jumps with convergence\") {\n    countMovesWithConvergence(Seq(0,3,0,1,-3)) shouldBe 10\n    countMovesWithConvergence(Seq(1)) shouldBe 1\n    countMovesWithConvergence(Seq(-1)) shouldBe 1\n    countMovesWithConvergence(Seq(0)) shouldBe 2\n    countMovesWithConvergence(Seq(3, 1 , 2, -3)) shouldBe 4\n  }\n}\n// defined class Day5Part2Test\n\n(new Day5Part2Test).execute()\n// Day5Part2Test:\n// - can count jumps with convergence\n\n\nThe change let to increase in jumps required by two orders of magnitude. There\nwas about a 4 second delay when running it the first time after compilation.\nGiven a couple of runs for optimisation, it was running both parts in less than\n1.5 seconds.\n\n countMovesWithConvergence(input)\n// res3: Int = 29227751","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-7.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-14T21:37:19.000Z","updated_at":"2017-12-14T21:44:51.000Z","published_at":"2017-12-12T05:00:00.000Z","custom_excerpt":"Advent of Code - Day 5","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a32f2959c9605113d0a4986","uuid":"6b37ee3e-da3f-45a6-9a80-04ed8106a82a","title":"Memory Reallocation","slug":"aoc-2017-day-6-memory-reallocation","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 6](http://adventofcode.com/2017/day/6)\\n\\n## Part 1\\n\\nToday I'm tasked with analysing a memory redistribution algorithm. Each iteration the algorithm finds the largest int in the sequence and distributes it as evenly as possible over the whole sequence. To do this it walks the sequence for n steps (where n is the integer being redistributed) starting at the next position and cycling if there is overflow.\\n\\nThe value I have to compute is how many iterations of the algorithm are performed before a previous sequence state is reached, closing an infinite loop.\\n\\nThe actual redistribution can be reduced to a single loop, using modulus based calculations to determine the increment for each index.\\n\\n```scala\\ndef redistribute(buckets: Vector[Int]): Vector[Int] = {\\n  val max = buckets.max\\n  val source = buckets.indexOf(max)\\n  val start = (source + 1) % buckets.length\\n  val finish = (start + (max % buckets.length)) % buckets.length\\n  val shouldGetMore: Int => Boolean =\\n    if (start <= finish) i => i >= start && i < finish\\n    else i => i >= start || i < finish\\n\\n  buckets\\n    .updated(source, 0)\\n    .zipWithIndex\\n    .map {\\n      case (b, i) =>\\n        b + (max / buckets.length) + (if (shouldGetMore(i)) 1 else 0)\\n    }\\n}\\n// redistribute: (buckets: Vector[Int])Vector[Int]\\n\\ndef countUntilLoop(buckets: Vector[Int]): Int = {\\n  def iter(state: Vector[Int],\\n           seen: Set[Vector[Int]] = Set.empty,\\n           count: Int = 0): Int =\\n    if (seen.contains(state)) count\\n    else iter(redistribute(state), seen + state, count + 1)\\n\\n  iter(buckets)\\n}\\n// countUntilLoop: (buckets: Vector[Int])Int\\n```\\n\\nThere was only one value, but due to how it loops, the walkthrough can be used to synthesise some extra test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day6Part1Test extends FunSuite with Matchers {\\n  test(\\\"can redistribute values\\\") {\\n    redistribute(Vector(0, 2, 7, 0)) shouldBe Vector(2, 4, 1, 2)\\n    redistribute(Vector(2, 4, 1, 2)) shouldBe Vector(3, 1, 2, 3)\\n    redistribute(Vector(23)) shouldBe Vector(23)\\n    redistribute(Vector(4, 2)) shouldBe Vector(2, 4)\\n  }\\n  \\n  test(\\\"can count iterations until repeat\\\") {\\n    countUntilLoop(Vector(0, 2, 7, 0)) shouldBe 5\\n    countUntilLoop(Vector(2, 4, 1, 2)) shouldBe 4\\n    countUntilLoop(Vector(3, 1, 2, 3)) shouldBe 4\\n    countUntilLoop(Vector(23)) shouldBe 1\\n    countUntilLoop(Vector(4, 2)) shouldBe 2\\n    countUntilLoop(Vector(5, 1)) shouldBe 3\\n  }\\n}\\n// defined class Day6Part1Test\\n\\n(new Day6Part1Test).execute()\\n// Day6Part1Test:\\n// - can redistribute values\\n// - can count iterations until repeat\\n```\\n\\nNow I can plug in the input and get a result to claim my gold star.\\n\\n```scala\\nval input = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\\n// input: scala.collection.immutable.Vector[Int] = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\\n\\ncountUntilLoop(input)\\n// res1: Int = 7864\\n```\\n\\n## Part 2\\n\\nThis only adds a slight extension to the puzzle, which is to count the length of the actual loop, excluding the steps taken before reaching the first position that repeats. I could just run the count function again, using the final sequence as the initial state would then walk the loop exactly once before seeing a repeat. Instead to save work, instead of storing a set of sequence states, the sequences were used as the keys to a map. The map values being the iteration that produced the state, meaning I could do a simple subtraction to get the loop length.\\n\\n```scala\\ndef countLoopSize(buckets: Vector[Int]): Int = {\\n  def iter(state: Vector[Int],\\n           seen: Map[Vector[Int], Int] = Map.empty,\\n           count: Int = 0): Int =\\n    if (seen.isDefinedAt(state)) count - seen(state)\\n    else iter(redistribute(state), seen.updated(state, count), count + 1)\\n\\n  iter(buckets)\\n}\\n// countLoopSize: (buckets: Vector[Int])Int\\n``` \\n\\nThe previous tests could be reworked for the new output\\n\\n```scala\\nclass Day6Part2Test extends FunSuite with Matchers {\\n  test(\\\"testCountLoopSize\\\") {\\n    countLoopSize(Vector(0, 2, 7, 0)) shouldBe 4\\n    countLoopSize(Vector(2, 4, 1, 2)) shouldBe 4\\n    countLoopSize(Vector(3, 1, 2, 3)) shouldBe 4\\n    countLoopSize(Vector(23)) shouldBe 1\\n    countLoopSize(Vector(4, 2)) shouldBe 2\\n    countLoopSize(Vector(5, 1)) shouldBe 2\\n  }\\n}\\n// defined class Day6Part2Test\\n\\n(new Day6Part2Test).execute()\\n// Day6Part2Test:\\n// - testCountLoopSize\\n```\\n\\nI can now claim another gold star:\\n\\n```scala\\ncountLoopSize(input)\\n// res3: Int = 1695\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/6\">Advent of Code 2017 - Day 6</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today I'm tasked with analysing a memory redistribution algorithm. Each iteration the algorithm finds the largest int in the sequence and distributes it as evenly as possible over the whole sequence. To do this it walks the sequence for n steps (where n is the integer being redistributed) starting at the next position and cycling if there is overflow.</p>\n<p>The value I have to compute is how many iterations of the algorithm are performed before a previous sequence state is reached, closing an infinite loop.</p>\n<p>The actual redistribution can be reduced to a single loop, using modulus based calculations to determine the increment for each index.</p>\n<pre><code class=\"language-scala\">def redistribute(buckets: Vector[Int]): Vector[Int] = {\n  val max = buckets.max\n  val source = buckets.indexOf(max)\n  val start = (source + 1) % buckets.length\n  val finish = (start + (max % buckets.length)) % buckets.length\n  val shouldGetMore: Int =&gt; Boolean =\n    if (start &lt;= finish) i =&gt; i &gt;= start &amp;&amp; i &lt; finish\n    else i =&gt; i &gt;= start || i &lt; finish\n\n  buckets\n    .updated(source, 0)\n    .zipWithIndex\n    .map {\n      case (b, i) =&gt;\n        b + (max / buckets.length) + (if (shouldGetMore(i)) 1 else 0)\n    }\n}\n// redistribute: (buckets: Vector[Int])Vector[Int]\n\ndef countUntilLoop(buckets: Vector[Int]): Int = {\n  def iter(state: Vector[Int],\n           seen: Set[Vector[Int]] = Set.empty,\n           count: Int = 0): Int =\n    if (seen.contains(state)) count\n    else iter(redistribute(state), seen + state, count + 1)\n\n  iter(buckets)\n}\n// countUntilLoop: (buckets: Vector[Int])Int\n</code></pre>\n<p>There was only one value, but due to how it loops, the walkthrough can be used to synthesise some extra test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day6Part1Test extends FunSuite with Matchers {\n  test(&quot;can redistribute values&quot;) {\n    redistribute(Vector(0, 2, 7, 0)) shouldBe Vector(2, 4, 1, 2)\n    redistribute(Vector(2, 4, 1, 2)) shouldBe Vector(3, 1, 2, 3)\n    redistribute(Vector(23)) shouldBe Vector(23)\n    redistribute(Vector(4, 2)) shouldBe Vector(2, 4)\n  }\n  \n  test(&quot;can count iterations until repeat&quot;) {\n    countUntilLoop(Vector(0, 2, 7, 0)) shouldBe 5\n    countUntilLoop(Vector(2, 4, 1, 2)) shouldBe 4\n    countUntilLoop(Vector(3, 1, 2, 3)) shouldBe 4\n    countUntilLoop(Vector(23)) shouldBe 1\n    countUntilLoop(Vector(4, 2)) shouldBe 2\n    countUntilLoop(Vector(5, 1)) shouldBe 3\n  }\n}\n// defined class Day6Part1Test\n\n(new Day6Part1Test).execute()\n// Day6Part1Test:\n// - can redistribute values\n// - can count iterations until repeat\n</code></pre>\n<p>Now I can plug in the input and get a result to claim my gold star.</p>\n<pre><code class=\"language-scala\">val input = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\n// input: scala.collection.immutable.Vector[Int] = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\n\ncountUntilLoop(input)\n// res1: Int = 7864\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>This only adds a slight extension to the puzzle, which is to count the length of the actual loop, excluding the steps taken before reaching the first position that repeats. I could just run the count function again, using the final sequence as the initial state would then walk the loop exactly once before seeing a repeat. Instead to save work, instead of storing a set of sequence states, the sequences were used as the keys to a map. The map values being the iteration that produced the state, meaning I could do a simple subtraction to get the loop length.</p>\n<pre><code class=\"language-scala\">def countLoopSize(buckets: Vector[Int]): Int = {\n  def iter(state: Vector[Int],\n           seen: Map[Vector[Int], Int] = Map.empty,\n           count: Int = 0): Int =\n    if (seen.isDefinedAt(state)) count - seen(state)\n    else iter(redistribute(state), seen.updated(state, count), count + 1)\n\n  iter(buckets)\n}\n// countLoopSize: (buckets: Vector[Int])Int\n</code></pre>\n<p>The previous tests could be reworked for the new output</p>\n<pre><code class=\"language-scala\">class Day6Part2Test extends FunSuite with Matchers {\n  test(&quot;testCountLoopSize&quot;) {\n    countLoopSize(Vector(0, 2, 7, 0)) shouldBe 4\n    countLoopSize(Vector(2, 4, 1, 2)) shouldBe 4\n    countLoopSize(Vector(3, 1, 2, 3)) shouldBe 4\n    countLoopSize(Vector(23)) shouldBe 1\n    countLoopSize(Vector(4, 2)) shouldBe 2\n    countLoopSize(Vector(5, 1)) shouldBe 2\n  }\n}\n// defined class Day6Part2Test\n\n(new Day6Part2Test).execute()\n// Day6Part2Test:\n// - testCountLoopSize\n</code></pre>\n<p>I can now claim another gold star:</p>\n<pre><code class=\"language-scala\">countLoopSize(input)\n// res3: Int = 1695\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a32f2959c9605113d0a4986","plaintext":"A solution for Advent of Code 2017 - Day 6 [http://adventofcode.com/2017/day/6]\n\nPart 1\nToday I'm tasked with analysing a memory redistribution algorithm. Each\niteration the algorithm finds the largest int in the sequence and distributes it\nas evenly as possible over the whole sequence. To do this it walks the sequence\nfor n steps (where n is the integer being redistributed) starting at the next\nposition and cycling if there is overflow.\n\nThe value I have to compute is how many iterations of the algorithm are\nperformed before a previous sequence state is reached, closing an infinite loop.\n\nThe actual redistribution can be reduced to a single loop, using modulus based\ncalculations to determine the increment for each index.\n\ndef redistribute(buckets: Vector[Int]): Vector[Int] = {\n  val max = buckets.max\n  val source = buckets.indexOf(max)\n  val start = (source + 1) % buckets.length\n  val finish = (start + (max % buckets.length)) % buckets.length\n  val shouldGetMore: Int => Boolean =\n    if (start <= finish) i => i >= start && i < finish\n    else i => i >= start || i < finish\n\n  buckets\n    .updated(source, 0)\n    .zipWithIndex\n    .map {\n      case (b, i) =>\n        b + (max / buckets.length) + (if (shouldGetMore(i)) 1 else 0)\n    }\n}\n// redistribute: (buckets: Vector[Int])Vector[Int]\n\ndef countUntilLoop(buckets: Vector[Int]): Int = {\n  def iter(state: Vector[Int],\n           seen: Set[Vector[Int]] = Set.empty,\n           count: Int = 0): Int =\n    if (seen.contains(state)) count\n    else iter(redistribute(state), seen + state, count + 1)\n\n  iter(buckets)\n}\n// countUntilLoop: (buckets: Vector[Int])Int\n\n\nThere was only one value, but due to how it loops, the walkthrough can be used\nto synthesise some extra test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day6Part1Test extends FunSuite with Matchers {\n  test(\"can redistribute values\") {\n    redistribute(Vector(0, 2, 7, 0)) shouldBe Vector(2, 4, 1, 2)\n    redistribute(Vector(2, 4, 1, 2)) shouldBe Vector(3, 1, 2, 3)\n    redistribute(Vector(23)) shouldBe Vector(23)\n    redistribute(Vector(4, 2)) shouldBe Vector(2, 4)\n  }\n  \n  test(\"can count iterations until repeat\") {\n    countUntilLoop(Vector(0, 2, 7, 0)) shouldBe 5\n    countUntilLoop(Vector(2, 4, 1, 2)) shouldBe 4\n    countUntilLoop(Vector(3, 1, 2, 3)) shouldBe 4\n    countUntilLoop(Vector(23)) shouldBe 1\n    countUntilLoop(Vector(4, 2)) shouldBe 2\n    countUntilLoop(Vector(5, 1)) shouldBe 3\n  }\n}\n// defined class Day6Part1Test\n\n(new Day6Part1Test).execute()\n// Day6Part1Test:\n// - can redistribute values\n// - can count iterations until repeat\n\n\nNow I can plug in the input and get a result to claim my gold star.\n\nval input = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\n// input: scala.collection.immutable.Vector[Int] = Vector(0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11)\n\ncountUntilLoop(input)\n// res1: Int = 7864\n\n\nPart 2\nThis only adds a slight extension to the puzzle, which is to count the length of\nthe actual loop, excluding the steps taken before reaching the first position\nthat repeats. I could just run the count function again, using the final\nsequence as the initial state would then walk the loop exactly once before\nseeing a repeat. Instead to save work, instead of storing a set of sequence\nstates, the sequences were used as the keys to a map. The map values being the\niteration that produced the state, meaning I could do a simple subtraction to\nget the loop length.\n\ndef countLoopSize(buckets: Vector[Int]): Int = {\n  def iter(state: Vector[Int],\n           seen: Map[Vector[Int], Int] = Map.empty,\n           count: Int = 0): Int =\n    if (seen.isDefinedAt(state)) count - seen(state)\n    else iter(redistribute(state), seen.updated(state, count), count + 1)\n\n  iter(buckets)\n}\n// countLoopSize: (buckets: Vector[Int])Int\n\n\nThe previous tests could be reworked for the new output\n\nclass Day6Part2Test extends FunSuite with Matchers {\n  test(\"testCountLoopSize\") {\n    countLoopSize(Vector(0, 2, 7, 0)) shouldBe 4\n    countLoopSize(Vector(2, 4, 1, 2)) shouldBe 4\n    countLoopSize(Vector(3, 1, 2, 3)) shouldBe 4\n    countLoopSize(Vector(23)) shouldBe 1\n    countLoopSize(Vector(4, 2)) shouldBe 2\n    countLoopSize(Vector(5, 1)) shouldBe 2\n  }\n}\n// defined class Day6Part2Test\n\n(new Day6Part2Test).execute()\n// Day6Part2Test:\n// - testCountLoopSize\n\n\nI can now claim another gold star:\n\ncountLoopSize(input)\n// res3: Int = 1695","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-8.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-14T21:52:21.000Z","updated_at":"2017-12-14T22:29:34.000Z","published_at":"2017-12-13T05:00:00.000Z","custom_excerpt":"Advent of Code - Day 6","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3309939c9605113d0a498d","uuid":"2f51b14b-ac1d-4dd8-a23c-cbc72b578c85","title":"Recursive Circus","slug":"aoc-2017-day-7-recursive-circus","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 7](http://adventofcode.com/2017/day/7)\\n\\n## Part 1\\n\\nToday the puzzle scenario is a recursive data structure, realised as a wobbling tower of discs. The main aim of part one is to make sense of the way this structure is represented. At least, sense enough to determine its root.\\n\\nSince the nodes of the structure are labeled with strings, I can store this as a map of string to a case class to store a reference to the parent, and to any children. Using the string label, rather than a hard reference to the other node makes the structure much easier to build one node at a time. To make things a bit easier to keep track of, I'll use a type alias to mark when a string is being used as a reference to a node.\\n\\n```scala\\ntype NodeRef = String\\n// defined type alias NodeRef\\n\\ncase class Node(name: String,\\n                weight: Option[Int] = None,\\n                parent: Option[NodeRef] = None,\\n                children: Set[NodeRef] = Set.empty)\\n// defined class Node\\n\\nval LineMatcher = \\\"([a-z]+) \\\\\\\\((\\\\\\\\d+)\\\\\\\\)(?: -> ((?:[a-z]+(?:, )?)+))?\\\".r\\n// LineMatcher: scala.util.matching.Regex = ([a-z]+) \\\\((\\\\d+)\\\\)(?: -> ((?:[a-z]+(?:, )?)+))?\\n\\ndef parseChildList(children: String): Set[NodeRef] = (\\n  if (children == null) Set.empty\\n  else children.split(\\\", \\\").toSet\\n)\\n// parseChildList: (children: String)Set[NodeRef]\\n\\ndef parseInput(lines: TraversableOnce[String]): Map[NodeRef, Node] = (\\n  lines.foldLeft(Map.empty[String, Node]) {\\n    case (map, LineMatcher(name, weight, children)) =>\\n      val node =\\n        map.getOrElse(name, Node(name))\\n          .copy(\\n            weight = Some(weight.toInt),\\n            children = parseChildList(children)\\n          )\\n      node.children\\n        .foldLeft(map.updated(node.name, node)) {\\n          case (newMap, nodeRef) =>\\n            newMap.updated(\\n              nodeRef,\\n              newMap.getOrElse(nodeRef, Node(nodeRef))\\n                .copy(parent = Some(node.name))\\n            )\\n        }\\n    case (map, _) => map\\n  }\\n)\\n// parseInput: (lines: TraversableOnce[String])Map[NodeRef,Node]\\n```\\n\\nOnce the data has been corralled into something usable, getting the actual \\nanswer is fairly simple.\\n\\n```scala\\ndef findRoot(nodes: TraversableOnce[Node]): Option[Node] = \\n    nodes.find(n => n.parent.isEmpty)\\n// findRoot: (nodes: TraversableOnce[Node])Option[Node]\\n``` \\n\\nThere is only one example in the puzzle description, but being a recursive\\nstructure we can break it down into multiple sub tests. They are unfortunately\\nquite verbose.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day7Part1Test extends FunSuite with Matchers {\\n  def sample =\\n    \\\"\\\"\\\"pbga (66)\\n      |xhth (57)\\n      |ebii (61)\\n      |havc (66)\\n      |ktlj (57)\\n      |fwft (72) -> ktlj, cntj, xhth\\n      |qoyq (66)\\n      |padx (45) -> pbga, havc, qoyq\\n      |tknk (41) -> ugml, padx, fwft\\n      |jptl (61)\\n      |ugml (68) -> gyxo, ebii, jptl\\n      |gyxo (61)\\n      |cntj (57)\\\"\\\"\\\".stripMargin.lines\\n\\n  def subSample1 =\\n    \\\"\\\"\\\"xhth (57)\\n      |ktlj (57)\\n      |fwft (72) -> ktlj, cntj, xhth\\n      |cntj (57)\\\"\\\"\\\".stripMargin.lines\\n\\n  def subSample2 =\\n    \\\"\\\"\\\"pbga (67)\\n      |havc (66)\\n      |qoyq (66)\\n      |padx (45) -> pbga, havc, qoyq\\\"\\\"\\\".stripMargin.lines\\n\\n  def subSample3 =\\n    \\\"\\\"\\\"ugmlq (68) -> gyxo, ebii\\n      |ebii (61)\\n      |gyxo (61)\\\"\\\"\\\".stripMargin.lines\\n\\n\\n  test(\\\"can parse input lines\\\") {\\n    val parsedSubSample1: Map[String, Node] = parseInput(subSample1)\\n\\n    parsedSubSample1.size shouldBe 4\\n    parsedSubSample1.get(\\\"xhth\\\") shouldBe Some(Node(\\\"xhth\\\", Some(57), Some(\\\"fwft\\\")))\\n    parsedSubSample1.get(\\\"ktlj\\\") shouldBe Some(Node(\\\"ktlj\\\", Some(57), Some(\\\"fwft\\\")))\\n    parsedSubSample1.get(\\\"fwft\\\") shouldBe Some(Node(\\\"fwft\\\", Some(72), None, Set(\\\"xhth\\\", \\\"ktlj\\\", \\\"cntj\\\")))\\n    parsedSubSample1.get(\\\"cntj\\\") shouldBe Some(Node(\\\"cntj\\\", Some(57), Some(\\\"fwft\\\")))\\n\\n    val parsedSubSample2: Map[String, Node] = parseInput(subSample2)\\n\\n    parsedSubSample2.size shouldBe 4\\n    parsedSubSample2.get(\\\"pbga\\\") shouldBe Some(Node(\\\"pbga\\\", Some(67), Some(\\\"padx\\\")))\\n    parsedSubSample2.get(\\\"havc\\\") shouldBe Some(Node(\\\"havc\\\", Some(66), Some(\\\"padx\\\")))\\n    parsedSubSample2.get(\\\"padx\\\") shouldBe Some(Node(\\\"padx\\\", Some(45), None, Set(\\\"pbga\\\", \\\"havc\\\", \\\"qoyq\\\")))\\n    parsedSubSample2.get(\\\"qoyq\\\") shouldBe Some(Node(\\\"qoyq\\\", Some(66), Some(\\\"padx\\\")))\\n\\n    val parsedSubSample3: Map[String, Node] = parseInput(subSample3)\\n\\n    parsedSubSample3.size shouldBe 3\\n    parsedSubSample3.get(\\\"ebii\\\") shouldBe Some(Node(\\\"ebii\\\", Some(61), Some(\\\"ugmlq\\\")))\\n    parsedSubSample3.get(\\\"gyxo\\\") shouldBe Some(Node(\\\"gyxo\\\", Some(61), Some(\\\"ugmlq\\\")))\\n    parsedSubSample3.get(\\\"ugmlq\\\") shouldBe Some(Node(\\\"ugmlq\\\", Some(68), None, Set(\\\"ebii\\\", \\\"gyxo\\\")))\\n\\n    val parsedSample: Map[String, Node] = parseInput(sample)\\n\\n    parsedSample.size shouldBe 13\\n    parsedSample.get(\\\"xhth\\\") shouldBe Some(Node(\\\"xhth\\\", Some(57), Some(\\\"fwft\\\")))\\n    parsedSample.get(\\\"ktlj\\\") shouldBe Some(Node(\\\"ktlj\\\", Some(57), Some(\\\"fwft\\\")))\\n    parsedSample.get(\\\"fwft\\\") shouldBe Some(Node(\\\"fwft\\\", Some(72), Some(\\\"tknk\\\"), Set(\\\"xhth\\\", \\\"ktlj\\\", \\\"cntj\\\")))\\n    parsedSample.get(\\\"cntj\\\") shouldBe Some(Node(\\\"cntj\\\", Some(57), Some(\\\"fwft\\\")))\\n    parsedSample.get(\\\"pbga\\\") shouldBe Some(Node(\\\"pbga\\\", Some(66), Some(\\\"padx\\\")))\\n    parsedSample.get(\\\"havc\\\") shouldBe Some(Node(\\\"havc\\\", Some(66), Some(\\\"padx\\\")))\\n    parsedSample.get(\\\"padx\\\") shouldBe Some(Node(\\\"padx\\\", Some(45), Some(\\\"tknk\\\"), Set(\\\"pbga\\\", \\\"havc\\\", \\\"qoyq\\\")))\\n    parsedSample.get(\\\"qoyq\\\") shouldBe Some(Node(\\\"qoyq\\\", Some(66), Some(\\\"padx\\\")))\\n    parsedSample.get(\\\"ebii\\\") shouldBe Some(Node(\\\"ebii\\\", Some(61), Some(\\\"ugml\\\")))\\n    parsedSample.get(\\\"gyxo\\\") shouldBe Some(Node(\\\"gyxo\\\", Some(61), Some(\\\"ugml\\\")))\\n    parsedSample.get(\\\"ugml\\\") shouldBe Some(Node(\\\"ugml\\\", Some(68), Some(\\\"tknk\\\"), Set(\\\"ebii\\\", \\\"gyxo\\\", \\\"jptl\\\")))\\n    parsedSample.get(\\\"jptl\\\") shouldBe Some(Node(\\\"jptl\\\", Some(61), Some(\\\"ugml\\\")))\\n    parsedSample.get(\\\"tknk\\\") shouldBe Some(Node(\\\"tknk\\\", Some(41), None, Set(\\\"ugml\\\", \\\"padx\\\", \\\"fwft\\\")))\\n  }\\n\\n  test(\\\"can find structure root\\\") {\\n    findRoot(parseInput(subSample1).map { case (_, v) => v }).map(n => n.name) shouldBe Some(\\\"fwft\\\")\\n    findRoot(parseInput(subSample2).values).map(n => n.name) shouldBe Some(\\\"padx\\\")\\n    findRoot(parseInput(subSample3).values).map(n => n.name) shouldBe Some(\\\"ugmlq\\\")\\n    findRoot(parseInput(sample).values).map(n => n.name) shouldBe Some(\\\"tknk\\\")\\n  }\\n}\\n// defined class Day7Part1Test\\n\\n(new Day7Part1Test).execute()\\n// Day7Part1Test:\\n// - can parse input lines\\n// - can find structure root\\n```\\n\\nI can now parse the input file and find the solution:\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = parseInput(Source.fromResource(\\\"day7input.txt\\\").getLines())\\n// input: Map[NodeRef,Node] = Map(wqobawc -> Node(wqobawc,Some(67),Some(cpoxc),Set()), xeppuz -> Node(xeppuz,Some(7),Some(cfmcrf),Set()), ewzvs -> Node(ewzvs,Some(54),Some(vpnfkw),Set()), yujhec -> Node(yujhec,Some(30),Some(ucocdl),Set(rnbvott, nmwrqbx, etingr, dktkg, qkzgb)), gmtzu -> Node(gmtzu,Some(30),Some(tjmyc),Set()), isuevmr -> Node(isuevmr,Some(221),Some(qsiqu),Set(sphktgz, gjauauy, bncsnst)), kdrswra -> Node(kdrswra,Some(102),Some(tymahpb),Set(xreip, ghxwug)), mdimlja -> Node(mdimlja,Some(36),Some(pxzoq),Set()), zdagr -> Node(zdagr,Some(249),Some(nwand),Set(gqjhcw, qvcpu)), wgqnrc -> Node(wgqnrc,Some(30),Some(dyfptec),Set()), svnqa -> Node(svnqa,Some(313),Some(tjrecaq),Set(nthqzh, uekit, hopiqm)), fabacam -> Node(fabacam,Some(305),Some(anygv),Set(dlcxjg, dlactl, falrf)), yfkyv ->...\\n\\nfindRoot(input.values).get.name\\n// res1: String = xegshds\\n```\\n\\n## Part 2\\n\\nNow I actually have to do some analysis of the data structure. Each node has a weight. The structure should have an invariant such that for each node, each of its sub-trees has the same weight. However there is one node that is violating this. The task is to find that node, and return the weight it **should** be to satisfy the invariant.\\n\\nSince I already have a way to find the root, I can start there, but to calculate the sub-tree weights I need to start at the roots. So the recursive function first recurses until it hits leaves, which have an empty group, and just return their weight.\\n\\nOnce we have data for all the children, if any of them don't have the same weight we have found the corrupt node, and can just pass that up the tree. For this reason the recursion returns an optional node and corrected weight pair.\\n\\nIf this is set for any of the nodes, it can be returned, otherwise if one child has a different weight, calculate the difference and set the data to be passed down.\\n\\n```scala\\ndef findMismatchedNode(nodes: Map[NodeRef, Node]): Option[(Node, Int)] = {\\n  def iter(node: Node): (Int, Option[(Node, Int)]) = {\\n    val childData = node.children.toList.map(\\n      c_ref => (c_ref, iter(nodes(c_ref)))\\n    )\\n\\n    val totalWeight =\\n      node.weight.getOrElse(0) + childData.map { case (_, (w, _)) => w }.sum\\n\\n    val groups = childData.groupBy { case (_, (w, _)) => w }\\n    (\\n      totalWeight,\\n      groups\\n        .find { case (_, ns) => ns.lengthCompare(1) == 0 }\\n        .collect {\\n          case (cW, (c_ref, (_, maybeNode)) :: _) =>\\n            maybeNode.getOrElse({\\n              val childNode = nodes(c_ref)\\n              (\\n                childNode,\\n                groups.find {\\n                  case (_, ns) => ns.lengthCompare(1) > 0\\n                }.map {\\n                  case (w, _) => childNode.weight.getOrElse(0) - cW + w\\n                }.getOrElse(0)\\n              )\\n            })\\n        }\\n    )\\n  }\\n  \\n  val root = findRoot(nodes.values)\\n  \\n  root.flatMap { r =>\\n    iter(r) match {\\n      case (_, maybeMismatch) => maybeMismatch\\n    }\\n  }\\n}\\n// findMismatchedNode: (nodes: Map[NodeRef,Node])Option[(Node, Int)]\\n```\\n\\nThe testing can reuse most of the data from the previous tests.\\n\\n```scala\\nclass Day7Part2Test extends FunSuite with Matchers {\\n  def sample =\\n    \\\"\\\"\\\"pbga (66)\\n      |xhth (57)\\n      |ebii (61)\\n      |havc (66)\\n      |ktlj (57)\\n      |fwft (72) -> ktlj, cntj, xhth\\n      |qoyq (66)\\n      |padx (45) -> pbga, havc, qoyq\\n      |tknk (41) -> ugml, padx, fwft\\n      |jptl (61)\\n      |ugml (68) -> gyxo, ebii, jptl\\n      |gyxo (61)\\n      |cntj (57)\\\"\\\"\\\".stripMargin.lines\\n\\n  def subSample2 =\\n    \\\"\\\"\\\"pbga (67)\\n      |havc (66)\\n      |qoyq (66)\\n      |padx (45) -> pbga, havc, qoyq\\\"\\\"\\\".stripMargin.lines\\n\\n  test(\\\"testFindMismatchedWeight\\\") {\\n    findMismatchedNode(parseInput(subSample2)) shouldBe\\n    Some((Node(\\\"pbga\\\", Some(67), Some(\\\"padx\\\")), 66))\\n\\n    findMismatchedNode(parseInput(sample)) shouldBe\\n    Some((Node(\\\"ugml\\\", Some(68), Some(\\\"tknk\\\"), Set(\\\"ebii\\\", \\\"gyxo\\\", \\\"jptl\\\")), 60))\\n  }\\n}\\n// defined class Day7Part2Test\\n\\n(new Day7Part2Test).execute()\\n// Day7Part2Test:\\n// - testFindMismatchedWeight\\n```\\n\\nAnd finally I can now extract the puzzle solution from the data returned:\\n\\n```scala\\nfindMismatchedNode(input).get._2\\n// res3: Int = 299\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/7\">Advent of Code 2017 - Day 7</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today the puzzle scenario is a recursive data structure, realised as a wobbling tower of discs. The main aim of part one is to make sense of the way this structure is represented. At least, sense enough to determine its root.</p>\n<p>Since the nodes of the structure are labeled with strings, I can store this as a map of string to a case class to store a reference to the parent, and to any children. Using the string label, rather than a hard reference to the other node makes the structure much easier to build one node at a time. To make things a bit easier to keep track of, I'll use a type alias to mark when a string is being used as a reference to a node.</p>\n<pre><code class=\"language-scala\">type NodeRef = String\n// defined type alias NodeRef\n\ncase class Node(name: String,\n                weight: Option[Int] = None,\n                parent: Option[NodeRef] = None,\n                children: Set[NodeRef] = Set.empty)\n// defined class Node\n\nval LineMatcher = &quot;([a-z]+) \\\\((\\\\d+)\\\\)(?: -&gt; ((?:[a-z]+(?:, )?)+))?&quot;.r\n// LineMatcher: scala.util.matching.Regex = ([a-z]+) \\((\\d+)\\)(?: -&gt; ((?:[a-z]+(?:, )?)+))?\n\ndef parseChildList(children: String): Set[NodeRef] = (\n  if (children == null) Set.empty\n  else children.split(&quot;, &quot;).toSet\n)\n// parseChildList: (children: String)Set[NodeRef]\n\ndef parseInput(lines: TraversableOnce[String]): Map[NodeRef, Node] = (\n  lines.foldLeft(Map.empty[String, Node]) {\n    case (map, LineMatcher(name, weight, children)) =&gt;\n      val node =\n        map.getOrElse(name, Node(name))\n          .copy(\n            weight = Some(weight.toInt),\n            children = parseChildList(children)\n          )\n      node.children\n        .foldLeft(map.updated(node.name, node)) {\n          case (newMap, nodeRef) =&gt;\n            newMap.updated(\n              nodeRef,\n              newMap.getOrElse(nodeRef, Node(nodeRef))\n                .copy(parent = Some(node.name))\n            )\n        }\n    case (map, _) =&gt; map\n  }\n)\n// parseInput: (lines: TraversableOnce[String])Map[NodeRef,Node]\n</code></pre>\n<p>Once the data has been corralled into something usable, getting the actual<br>\nanswer is fairly simple.</p>\n<pre><code class=\"language-scala\">def findRoot(nodes: TraversableOnce[Node]): Option[Node] = \n    nodes.find(n =&gt; n.parent.isEmpty)\n// findRoot: (nodes: TraversableOnce[Node])Option[Node]\n</code></pre>\n<p>There is only one example in the puzzle description, but being a recursive<br>\nstructure we can break it down into multiple sub tests. They are unfortunately<br>\nquite verbose.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day7Part1Test extends FunSuite with Matchers {\n  def sample =\n    &quot;&quot;&quot;pbga (66)\n      |xhth (57)\n      |ebii (61)\n      |havc (66)\n      |ktlj (57)\n      |fwft (72) -&gt; ktlj, cntj, xhth\n      |qoyq (66)\n      |padx (45) -&gt; pbga, havc, qoyq\n      |tknk (41) -&gt; ugml, padx, fwft\n      |jptl (61)\n      |ugml (68) -&gt; gyxo, ebii, jptl\n      |gyxo (61)\n      |cntj (57)&quot;&quot;&quot;.stripMargin.lines\n\n  def subSample1 =\n    &quot;&quot;&quot;xhth (57)\n      |ktlj (57)\n      |fwft (72) -&gt; ktlj, cntj, xhth\n      |cntj (57)&quot;&quot;&quot;.stripMargin.lines\n\n  def subSample2 =\n    &quot;&quot;&quot;pbga (67)\n      |havc (66)\n      |qoyq (66)\n      |padx (45) -&gt; pbga, havc, qoyq&quot;&quot;&quot;.stripMargin.lines\n\n  def subSample3 =\n    &quot;&quot;&quot;ugmlq (68) -&gt; gyxo, ebii\n      |ebii (61)\n      |gyxo (61)&quot;&quot;&quot;.stripMargin.lines\n\n\n  test(&quot;can parse input lines&quot;) {\n    val parsedSubSample1: Map[String, Node] = parseInput(subSample1)\n\n    parsedSubSample1.size shouldBe 4\n    parsedSubSample1.get(&quot;xhth&quot;) shouldBe Some(Node(&quot;xhth&quot;, Some(57), Some(&quot;fwft&quot;)))\n    parsedSubSample1.get(&quot;ktlj&quot;) shouldBe Some(Node(&quot;ktlj&quot;, Some(57), Some(&quot;fwft&quot;)))\n    parsedSubSample1.get(&quot;fwft&quot;) shouldBe Some(Node(&quot;fwft&quot;, Some(72), None, Set(&quot;xhth&quot;, &quot;ktlj&quot;, &quot;cntj&quot;)))\n    parsedSubSample1.get(&quot;cntj&quot;) shouldBe Some(Node(&quot;cntj&quot;, Some(57), Some(&quot;fwft&quot;)))\n\n    val parsedSubSample2: Map[String, Node] = parseInput(subSample2)\n\n    parsedSubSample2.size shouldBe 4\n    parsedSubSample2.get(&quot;pbga&quot;) shouldBe Some(Node(&quot;pbga&quot;, Some(67), Some(&quot;padx&quot;)))\n    parsedSubSample2.get(&quot;havc&quot;) shouldBe Some(Node(&quot;havc&quot;, Some(66), Some(&quot;padx&quot;)))\n    parsedSubSample2.get(&quot;padx&quot;) shouldBe Some(Node(&quot;padx&quot;, Some(45), None, Set(&quot;pbga&quot;, &quot;havc&quot;, &quot;qoyq&quot;)))\n    parsedSubSample2.get(&quot;qoyq&quot;) shouldBe Some(Node(&quot;qoyq&quot;, Some(66), Some(&quot;padx&quot;)))\n\n    val parsedSubSample3: Map[String, Node] = parseInput(subSample3)\n\n    parsedSubSample3.size shouldBe 3\n    parsedSubSample3.get(&quot;ebii&quot;) shouldBe Some(Node(&quot;ebii&quot;, Some(61), Some(&quot;ugmlq&quot;)))\n    parsedSubSample3.get(&quot;gyxo&quot;) shouldBe Some(Node(&quot;gyxo&quot;, Some(61), Some(&quot;ugmlq&quot;)))\n    parsedSubSample3.get(&quot;ugmlq&quot;) shouldBe Some(Node(&quot;ugmlq&quot;, Some(68), None, Set(&quot;ebii&quot;, &quot;gyxo&quot;)))\n\n    val parsedSample: Map[String, Node] = parseInput(sample)\n\n    parsedSample.size shouldBe 13\n    parsedSample.get(&quot;xhth&quot;) shouldBe Some(Node(&quot;xhth&quot;, Some(57), Some(&quot;fwft&quot;)))\n    parsedSample.get(&quot;ktlj&quot;) shouldBe Some(Node(&quot;ktlj&quot;, Some(57), Some(&quot;fwft&quot;)))\n    parsedSample.get(&quot;fwft&quot;) shouldBe Some(Node(&quot;fwft&quot;, Some(72), Some(&quot;tknk&quot;), Set(&quot;xhth&quot;, &quot;ktlj&quot;, &quot;cntj&quot;)))\n    parsedSample.get(&quot;cntj&quot;) shouldBe Some(Node(&quot;cntj&quot;, Some(57), Some(&quot;fwft&quot;)))\n    parsedSample.get(&quot;pbga&quot;) shouldBe Some(Node(&quot;pbga&quot;, Some(66), Some(&quot;padx&quot;)))\n    parsedSample.get(&quot;havc&quot;) shouldBe Some(Node(&quot;havc&quot;, Some(66), Some(&quot;padx&quot;)))\n    parsedSample.get(&quot;padx&quot;) shouldBe Some(Node(&quot;padx&quot;, Some(45), Some(&quot;tknk&quot;), Set(&quot;pbga&quot;, &quot;havc&quot;, &quot;qoyq&quot;)))\n    parsedSample.get(&quot;qoyq&quot;) shouldBe Some(Node(&quot;qoyq&quot;, Some(66), Some(&quot;padx&quot;)))\n    parsedSample.get(&quot;ebii&quot;) shouldBe Some(Node(&quot;ebii&quot;, Some(61), Some(&quot;ugml&quot;)))\n    parsedSample.get(&quot;gyxo&quot;) shouldBe Some(Node(&quot;gyxo&quot;, Some(61), Some(&quot;ugml&quot;)))\n    parsedSample.get(&quot;ugml&quot;) shouldBe Some(Node(&quot;ugml&quot;, Some(68), Some(&quot;tknk&quot;), Set(&quot;ebii&quot;, &quot;gyxo&quot;, &quot;jptl&quot;)))\n    parsedSample.get(&quot;jptl&quot;) shouldBe Some(Node(&quot;jptl&quot;, Some(61), Some(&quot;ugml&quot;)))\n    parsedSample.get(&quot;tknk&quot;) shouldBe Some(Node(&quot;tknk&quot;, Some(41), None, Set(&quot;ugml&quot;, &quot;padx&quot;, &quot;fwft&quot;)))\n  }\n\n  test(&quot;can find structure root&quot;) {\n    findRoot(parseInput(subSample1).map { case (_, v) =&gt; v }).map(n =&gt; n.name) shouldBe Some(&quot;fwft&quot;)\n    findRoot(parseInput(subSample2).values).map(n =&gt; n.name) shouldBe Some(&quot;padx&quot;)\n    findRoot(parseInput(subSample3).values).map(n =&gt; n.name) shouldBe Some(&quot;ugmlq&quot;)\n    findRoot(parseInput(sample).values).map(n =&gt; n.name) shouldBe Some(&quot;tknk&quot;)\n  }\n}\n// defined class Day7Part1Test\n\n(new Day7Part1Test).execute()\n// Day7Part1Test:\n// - can parse input lines\n// - can find structure root\n</code></pre>\n<p>I can now parse the input file and find the solution:</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(&quot;day7input.txt&quot;).getLines())\n// input: Map[NodeRef,Node] = Map(wqobawc -&gt; Node(wqobawc,Some(67),Some(cpoxc),Set()), xeppuz -&gt; Node(xeppuz,Some(7),Some(cfmcrf),Set()), ewzvs -&gt; Node(ewzvs,Some(54),Some(vpnfkw),Set()), yujhec -&gt; Node(yujhec,Some(30),Some(ucocdl),Set(rnbvott, nmwrqbx, etingr, dktkg, qkzgb)), gmtzu -&gt; Node(gmtzu,Some(30),Some(tjmyc),Set()), isuevmr -&gt; Node(isuevmr,Some(221),Some(qsiqu),Set(sphktgz, gjauauy, bncsnst)), kdrswra -&gt; Node(kdrswra,Some(102),Some(tymahpb),Set(xreip, ghxwug)), mdimlja -&gt; Node(mdimlja,Some(36),Some(pxzoq),Set()), zdagr -&gt; Node(zdagr,Some(249),Some(nwand),Set(gqjhcw, qvcpu)), wgqnrc -&gt; Node(wgqnrc,Some(30),Some(dyfptec),Set()), svnqa -&gt; Node(svnqa,Some(313),Some(tjrecaq),Set(nthqzh, uekit, hopiqm)), fabacam -&gt; Node(fabacam,Some(305),Some(anygv),Set(dlcxjg, dlactl, falrf)), yfkyv -&gt;...\n\nfindRoot(input.values).get.name\n// res1: String = xegshds\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Now I actually have to do some analysis of the data structure. Each node has a weight. The structure should have an invariant such that for each node, each of its sub-trees has the same weight. However there is one node that is violating this. The task is to find that node, and return the weight it <strong>should</strong> be to satisfy the invariant.</p>\n<p>Since I already have a way to find the root, I can start there, but to calculate the sub-tree weights I need to start at the roots. So the recursive function first recurses until it hits leaves, which have an empty group, and just return their weight.</p>\n<p>Once we have data for all the children, if any of them don't have the same weight we have found the corrupt node, and can just pass that up the tree. For this reason the recursion returns an optional node and corrected weight pair.</p>\n<p>If this is set for any of the nodes, it can be returned, otherwise if one child has a different weight, calculate the difference and set the data to be passed down.</p>\n<pre><code class=\"language-scala\">def findMismatchedNode(nodes: Map[NodeRef, Node]): Option[(Node, Int)] = {\n  def iter(node: Node): (Int, Option[(Node, Int)]) = {\n    val childData = node.children.toList.map(\n      c_ref =&gt; (c_ref, iter(nodes(c_ref)))\n    )\n\n    val totalWeight =\n      node.weight.getOrElse(0) + childData.map { case (_, (w, _)) =&gt; w }.sum\n\n    val groups = childData.groupBy { case (_, (w, _)) =&gt; w }\n    (\n      totalWeight,\n      groups\n        .find { case (_, ns) =&gt; ns.lengthCompare(1) == 0 }\n        .collect {\n          case (cW, (c_ref, (_, maybeNode)) :: _) =&gt;\n            maybeNode.getOrElse({\n              val childNode = nodes(c_ref)\n              (\n                childNode,\n                groups.find {\n                  case (_, ns) =&gt; ns.lengthCompare(1) &gt; 0\n                }.map {\n                  case (w, _) =&gt; childNode.weight.getOrElse(0) - cW + w\n                }.getOrElse(0)\n              )\n            })\n        }\n    )\n  }\n  \n  val root = findRoot(nodes.values)\n  \n  root.flatMap { r =&gt;\n    iter(r) match {\n      case (_, maybeMismatch) =&gt; maybeMismatch\n    }\n  }\n}\n// findMismatchedNode: (nodes: Map[NodeRef,Node])Option[(Node, Int)]\n</code></pre>\n<p>The testing can reuse most of the data from the previous tests.</p>\n<pre><code class=\"language-scala\">class Day7Part2Test extends FunSuite with Matchers {\n  def sample =\n    &quot;&quot;&quot;pbga (66)\n      |xhth (57)\n      |ebii (61)\n      |havc (66)\n      |ktlj (57)\n      |fwft (72) -&gt; ktlj, cntj, xhth\n      |qoyq (66)\n      |padx (45) -&gt; pbga, havc, qoyq\n      |tknk (41) -&gt; ugml, padx, fwft\n      |jptl (61)\n      |ugml (68) -&gt; gyxo, ebii, jptl\n      |gyxo (61)\n      |cntj (57)&quot;&quot;&quot;.stripMargin.lines\n\n  def subSample2 =\n    &quot;&quot;&quot;pbga (67)\n      |havc (66)\n      |qoyq (66)\n      |padx (45) -&gt; pbga, havc, qoyq&quot;&quot;&quot;.stripMargin.lines\n\n  test(&quot;testFindMismatchedWeight&quot;) {\n    findMismatchedNode(parseInput(subSample2)) shouldBe\n    Some((Node(&quot;pbga&quot;, Some(67), Some(&quot;padx&quot;)), 66))\n\n    findMismatchedNode(parseInput(sample)) shouldBe\n    Some((Node(&quot;ugml&quot;, Some(68), Some(&quot;tknk&quot;), Set(&quot;ebii&quot;, &quot;gyxo&quot;, &quot;jptl&quot;)), 60))\n  }\n}\n// defined class Day7Part2Test\n\n(new Day7Part2Test).execute()\n// Day7Part2Test:\n// - testFindMismatchedWeight\n</code></pre>\n<p>And finally I can now extract the puzzle solution from the data returned:</p>\n<pre><code class=\"language-scala\">findMismatchedNode(input).get._2\n// res3: Int = 299\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3309939c9605113d0a498d","plaintext":"A solution for Advent of Code 2017 - Day 7 [http://adventofcode.com/2017/day/7]\n\nPart 1\nToday the puzzle scenario is a recursive data structure, realised as a wobbling\ntower of discs. The main aim of part one is to make sense of the way this\nstructure is represented. At least, sense enough to determine its root.\n\nSince the nodes of the structure are labeled with strings, I can store this as a\nmap of string to a case class to store a reference to the parent, and to any\nchildren. Using the string label, rather than a hard reference to the other node\nmakes the structure much easier to build one node at a time. To make things a\nbit easier to keep track of, I'll use a type alias to mark when a string is\nbeing used as a reference to a node.\n\ntype NodeRef = String\n// defined type alias NodeRef\n\ncase class Node(name: String,\n                weight: Option[Int] = None,\n                parent: Option[NodeRef] = None,\n                children: Set[NodeRef] = Set.empty)\n// defined class Node\n\nval LineMatcher = \"([a-z]+) \\\\((\\\\d+)\\\\)(?: -> ((?:[a-z]+(?:, )?)+))?\".r\n// LineMatcher: scala.util.matching.Regex = ([a-z]+) \\((\\d+)\\)(?: -> ((?:[a-z]+(?:, )?)+))?\n\ndef parseChildList(children: String): Set[NodeRef] = (\n  if (children == null) Set.empty\n  else children.split(\", \").toSet\n)\n// parseChildList: (children: String)Set[NodeRef]\n\ndef parseInput(lines: TraversableOnce[String]): Map[NodeRef, Node] = (\n  lines.foldLeft(Map.empty[String, Node]) {\n    case (map, LineMatcher(name, weight, children)) =>\n      val node =\n        map.getOrElse(name, Node(name))\n          .copy(\n            weight = Some(weight.toInt),\n            children = parseChildList(children)\n          )\n      node.children\n        .foldLeft(map.updated(node.name, node)) {\n          case (newMap, nodeRef) =>\n            newMap.updated(\n              nodeRef,\n              newMap.getOrElse(nodeRef, Node(nodeRef))\n                .copy(parent = Some(node.name))\n            )\n        }\n    case (map, _) => map\n  }\n)\n// parseInput: (lines: TraversableOnce[String])Map[NodeRef,Node]\n\n\nOnce the data has been corralled into something usable, getting the actual\nanswer is fairly simple.\n\ndef findRoot(nodes: TraversableOnce[Node]): Option[Node] = \n    nodes.find(n => n.parent.isEmpty)\n// findRoot: (nodes: TraversableOnce[Node])Option[Node]\n\n\nThere is only one example in the puzzle description, but being a recursive\nstructure we can break it down into multiple sub tests. They are unfortunately\nquite verbose.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day7Part1Test extends FunSuite with Matchers {\n  def sample =\n    \"\"\"pbga (66)\n      |xhth (57)\n      |ebii (61)\n      |havc (66)\n      |ktlj (57)\n      |fwft (72) -> ktlj, cntj, xhth\n      |qoyq (66)\n      |padx (45) -> pbga, havc, qoyq\n      |tknk (41) -> ugml, padx, fwft\n      |jptl (61)\n      |ugml (68) -> gyxo, ebii, jptl\n      |gyxo (61)\n      |cntj (57)\"\"\".stripMargin.lines\n\n  def subSample1 =\n    \"\"\"xhth (57)\n      |ktlj (57)\n      |fwft (72) -> ktlj, cntj, xhth\n      |cntj (57)\"\"\".stripMargin.lines\n\n  def subSample2 =\n    \"\"\"pbga (67)\n      |havc (66)\n      |qoyq (66)\n      |padx (45) -> pbga, havc, qoyq\"\"\".stripMargin.lines\n\n  def subSample3 =\n    \"\"\"ugmlq (68) -> gyxo, ebii\n      |ebii (61)\n      |gyxo (61)\"\"\".stripMargin.lines\n\n\n  test(\"can parse input lines\") {\n    val parsedSubSample1: Map[String, Node] = parseInput(subSample1)\n\n    parsedSubSample1.size shouldBe 4\n    parsedSubSample1.get(\"xhth\") shouldBe Some(Node(\"xhth\", Some(57), Some(\"fwft\")))\n    parsedSubSample1.get(\"ktlj\") shouldBe Some(Node(\"ktlj\", Some(57), Some(\"fwft\")))\n    parsedSubSample1.get(\"fwft\") shouldBe Some(Node(\"fwft\", Some(72), None, Set(\"xhth\", \"ktlj\", \"cntj\")))\n    parsedSubSample1.get(\"cntj\") shouldBe Some(Node(\"cntj\", Some(57), Some(\"fwft\")))\n\n    val parsedSubSample2: Map[String, Node] = parseInput(subSample2)\n\n    parsedSubSample2.size shouldBe 4\n    parsedSubSample2.get(\"pbga\") shouldBe Some(Node(\"pbga\", Some(67), Some(\"padx\")))\n    parsedSubSample2.get(\"havc\") shouldBe Some(Node(\"havc\", Some(66), Some(\"padx\")))\n    parsedSubSample2.get(\"padx\") shouldBe Some(Node(\"padx\", Some(45), None, Set(\"pbga\", \"havc\", \"qoyq\")))\n    parsedSubSample2.get(\"qoyq\") shouldBe Some(Node(\"qoyq\", Some(66), Some(\"padx\")))\n\n    val parsedSubSample3: Map[String, Node] = parseInput(subSample3)\n\n    parsedSubSample3.size shouldBe 3\n    parsedSubSample3.get(\"ebii\") shouldBe Some(Node(\"ebii\", Some(61), Some(\"ugmlq\")))\n    parsedSubSample3.get(\"gyxo\") shouldBe Some(Node(\"gyxo\", Some(61), Some(\"ugmlq\")))\n    parsedSubSample3.get(\"ugmlq\") shouldBe Some(Node(\"ugmlq\", Some(68), None, Set(\"ebii\", \"gyxo\")))\n\n    val parsedSample: Map[String, Node] = parseInput(sample)\n\n    parsedSample.size shouldBe 13\n    parsedSample.get(\"xhth\") shouldBe Some(Node(\"xhth\", Some(57), Some(\"fwft\")))\n    parsedSample.get(\"ktlj\") shouldBe Some(Node(\"ktlj\", Some(57), Some(\"fwft\")))\n    parsedSample.get(\"fwft\") shouldBe Some(Node(\"fwft\", Some(72), Some(\"tknk\"), Set(\"xhth\", \"ktlj\", \"cntj\")))\n    parsedSample.get(\"cntj\") shouldBe Some(Node(\"cntj\", Some(57), Some(\"fwft\")))\n    parsedSample.get(\"pbga\") shouldBe Some(Node(\"pbga\", Some(66), Some(\"padx\")))\n    parsedSample.get(\"havc\") shouldBe Some(Node(\"havc\", Some(66), Some(\"padx\")))\n    parsedSample.get(\"padx\") shouldBe Some(Node(\"padx\", Some(45), Some(\"tknk\"), Set(\"pbga\", \"havc\", \"qoyq\")))\n    parsedSample.get(\"qoyq\") shouldBe Some(Node(\"qoyq\", Some(66), Some(\"padx\")))\n    parsedSample.get(\"ebii\") shouldBe Some(Node(\"ebii\", Some(61), Some(\"ugml\")))\n    parsedSample.get(\"gyxo\") shouldBe Some(Node(\"gyxo\", Some(61), Some(\"ugml\")))\n    parsedSample.get(\"ugml\") shouldBe Some(Node(\"ugml\", Some(68), Some(\"tknk\"), Set(\"ebii\", \"gyxo\", \"jptl\")))\n    parsedSample.get(\"jptl\") shouldBe Some(Node(\"jptl\", Some(61), Some(\"ugml\")))\n    parsedSample.get(\"tknk\") shouldBe Some(Node(\"tknk\", Some(41), None, Set(\"ugml\", \"padx\", \"fwft\")))\n  }\n\n  test(\"can find structure root\") {\n    findRoot(parseInput(subSample1).map { case (_, v) => v }).map(n => n.name) shouldBe Some(\"fwft\")\n    findRoot(parseInput(subSample2).values).map(n => n.name) shouldBe Some(\"padx\")\n    findRoot(parseInput(subSample3).values).map(n => n.name) shouldBe Some(\"ugmlq\")\n    findRoot(parseInput(sample).values).map(n => n.name) shouldBe Some(\"tknk\")\n  }\n}\n// defined class Day7Part1Test\n\n(new Day7Part1Test).execute()\n// Day7Part1Test:\n// - can parse input lines\n// - can find structure root\n\n\nI can now parse the input file and find the solution:\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(\"day7input.txt\").getLines())\n// input: Map[NodeRef,Node] = Map(wqobawc -> Node(wqobawc,Some(67),Some(cpoxc),Set()), xeppuz -> Node(xeppuz,Some(7),Some(cfmcrf),Set()), ewzvs -> Node(ewzvs,Some(54),Some(vpnfkw),Set()), yujhec -> Node(yujhec,Some(30),Some(ucocdl),Set(rnbvott, nmwrqbx, etingr, dktkg, qkzgb)), gmtzu -> Node(gmtzu,Some(30),Some(tjmyc),Set()), isuevmr -> Node(isuevmr,Some(221),Some(qsiqu),Set(sphktgz, gjauauy, bncsnst)), kdrswra -> Node(kdrswra,Some(102),Some(tymahpb),Set(xreip, ghxwug)), mdimlja -> Node(mdimlja,Some(36),Some(pxzoq),Set()), zdagr -> Node(zdagr,Some(249),Some(nwand),Set(gqjhcw, qvcpu)), wgqnrc -> Node(wgqnrc,Some(30),Some(dyfptec),Set()), svnqa -> Node(svnqa,Some(313),Some(tjrecaq),Set(nthqzh, uekit, hopiqm)), fabacam -> Node(fabacam,Some(305),Some(anygv),Set(dlcxjg, dlactl, falrf)), yfkyv ->...\n\nfindRoot(input.values).get.name\n// res1: String = xegshds\n\n\nPart 2\nNow I actually have to do some analysis of the data structure. Each node has a\nweight. The structure should have an invariant such that for each node, each of\nits sub-trees has the same weight. However there is one node that is violating\nthis. The task is to find that node, and return the weight it should be to\nsatisfy the invariant.\n\nSince I already have a way to find the root, I can start there, but to calculate\nthe sub-tree weights I need to start at the roots. So the recursive function\nfirst recurses until it hits leaves, which have an empty group, and just return\ntheir weight.\n\nOnce we have data for all the children, if any of them don't have the same\nweight we have found the corrupt node, and can just pass that up the tree. For\nthis reason the recursion returns an optional node and corrected weight pair.\n\nIf this is set for any of the nodes, it can be returned, otherwise if one child\nhas a different weight, calculate the difference and set the data to be passed\ndown.\n\ndef findMismatchedNode(nodes: Map[NodeRef, Node]): Option[(Node, Int)] = {\n  def iter(node: Node): (Int, Option[(Node, Int)]) = {\n    val childData = node.children.toList.map(\n      c_ref => (c_ref, iter(nodes(c_ref)))\n    )\n\n    val totalWeight =\n      node.weight.getOrElse(0) + childData.map { case (_, (w, _)) => w }.sum\n\n    val groups = childData.groupBy { case (_, (w, _)) => w }\n    (\n      totalWeight,\n      groups\n        .find { case (_, ns) => ns.lengthCompare(1) == 0 }\n        .collect {\n          case (cW, (c_ref, (_, maybeNode)) :: _) =>\n            maybeNode.getOrElse({\n              val childNode = nodes(c_ref)\n              (\n                childNode,\n                groups.find {\n                  case (_, ns) => ns.lengthCompare(1) > 0\n                }.map {\n                  case (w, _) => childNode.weight.getOrElse(0) - cW + w\n                }.getOrElse(0)\n              )\n            })\n        }\n    )\n  }\n  \n  val root = findRoot(nodes.values)\n  \n  root.flatMap { r =>\n    iter(r) match {\n      case (_, maybeMismatch) => maybeMismatch\n    }\n  }\n}\n// findMismatchedNode: (nodes: Map[NodeRef,Node])Option[(Node, Int)]\n\n\nThe testing can reuse most of the data from the previous tests.\n\nclass Day7Part2Test extends FunSuite with Matchers {\n  def sample =\n    \"\"\"pbga (66)\n      |xhth (57)\n      |ebii (61)\n      |havc (66)\n      |ktlj (57)\n      |fwft (72) -> ktlj, cntj, xhth\n      |qoyq (66)\n      |padx (45) -> pbga, havc, qoyq\n      |tknk (41) -> ugml, padx, fwft\n      |jptl (61)\n      |ugml (68) -> gyxo, ebii, jptl\n      |gyxo (61)\n      |cntj (57)\"\"\".stripMargin.lines\n\n  def subSample2 =\n    \"\"\"pbga (67)\n      |havc (66)\n      |qoyq (66)\n      |padx (45) -> pbga, havc, qoyq\"\"\".stripMargin.lines\n\n  test(\"testFindMismatchedWeight\") {\n    findMismatchedNode(parseInput(subSample2)) shouldBe\n    Some((Node(\"pbga\", Some(67), Some(\"padx\")), 66))\n\n    findMismatchedNode(parseInput(sample)) shouldBe\n    Some((Node(\"ugml\", Some(68), Some(\"tknk\"), Set(\"ebii\", \"gyxo\", \"jptl\")), 60))\n  }\n}\n// defined class Day7Part2Test\n\n(new Day7Part2Test).execute()\n// Day7Part2Test:\n// - testFindMismatchedWeight\n\n\nAnd finally I can now extract the puzzle solution from the data returned:\n\nfindMismatchedNode(input).get._2\n// res3: Int = 299","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-9.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-14T23:30:27.000Z","updated_at":"2017-12-15T00:42:20.000Z","published_at":"2017-12-14T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 7","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a33186f9c9605113d0a4994","uuid":"37216be8-3893-4ea2-bd06-f09761dc49df","title":"I Heard You Like Registers","slug":"aoc-2017-day-8-i-heard-you-like-registers","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 8](http://adventofcode.com/2017/day/8)\\n\\n## Part 1\\n\\nToday the task is to parse a rudimentary instruction language. Each line of the input represents an instruction that will update a value in a named register if a condition on another, or possibly the same register is met. Whilst this could be done matching on the strings, scala has a rich syntax for expressing these more clearly. So firstly I set up a way to represent the parts of the instruction. Unassigned registers default to 0.\\n\\n```scala\\nimport scala.util.{Failure, Success, Try}\\n// import scala.util.{Failure, Success, Try}\\n\\ntype RegisterRef = String\\n// defined type alias RegisterRef\\n\\nsealed trait Operator {\\n  def apply(a: Int, b: Int): Int\\n}\\n// defined trait Operator\\n\\ncase object Inc extends Operator {\\n  override def apply(a: Int, b: Int): Int = a + b\\n}\\n// defined object Inc\\n\\ncase object Dec extends Operator {\\n  def apply(a: Int, b: Int): Int = a - b\\n}\\n// defined object Dec\\n\\nsealed trait Condition {\\n  def test(a: Int, b: Int): Boolean\\n}\\n// defined trait Condition\\n\\ncase object Eq extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a == b\\n}\\n// defined object Eq\\n\\ncase object Neq extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a != b\\n}\\n// defined object Neq\\n\\ncase object Lt extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a < b\\n}\\n// defined object Lt\\n\\ncase object Lte extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a <= b\\n}\\n// defined object Lte\\n\\ncase object Gt extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a > b\\n}\\n// defined object Gt\\n\\ncase object Gte extends Condition {\\n  override def test(a: Int, b: Int): Boolean = a >= b\\n}\\n// defined object Gte\\n\\n// The next two should be in an Condition companion object, but the plugin\\n// that runs the embeded code gets confused by it \\ndef conditionFromString(str: String): Condition = str match {\\n  case \\\"==\\\" => Eq\\n  case \\\"!=\\\" => Neq\\n  case \\\"<\\\" => Lt\\n  case \\\"<=\\\" => Lte\\n  case \\\">\\\" => Gt\\n  case \\\">=\\\" => Gte\\n}\\n// conditionFromString: (str: String)Condition\\n\\ncase class Instruction(register: RegisterRef,\\n                       operator: Operator,\\n                       value: Int,\\n                       conditionRegister: RegisterRef,\\n                       condition: Condition,\\n                       conditionValue: Int) {\\n  def apply(registers: Map[RegisterRef, Int]): Map[RegisterRef, Int] = (\\n    if (condition.test(registers(conditionRegister), conditionValue))\\n      registers.updated(register, operator(registers(register), value))\\n    else\\n      registers\\n  )   \\n\\n  // Ignore this until part 2\\n  def apply(registers: Map[RegisterRef, Int], max: Int): (Map[RegisterRef, Int], Int) = (\\n    if (condition.test(registers(conditionRegister), conditionValue)) {\\n      val newVal = operator(registers(register), value)\\n      (registers.updated(register, newVal), Math.max(max, newVal))\\n    }\\n    else (registers, max)\\n  )\\n}\\n// defined class Instruction\\n\\n// The next two should be in an Instruction companion object, but the plugin\\n// that runs the embeded code gets confused by it \\nval LineParser =\\n    \\\"([a-z]+) (inc|dec) (-?\\\\\\\\d+) if ([a-z]+) ([!<>=]{1,2}) (-?\\\\\\\\d+)\\\".r\\n// LineParser: scala.util.matching.Regex = ([a-z]+) (inc|dec) (-?\\\\d+) if ([a-z]+) ([!<>=]{1,2}) (-?\\\\d+)\\n\\ndef instructionFromLine(line: String): Try[Instruction] = {\\n  line match {\\n    case LineParser(reg, op, value, condReg, cond, condVal) =>\\n      Success(Instruction(\\n        reg,\\n        if (op == \\\"inc\\\") Inc else Dec,\\n        value.toInt,\\n        condReg,\\n        conditionFromString(cond),\\n        condVal.toInt\\n      ))\\n  \\n    case _ =>\\n      Failure(new RuntimeException(\\\"line was not a valid instruction\\\"))\\n  }\\n}\\n// instructionFromLine: (line: String)scala.util.Try[Instruction]\\n```\\n\\nThe actual task is to apply the sequence of instructions, and then find the\\nmaximally valued register.\\n\\n```scala\\ndef applyInstructions(registers: Map[RegisterRef, Int],\\n                      instructions: TraversableOnce[Instruction]\\n                     ): Map[RegisterRef, Int] =\\n  instructions.foldLeft(registers) { case (rs, ins) => ins(rs) }\\n// applyInstructions: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Map[RegisterRef,Int]\\n\\ndef findMax(registers: Map[RegisterRef, Int]): (RegisterRef, Int) = (\\n  if (registers.isEmpty) (\\\"\\\", Int.MinValue)\\n  else registers.maxBy { case (_, v) => v }\\n)\\n// findMax: (registers: Map[RegisterRef,Int])(RegisterRef, Int)\\n```  \\n\\nThe example provided can be expanded into some test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nimport scala.util.Success\\n// import scala.util.Success\\n\\nclass Day8Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can parse instruction\\\") {\\n    instructionFromLine(\\\"b inc 5 if a > 1\\\") shouldBe Success(Instruction(\\\"b\\\", Inc, 5, \\\"a\\\", Gt, 1))\\n    instructionFromLine(\\\"a inc 1 if b < 5\\\") shouldBe Success(Instruction(\\\"a\\\", Inc, 1, \\\"b\\\", Lt, 5))\\n    instructionFromLine(\\\"c dec -10 if a >= 1\\\") shouldBe Success(Instruction(\\\"c\\\", Dec, -10, \\\"a\\\", Gte, 1))\\n    instructionFromLine(\\\"c inc -20 if c == 10\\\") shouldBe Success(Instruction(\\\"c\\\", Inc, -20, \\\"c\\\", Eq, 10))\\n  }\\n\\n  test(\\\"can apply instruction\\\") {\\n    val emptyRegister = Map.empty[RegisterRef, Int].withDefaultValue(0)\\n\\n    instructionFromLine(\\\"b inc 5 if a > 1\\\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\\n    instructionFromLine(\\\"b inc 5 if a > 1\\\").map(_ (Map(\\\"a\\\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 1))\\n    instructionFromLine(\\\"b inc 5 if a > 1\\\").map(_ (Map(\\\"a\\\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 2, \\\"b\\\" -> 5))\\n\\n    instructionFromLine(\\\"a inc 1 if b < 5\\\").map(_ (emptyRegister)) shouldBe Success(Map(\\\"a\\\" -> 1))\\n    instructionFromLine(\\\"a inc 1 if b < 5\\\").map(_ (Map(\\\"b\\\" -> 4).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 1, \\\"b\\\" -> 4))\\n    instructionFromLine(\\\"a inc 1 if b < 5\\\").map(_ (Map(\\\"b\\\" -> 5).withDefaultValue(0))) shouldBe Success(Map(\\\"b\\\" -> 5))\\n\\n    instructionFromLine(\\\"c dec -10 if a >= 1\\\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\\n    instructionFromLine(\\\"c dec -10 if a >= 1\\\").map(_ (Map(\\\"a\\\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 1, \\\"c\\\" -> 10))\\n    instructionFromLine(\\\"c dec -10 if a >= 1\\\").map(_ (Map(\\\"a\\\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 2, \\\"c\\\" -> 10))\\n\\n    instructionFromLine(\\\"c dec -10 if a <= 1\\\").map(_ (emptyRegister)) shouldBe Success(Map(\\\"c\\\" -> 10))\\n    instructionFromLine(\\\"c dec -10 if a <= 1\\\").map(_ (Map(\\\"a\\\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 1, \\\"c\\\" -> 10))\\n    instructionFromLine(\\\"c dec -10 if a <= 1\\\").map(_ (Map(\\\"a\\\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\\\"a\\\" -> 2))\\n\\n    instructionFromLine(\\\"c inc -20 if c == 10\\\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\\n    instructionFromLine(\\\"c inc -20 if c == 10\\\").map(_ (Map(\\\"c\\\" -> 10).withDefaultValue(0))) shouldBe Success(Map(\\\"c\\\" -> -10))\\n    instructionFromLine(\\\"c inc -20 if c == 10\\\").map(_ (Map(\\\"c\\\" -> 11, \\\"d\\\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\\\"c\\\" -> 11, \\\"d\\\" -> 23))\\n\\n    instructionFromLine(\\\"a dec 20 if c != 10\\\").map(_ (emptyRegister)) shouldBe Success(Map(\\\"a\\\" -> -20))\\n    instructionFromLine(\\\"a dec 20 if c != 10\\\").map(_ (Map(\\\"c\\\" -> 10, \\\"d\\\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\\\"c\\\" -> 10, \\\"d\\\" -> 23))\\n    instructionFromLine(\\\"a dec 20 if c != 10\\\").map(_ (Map(\\\"c\\\" -> 11, \\\"a\\\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\\\"c\\\" -> 11, \\\"a\\\" -> 3))\\n  }\\n\\n  test(\\\"can apply instructions\\\") {\\n    val instructions: Iterator[Instruction] =\\n      \\\"\\\"\\\"b inc 5 if a > 1\\n        |a inc 1 if b < 5\\n        |c dec -10 if a >= 1\\n        |c inc -20 if c == 10\\\"\\\"\\\".stripMargin.lines\\n        .map(instructionFromLine)\\n        .collect { case Success(i) => i }\\n\\n    applyInstructions(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe Map(\\\"a\\\"->1, \\\"c\\\" -> -10)\\n  }\\n\\n  test(\\\"can find maximum register value\\\") {\\n    findMax(Map(\\\"a\\\"->1, \\\"c\\\" -> -10)) should be (\\\"a\\\", 1)\\n  }\\n}\\n// defined class Day8Part1Test\\n\\n(new Day8Part1Test).execute()\\n// Day8Part1Test:\\n// - can parse instruction\\n// - can apply instruction\\n// - can apply instructions\\n// - can find maximum register value\\n```\\n\\nAll the pieces are now in place to run the input program.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval registers = Map.empty[RegisterRef, Int].withDefaultValue(0)\\n// registers: scala.collection.immutable.Map[RegisterRef,Int] = Map()\\n\\ndef instructions: Iterator[Instruction] =\\n  Source.fromResource(\\\"day8input.txt\\\").getLines().map(instructionFromLine).collect { case Success(i) => i }\\n// instructions: Iterator[Instruction]\\n\\nfindMax(applyInstructions(registers, instructions))\\n// res5: (RegisterRef, Int) = (gf,6343)\\n```\\n\\n## Part 2\\n\\nSince most of the leg work in the first part was interpreting the instructions part two is much simpler. It wants to find the maximum value that was present at any point during the computation.\\n\\nOriginally I wrote this by calling findMax after each step. I then noticed that if the maximum was going to change, then the newly set value would have to be the new maximum as all other values were unchanged. I wrote a different version of Instruction.apply that you can see in the code above, that also updates the current max if required.\\n\\n```scala\\ndef findProcessingMax(registers: Map[RegisterRef, Int],\\n                      instructions: TraversableOnce[Instruction]\\n                     ): Int =\\n  instructions.foldLeft((registers, Int.MinValue)) {\\n    case ((rs, max), ins) => ins(rs, max)\\n  }._2\\n// findProcessingMax: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Int\\n```\\n\\nGiven the change was reasonably simple, I only added the example as a test for this part.\\n\\n```scala\\nclass Day8Test extends FunSuite with Matchers {\\n  test(\\\"can find processing max\\\") {\\n    val instructions: Iterator[Instruction] =\\n      \\\"\\\"\\\"b inc 5 if a > 1\\n        |a inc 1 if b < 5\\n        |c dec -10 if a >= 1\\n        |c inc -20 if c == 10\\\"\\\"\\\".stripMargin.lines\\n        .map(instructionFromLine)\\n        .collect { case Success(i) => i }\\n\\n    findProcessingMax(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe 10\\n  }\\n}\\n// defined class Day8Test\\n```\\n\\nNow I can complete the puzzle.\\n\\n```scala\\nfindProcessingMax(registers, instructions)\\n// res6: Int = 7184\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/8\">Advent of Code 2017 - Day 8</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today the task is to parse a rudimentary instruction language. Each line of the input represents an instruction that will update a value in a named register if a condition on another, or possibly the same register is met. Whilst this could be done matching on the strings, scala has a rich syntax for expressing these more clearly. So firstly I set up a way to represent the parts of the instruction. Unassigned registers default to 0.</p>\n<pre><code class=\"language-scala\">import scala.util.{Failure, Success, Try}\n// import scala.util.{Failure, Success, Try}\n\ntype RegisterRef = String\n// defined type alias RegisterRef\n\nsealed trait Operator {\n  def apply(a: Int, b: Int): Int\n}\n// defined trait Operator\n\ncase object Inc extends Operator {\n  override def apply(a: Int, b: Int): Int = a + b\n}\n// defined object Inc\n\ncase object Dec extends Operator {\n  def apply(a: Int, b: Int): Int = a - b\n}\n// defined object Dec\n\nsealed trait Condition {\n  def test(a: Int, b: Int): Boolean\n}\n// defined trait Condition\n\ncase object Eq extends Condition {\n  override def test(a: Int, b: Int): Boolean = a == b\n}\n// defined object Eq\n\ncase object Neq extends Condition {\n  override def test(a: Int, b: Int): Boolean = a != b\n}\n// defined object Neq\n\ncase object Lt extends Condition {\n  override def test(a: Int, b: Int): Boolean = a &lt; b\n}\n// defined object Lt\n\ncase object Lte extends Condition {\n  override def test(a: Int, b: Int): Boolean = a &lt;= b\n}\n// defined object Lte\n\ncase object Gt extends Condition {\n  override def test(a: Int, b: Int): Boolean = a &gt; b\n}\n// defined object Gt\n\ncase object Gte extends Condition {\n  override def test(a: Int, b: Int): Boolean = a &gt;= b\n}\n// defined object Gte\n\n// The next two should be in an Condition companion object, but the plugin\n// that runs the embeded code gets confused by it \ndef conditionFromString(str: String): Condition = str match {\n  case &quot;==&quot; =&gt; Eq\n  case &quot;!=&quot; =&gt; Neq\n  case &quot;&lt;&quot; =&gt; Lt\n  case &quot;&lt;=&quot; =&gt; Lte\n  case &quot;&gt;&quot; =&gt; Gt\n  case &quot;&gt;=&quot; =&gt; Gte\n}\n// conditionFromString: (str: String)Condition\n\ncase class Instruction(register: RegisterRef,\n                       operator: Operator,\n                       value: Int,\n                       conditionRegister: RegisterRef,\n                       condition: Condition,\n                       conditionValue: Int) {\n  def apply(registers: Map[RegisterRef, Int]): Map[RegisterRef, Int] = (\n    if (condition.test(registers(conditionRegister), conditionValue))\n      registers.updated(register, operator(registers(register), value))\n    else\n      registers\n  )   \n\n  // Ignore this until part 2\n  def apply(registers: Map[RegisterRef, Int], max: Int): (Map[RegisterRef, Int], Int) = (\n    if (condition.test(registers(conditionRegister), conditionValue)) {\n      val newVal = operator(registers(register), value)\n      (registers.updated(register, newVal), Math.max(max, newVal))\n    }\n    else (registers, max)\n  )\n}\n// defined class Instruction\n\n// The next two should be in an Instruction companion object, but the plugin\n// that runs the embeded code gets confused by it \nval LineParser =\n    &quot;([a-z]+) (inc|dec) (-?\\\\d+) if ([a-z]+) ([!&lt;&gt;=]{1,2}) (-?\\\\d+)&quot;.r\n// LineParser: scala.util.matching.Regex = ([a-z]+) (inc|dec) (-?\\d+) if ([a-z]+) ([!&lt;&gt;=]{1,2}) (-?\\d+)\n\ndef instructionFromLine(line: String): Try[Instruction] = {\n  line match {\n    case LineParser(reg, op, value, condReg, cond, condVal) =&gt;\n      Success(Instruction(\n        reg,\n        if (op == &quot;inc&quot;) Inc else Dec,\n        value.toInt,\n        condReg,\n        conditionFromString(cond),\n        condVal.toInt\n      ))\n  \n    case _ =&gt;\n      Failure(new RuntimeException(&quot;line was not a valid instruction&quot;))\n  }\n}\n// instructionFromLine: (line: String)scala.util.Try[Instruction]\n</code></pre>\n<p>The actual task is to apply the sequence of instructions, and then find the<br>\nmaximally valued register.</p>\n<pre><code class=\"language-scala\">def applyInstructions(registers: Map[RegisterRef, Int],\n                      instructions: TraversableOnce[Instruction]\n                     ): Map[RegisterRef, Int] =\n  instructions.foldLeft(registers) { case (rs, ins) =&gt; ins(rs) }\n// applyInstructions: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Map[RegisterRef,Int]\n\ndef findMax(registers: Map[RegisterRef, Int]): (RegisterRef, Int) = (\n  if (registers.isEmpty) (&quot;&quot;, Int.MinValue)\n  else registers.maxBy { case (_, v) =&gt; v }\n)\n// findMax: (registers: Map[RegisterRef,Int])(RegisterRef, Int)\n</code></pre>\n<p>The example provided can be expanded into some test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nimport scala.util.Success\n// import scala.util.Success\n\nclass Day8Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can parse instruction&quot;) {\n    instructionFromLine(&quot;b inc 5 if a &gt; 1&quot;) shouldBe Success(Instruction(&quot;b&quot;, Inc, 5, &quot;a&quot;, Gt, 1))\n    instructionFromLine(&quot;a inc 1 if b &lt; 5&quot;) shouldBe Success(Instruction(&quot;a&quot;, Inc, 1, &quot;b&quot;, Lt, 5))\n    instructionFromLine(&quot;c dec -10 if a &gt;= 1&quot;) shouldBe Success(Instruction(&quot;c&quot;, Dec, -10, &quot;a&quot;, Gte, 1))\n    instructionFromLine(&quot;c inc -20 if c == 10&quot;) shouldBe Success(Instruction(&quot;c&quot;, Inc, -20, &quot;c&quot;, Eq, 10))\n  }\n\n  test(&quot;can apply instruction&quot;) {\n    val emptyRegister = Map.empty[RegisterRef, Int].withDefaultValue(0)\n\n    instructionFromLine(&quot;b inc 5 if a &gt; 1&quot;).map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(&quot;b inc 5 if a &gt; 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 1).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 1))\n    instructionFromLine(&quot;b inc 5 if a &gt; 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 2).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 2, &quot;b&quot; -&gt; 5))\n\n    instructionFromLine(&quot;a inc 1 if b &lt; 5&quot;).map(_ (emptyRegister)) shouldBe Success(Map(&quot;a&quot; -&gt; 1))\n    instructionFromLine(&quot;a inc 1 if b &lt; 5&quot;).map(_ (Map(&quot;b&quot; -&gt; 4).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 4))\n    instructionFromLine(&quot;a inc 1 if b &lt; 5&quot;).map(_ (Map(&quot;b&quot; -&gt; 5).withDefaultValue(0))) shouldBe Success(Map(&quot;b&quot; -&gt; 5))\n\n    instructionFromLine(&quot;c dec -10 if a &gt;= 1&quot;).map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(&quot;c dec -10 if a &gt;= 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 1).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 1, &quot;c&quot; -&gt; 10))\n    instructionFromLine(&quot;c dec -10 if a &gt;= 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 2).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 2, &quot;c&quot; -&gt; 10))\n\n    instructionFromLine(&quot;c dec -10 if a &lt;= 1&quot;).map(_ (emptyRegister)) shouldBe Success(Map(&quot;c&quot; -&gt; 10))\n    instructionFromLine(&quot;c dec -10 if a &lt;= 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 1).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 1, &quot;c&quot; -&gt; 10))\n    instructionFromLine(&quot;c dec -10 if a &lt;= 1&quot;).map(_ (Map(&quot;a&quot; -&gt; 2).withDefaultValue(0))) shouldBe Success(Map(&quot;a&quot; -&gt; 2))\n\n    instructionFromLine(&quot;c inc -20 if c == 10&quot;).map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(&quot;c inc -20 if c == 10&quot;).map(_ (Map(&quot;c&quot; -&gt; 10).withDefaultValue(0))) shouldBe Success(Map(&quot;c&quot; -&gt; -10))\n    instructionFromLine(&quot;c inc -20 if c == 10&quot;).map(_ (Map(&quot;c&quot; -&gt; 11, &quot;d&quot; -&gt; 23).withDefaultValue(0))) shouldBe Success(Map(&quot;c&quot; -&gt; 11, &quot;d&quot; -&gt; 23))\n\n    instructionFromLine(&quot;a dec 20 if c != 10&quot;).map(_ (emptyRegister)) shouldBe Success(Map(&quot;a&quot; -&gt; -20))\n    instructionFromLine(&quot;a dec 20 if c != 10&quot;).map(_ (Map(&quot;c&quot; -&gt; 10, &quot;d&quot; -&gt; 23).withDefaultValue(0))) shouldBe Success(Map(&quot;c&quot; -&gt; 10, &quot;d&quot; -&gt; 23))\n    instructionFromLine(&quot;a dec 20 if c != 10&quot;).map(_ (Map(&quot;c&quot; -&gt; 11, &quot;a&quot; -&gt; 23).withDefaultValue(0))) shouldBe Success(Map(&quot;c&quot; -&gt; 11, &quot;a&quot; -&gt; 3))\n  }\n\n  test(&quot;can apply instructions&quot;) {\n    val instructions: Iterator[Instruction] =\n      &quot;&quot;&quot;b inc 5 if a &gt; 1\n        |a inc 1 if b &lt; 5\n        |c dec -10 if a &gt;= 1\n        |c inc -20 if c == 10&quot;&quot;&quot;.stripMargin.lines\n        .map(instructionFromLine)\n        .collect { case Success(i) =&gt; i }\n\n    applyInstructions(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe Map(&quot;a&quot;-&gt;1, &quot;c&quot; -&gt; -10)\n  }\n\n  test(&quot;can find maximum register value&quot;) {\n    findMax(Map(&quot;a&quot;-&gt;1, &quot;c&quot; -&gt; -10)) should be (&quot;a&quot;, 1)\n  }\n}\n// defined class Day8Part1Test\n\n(new Day8Part1Test).execute()\n// Day8Part1Test:\n// - can parse instruction\n// - can apply instruction\n// - can apply instructions\n// - can find maximum register value\n</code></pre>\n<p>All the pieces are now in place to run the input program.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval registers = Map.empty[RegisterRef, Int].withDefaultValue(0)\n// registers: scala.collection.immutable.Map[RegisterRef,Int] = Map()\n\ndef instructions: Iterator[Instruction] =\n  Source.fromResource(&quot;day8input.txt&quot;).getLines().map(instructionFromLine).collect { case Success(i) =&gt; i }\n// instructions: Iterator[Instruction]\n\nfindMax(applyInstructions(registers, instructions))\n// res5: (RegisterRef, Int) = (gf,6343)\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Since most of the leg work in the first part was interpreting the instructions part two is much simpler. It wants to find the maximum value that was present at any point during the computation.</p>\n<p>Originally I wrote this by calling findMax after each step. I then noticed that if the maximum was going to change, then the newly set value would have to be the new maximum as all other values were unchanged. I wrote a different version of Instruction.apply that you can see in the code above, that also updates the current max if required.</p>\n<pre><code class=\"language-scala\">def findProcessingMax(registers: Map[RegisterRef, Int],\n                      instructions: TraversableOnce[Instruction]\n                     ): Int =\n  instructions.foldLeft((registers, Int.MinValue)) {\n    case ((rs, max), ins) =&gt; ins(rs, max)\n  }._2\n// findProcessingMax: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Int\n</code></pre>\n<p>Given the change was reasonably simple, I only added the example as a test for this part.</p>\n<pre><code class=\"language-scala\">class Day8Test extends FunSuite with Matchers {\n  test(&quot;can find processing max&quot;) {\n    val instructions: Iterator[Instruction] =\n      &quot;&quot;&quot;b inc 5 if a &gt; 1\n        |a inc 1 if b &lt; 5\n        |c dec -10 if a &gt;= 1\n        |c inc -20 if c == 10&quot;&quot;&quot;.stripMargin.lines\n        .map(instructionFromLine)\n        .collect { case Success(i) =&gt; i }\n\n    findProcessingMax(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe 10\n  }\n}\n// defined class Day8Test\n</code></pre>\n<p>Now I can complete the puzzle.</p>\n<pre><code class=\"language-scala\">findProcessingMax(registers, instructions)\n// res6: Int = 7184\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a33186f9c9605113d0a4994","plaintext":"A solution for Advent of Code 2017 - Day 8 [http://adventofcode.com/2017/day/8]\n\nPart 1\nToday the task is to parse a rudimentary instruction language. Each line of the\ninput represents an instruction that will update a value in a named register if\na condition on another, or possibly the same register is met. Whilst this could\nbe done matching on the strings, scala has a rich syntax for expressing these\nmore clearly. So firstly I set up a way to represent the parts of the\ninstruction. Unassigned registers default to 0.\n\nimport scala.util.{Failure, Success, Try}\n// import scala.util.{Failure, Success, Try}\n\ntype RegisterRef = String\n// defined type alias RegisterRef\n\nsealed trait Operator {\n  def apply(a: Int, b: Int): Int\n}\n// defined trait Operator\n\ncase object Inc extends Operator {\n  override def apply(a: Int, b: Int): Int = a + b\n}\n// defined object Inc\n\ncase object Dec extends Operator {\n  def apply(a: Int, b: Int): Int = a - b\n}\n// defined object Dec\n\nsealed trait Condition {\n  def test(a: Int, b: Int): Boolean\n}\n// defined trait Condition\n\ncase object Eq extends Condition {\n  override def test(a: Int, b: Int): Boolean = a == b\n}\n// defined object Eq\n\ncase object Neq extends Condition {\n  override def test(a: Int, b: Int): Boolean = a != b\n}\n// defined object Neq\n\ncase object Lt extends Condition {\n  override def test(a: Int, b: Int): Boolean = a < b\n}\n// defined object Lt\n\ncase object Lte extends Condition {\n  override def test(a: Int, b: Int): Boolean = a <= b\n}\n// defined object Lte\n\ncase object Gt extends Condition {\n  override def test(a: Int, b: Int): Boolean = a > b\n}\n// defined object Gt\n\ncase object Gte extends Condition {\n  override def test(a: Int, b: Int): Boolean = a >= b\n}\n// defined object Gte\n\n// The next two should be in an Condition companion object, but the plugin\n// that runs the embeded code gets confused by it \ndef conditionFromString(str: String): Condition = str match {\n  case \"==\" => Eq\n  case \"!=\" => Neq\n  case \"<\" => Lt\n  case \"<=\" => Lte\n  case \">\" => Gt\n  case \">=\" => Gte\n}\n// conditionFromString: (str: String)Condition\n\ncase class Instruction(register: RegisterRef,\n                       operator: Operator,\n                       value: Int,\n                       conditionRegister: RegisterRef,\n                       condition: Condition,\n                       conditionValue: Int) {\n  def apply(registers: Map[RegisterRef, Int]): Map[RegisterRef, Int] = (\n    if (condition.test(registers(conditionRegister), conditionValue))\n      registers.updated(register, operator(registers(register), value))\n    else\n      registers\n  )   \n\n  // Ignore this until part 2\n  def apply(registers: Map[RegisterRef, Int], max: Int): (Map[RegisterRef, Int], Int) = (\n    if (condition.test(registers(conditionRegister), conditionValue)) {\n      val newVal = operator(registers(register), value)\n      (registers.updated(register, newVal), Math.max(max, newVal))\n    }\n    else (registers, max)\n  )\n}\n// defined class Instruction\n\n// The next two should be in an Instruction companion object, but the plugin\n// that runs the embeded code gets confused by it \nval LineParser =\n    \"([a-z]+) (inc|dec) (-?\\\\d+) if ([a-z]+) ([!<>=]{1,2}) (-?\\\\d+)\".r\n// LineParser: scala.util.matching.Regex = ([a-z]+) (inc|dec) (-?\\d+) if ([a-z]+) ([!<>=]{1,2}) (-?\\d+)\n\ndef instructionFromLine(line: String): Try[Instruction] = {\n  line match {\n    case LineParser(reg, op, value, condReg, cond, condVal) =>\n      Success(Instruction(\n        reg,\n        if (op == \"inc\") Inc else Dec,\n        value.toInt,\n        condReg,\n        conditionFromString(cond),\n        condVal.toInt\n      ))\n  \n    case _ =>\n      Failure(new RuntimeException(\"line was not a valid instruction\"))\n  }\n}\n// instructionFromLine: (line: String)scala.util.Try[Instruction]\n\n\nThe actual task is to apply the sequence of instructions, and then find the\nmaximally valued register.\n\ndef applyInstructions(registers: Map[RegisterRef, Int],\n                      instructions: TraversableOnce[Instruction]\n                     ): Map[RegisterRef, Int] =\n  instructions.foldLeft(registers) { case (rs, ins) => ins(rs) }\n// applyInstructions: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Map[RegisterRef,Int]\n\ndef findMax(registers: Map[RegisterRef, Int]): (RegisterRef, Int) = (\n  if (registers.isEmpty) (\"\", Int.MinValue)\n  else registers.maxBy { case (_, v) => v }\n)\n// findMax: (registers: Map[RegisterRef,Int])(RegisterRef, Int)\n\n\nThe example provided can be expanded into some test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nimport scala.util.Success\n// import scala.util.Success\n\nclass Day8Part1Test extends FunSuite with Matchers {\n\n  test(\"can parse instruction\") {\n    instructionFromLine(\"b inc 5 if a > 1\") shouldBe Success(Instruction(\"b\", Inc, 5, \"a\", Gt, 1))\n    instructionFromLine(\"a inc 1 if b < 5\") shouldBe Success(Instruction(\"a\", Inc, 1, \"b\", Lt, 5))\n    instructionFromLine(\"c dec -10 if a >= 1\") shouldBe Success(Instruction(\"c\", Dec, -10, \"a\", Gte, 1))\n    instructionFromLine(\"c inc -20 if c == 10\") shouldBe Success(Instruction(\"c\", Inc, -20, \"c\", Eq, 10))\n  }\n\n  test(\"can apply instruction\") {\n    val emptyRegister = Map.empty[RegisterRef, Int].withDefaultValue(0)\n\n    instructionFromLine(\"b inc 5 if a > 1\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(\"b inc 5 if a > 1\").map(_ (Map(\"a\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 1))\n    instructionFromLine(\"b inc 5 if a > 1\").map(_ (Map(\"a\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 2, \"b\" -> 5))\n\n    instructionFromLine(\"a inc 1 if b < 5\").map(_ (emptyRegister)) shouldBe Success(Map(\"a\" -> 1))\n    instructionFromLine(\"a inc 1 if b < 5\").map(_ (Map(\"b\" -> 4).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 1, \"b\" -> 4))\n    instructionFromLine(\"a inc 1 if b < 5\").map(_ (Map(\"b\" -> 5).withDefaultValue(0))) shouldBe Success(Map(\"b\" -> 5))\n\n    instructionFromLine(\"c dec -10 if a >= 1\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(\"c dec -10 if a >= 1\").map(_ (Map(\"a\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 1, \"c\" -> 10))\n    instructionFromLine(\"c dec -10 if a >= 1\").map(_ (Map(\"a\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 2, \"c\" -> 10))\n\n    instructionFromLine(\"c dec -10 if a <= 1\").map(_ (emptyRegister)) shouldBe Success(Map(\"c\" -> 10))\n    instructionFromLine(\"c dec -10 if a <= 1\").map(_ (Map(\"a\" -> 1).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 1, \"c\" -> 10))\n    instructionFromLine(\"c dec -10 if a <= 1\").map(_ (Map(\"a\" -> 2).withDefaultValue(0))) shouldBe Success(Map(\"a\" -> 2))\n\n    instructionFromLine(\"c inc -20 if c == 10\").map(_ (emptyRegister)) shouldBe Success(emptyRegister)\n    instructionFromLine(\"c inc -20 if c == 10\").map(_ (Map(\"c\" -> 10).withDefaultValue(0))) shouldBe Success(Map(\"c\" -> -10))\n    instructionFromLine(\"c inc -20 if c == 10\").map(_ (Map(\"c\" -> 11, \"d\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\"c\" -> 11, \"d\" -> 23))\n\n    instructionFromLine(\"a dec 20 if c != 10\").map(_ (emptyRegister)) shouldBe Success(Map(\"a\" -> -20))\n    instructionFromLine(\"a dec 20 if c != 10\").map(_ (Map(\"c\" -> 10, \"d\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\"c\" -> 10, \"d\" -> 23))\n    instructionFromLine(\"a dec 20 if c != 10\").map(_ (Map(\"c\" -> 11, \"a\" -> 23).withDefaultValue(0))) shouldBe Success(Map(\"c\" -> 11, \"a\" -> 3))\n  }\n\n  test(\"can apply instructions\") {\n    val instructions: Iterator[Instruction] =\n      \"\"\"b inc 5 if a > 1\n        |a inc 1 if b < 5\n        |c dec -10 if a >= 1\n        |c inc -20 if c == 10\"\"\".stripMargin.lines\n        .map(instructionFromLine)\n        .collect { case Success(i) => i }\n\n    applyInstructions(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe Map(\"a\"->1, \"c\" -> -10)\n  }\n\n  test(\"can find maximum register value\") {\n    findMax(Map(\"a\"->1, \"c\" -> -10)) should be (\"a\", 1)\n  }\n}\n// defined class Day8Part1Test\n\n(new Day8Part1Test).execute()\n// Day8Part1Test:\n// - can parse instruction\n// - can apply instruction\n// - can apply instructions\n// - can find maximum register value\n\n\nAll the pieces are now in place to run the input program.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval registers = Map.empty[RegisterRef, Int].withDefaultValue(0)\n// registers: scala.collection.immutable.Map[RegisterRef,Int] = Map()\n\ndef instructions: Iterator[Instruction] =\n  Source.fromResource(\"day8input.txt\").getLines().map(instructionFromLine).collect { case Success(i) => i }\n// instructions: Iterator[Instruction]\n\nfindMax(applyInstructions(registers, instructions))\n// res5: (RegisterRef, Int) = (gf,6343)\n\n\nPart 2\nSince most of the leg work in the first part was interpreting the instructions\npart two is much simpler. It wants to find the maximum value that was present at\nany point during the computation.\n\nOriginally I wrote this by calling findMax after each step. I then noticed that\nif the maximum was going to change, then the newly set value would have to be\nthe new maximum as all other values were unchanged. I wrote a different version\nof Instruction.apply that you can see in the code above, that also updates the\ncurrent max if required.\n\ndef findProcessingMax(registers: Map[RegisterRef, Int],\n                      instructions: TraversableOnce[Instruction]\n                     ): Int =\n  instructions.foldLeft((registers, Int.MinValue)) {\n    case ((rs, max), ins) => ins(rs, max)\n  }._2\n// findProcessingMax: (registers: Map[RegisterRef,Int], instructions: TraversableOnce[Instruction])Int\n\n\nGiven the change was reasonably simple, I only added the example as a test for\nthis part.\n\nclass Day8Test extends FunSuite with Matchers {\n  test(\"can find processing max\") {\n    val instructions: Iterator[Instruction] =\n      \"\"\"b inc 5 if a > 1\n        |a inc 1 if b < 5\n        |c dec -10 if a >= 1\n        |c inc -20 if c == 10\"\"\".stripMargin.lines\n        .map(instructionFromLine)\n        .collect { case Success(i) => i }\n\n    findProcessingMax(Map.empty[RegisterRef, Int].withDefaultValue(0), instructions) shouldBe 10\n  }\n}\n// defined class Day8Test\n\n\nNow I can complete the puzzle.\n\nfindProcessingMax(registers, instructions)\n// res6: Int = 7184","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-12.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-15T00:33:51.000Z","updated_at":"2017-12-15T05:00:00.000Z","published_at":"2017-12-15T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 8","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a34731e9c9605113d0a499d","uuid":"4b46cd10-d172-403e-a505-36f5abb72137","title":"Stream Processing","slug":"aoc-2017-day-9-stream-processing","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 9](http://adventofcode.com/2017/day/9)\\n\\n## Part 1\\n\\nToday's task is kind of a twist on ensuring your curly braces match up. Not really much of a problem now that compilers and IDEs can do that for you. The twist is that as well as the curly braces there are angle braces, and these change the rules for how characters should be parsed when encountered.\\n\\nThis puzzle is crying out for a state machine. I used a bunch of case classes, probably more than was needed for the puzzle given that the provided stream doesn't need validating against the syntax. For the puzzle I only need to enough interpretation to keep track of nesting depth, parsing mode (garbage/not), and when a group closes. I decided to instead essentially emit a state between each character. This then had a function to get the next state given the following character. Whilst a bit more verbose, it makes it easier to read what is going on, and is more likely to be reusable for part 2.\\n\\n```scala\\nobject Day9 {\\n  sealed trait State {\\n    def apply(char: Char): State\\n  }\\n\\n  case object ExpectOpen extends State {\\n    override def apply(char: Char): State = char match {\\n      case '{' => StartGroup\\n      case '<' => StartGarbage\\n      case _ => Error(\\\"ExpectOpen: expected '{' or '<'; got \\\" + char)\\n    }\\n  }\\n\\n  case object StartGroup extends State {\\n    override def apply(char: Char): State = char match {\\n      case '{' => StartGroup\\n      case '<' => StartGarbage\\n      case '}' => CloseGroup\\n      case _ => Error(\\\"ExpectOpen: expected '{', '}', or '<'; got \\\" + char)\\n    }\\n  }\\n\\n  case object CloseGroup extends State {\\n    override def apply(char: Char): State = char match {\\n      case ',' => ExpectOpen\\n      case '}' => CloseGroup\\n      case _ => Error(\\\"StartGroup: expected '}' or ','; got \\\" + char)\\n    }\\n  }\\n\\n  case object InGarbage extends State {\\n    override def apply(char: Char): State = char match {\\n      case '>' => CloseGarbage\\n      case '!' => Escaped\\n      case _ => InGarbage\\n    }\\n  }\\n\\n  // In initially for part 1 this didn't exist and there was just InGarbage.\\n  // It is easier to include it here than have to redefine all the states again \\n  // for part 2\\n  case object StartGarbage extends State {\\n    override def apply(char: Char): State = char match {\\n      case '>' => CloseGarbage\\n      case '!' => Escaped\\n      case _ => InGarbage\\n    }\\n  }\\n\\n  case object Escaped extends State {\\n    override def apply(char: Char): State = StartGarbage\\n  }\\n\\n  case object CloseGarbage extends State {\\n    override def apply(char: Char): State = char match {\\n      case ',' => ExpectOpen\\n      case '}' => CloseGroup\\n      case _ => Error(\\\"StartGroup: expected '}' or ','; got \\\" + char)\\n    }\\n  }\\n\\n  case class Error(msg: String) extends State {\\n    override def apply(char: Char): State = this\\n  }\\n}\\n// defined object Day9\\n```\\n\\nTo map the stream of chars from the input to a stream of states I can pull a nifty trick of lazily defining a Stream starting with the initial state. Then to get the rest of that stream I append the Stream[Chars] zipped with the stream itself. Since the first value is defined, that gets zipped with the first character, which is enough to compute the second state. Thanks to the lazy evaluation, that second state is then available to be zipped with the second Char, producing a third state, and so on...\\n\\n```scala\\nimport Day9._\\n// import Day9._\\n\\ndef parseStream(chars: Stream[Char]): Stream[State] = {\\n\\n  lazy val states: Stream[State] =\\n    ExpectOpen #:: states.zip(chars).map { case (s, c) => s(c) }\\n\\n  states\\n}\\n// parseStream: (chars: Stream[Char])Stream[Day9.State]\\n```\\n\\nNow there is a stream of states it is possible to filter to just the ones needed to calculate the current depth (Start Group increments, End Group decrements) and a running total (one of Start or End Group, I chose End as it means the current value of depth is the correct depth to add to the score.)\\n\\n```scala\\ndef scoreGroups(states: Stream[State]): Int = {\\n  def iter(states: Stream[State], depth: Int = 0, score: Int = 0): Int =\\n    states match {\\n      case Stream.Empty => score\\n      case StartGroup #:: tail => iter(tail, depth + 1, score)\\n      case CloseGroup #:: tail => iter(tail, depth - 1, score + depth)\\n      case _ #:: tail => iter(tail, depth, score)\\n    }\\n\\n  iter(states)\\n}\\n// scoreGroups: (states: Stream[Day9.State])Int\\n```\\n\\nBoth the parsing and the reduction need some testing. Today there is a wealth of test cases from the puzzle description. Even abstracting out some repeated patterns the stream\\nparsing tests are quite verbose, but as I'm essentially mapping each character to multiple words that is expected.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day9Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can parse stream\\\") {\\n\\n    def repeat[T](n: Int, value: T): Stream[T] = {\\n      if (n == 0) Stream.empty\\n      else value #:: repeat(n - 1, value)\\n    }\\n\\n    parseStream(\\\"<>,\\\".toStream) shouldBe Stream(ExpectOpen, StartGarbage, CloseGarbage, ExpectOpen)\\n\\n    parseStream(\\\"<random characters>,\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen, StartGarbage),\\n      repeat(17, InGarbage),\\n      Stream(CloseGarbage, ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"<<<<>,\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen, StartGarbage),\\n      repeat(3, InGarbage),\\n      Stream(CloseGarbage, ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"<{!>}>,\\\".toStream) shouldBe Stream(\\n      ExpectOpen,\\n      StartGarbage,\\n      InGarbage,\\n      Escaped,\\n      StartGarbage,\\n      InGarbage,\\n      CloseGarbage,\\n      ExpectOpen\\n    )\\n\\n    parseStream(\\\"<!!>,\\\".toStream) shouldBe Stream(\\n      ExpectOpen,\\n      StartGarbage,\\n      Escaped,\\n      StartGarbage,\\n      CloseGarbage,\\n      ExpectOpen\\n    )\\n\\n    parseStream(\\\"<!!!>>,\\\".toStream) shouldBe Stream(\\n      ExpectOpen,\\n      StartGarbage,\\n      Escaped,\\n      StartGarbage,\\n      Escaped,\\n      StartGarbage,\\n      CloseGarbage,\\n      ExpectOpen\\n    )\\n\\n    parseStream(\\\"<{o\\\\\\\"i!a,<{i<a>,\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen, StartGarbage),\\n      repeat(4, InGarbage),\\n      Stream(Escaped, StartGarbage),\\n      repeat(6, InGarbage),\\n      Stream(CloseGarbage, ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"{},\\\".toStream) shouldBe Stream(\\n      ExpectOpen,\\n      StartGroup,\\n      CloseGroup,\\n      ExpectOpen\\n    )\\n\\n    parseStream(\\\"{},\\\".toStream).count(_ == StartGroup) shouldBe 1\\n\\n    parseStream(\\\"{{{}}},\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen),\\n      repeat(3, StartGroup),\\n      repeat(3, CloseGroup),\\n      Stream(ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"{{{}}},\\\".toStream).count(_ == StartGroup) shouldBe 3\\n\\n    parseStream(\\\"{{},{}},\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen),\\n      repeat(2, StartGroup),\\n      Stream(CloseGroup, ExpectOpen, StartGroup),\\n      repeat(2, CloseGroup),\\n      Stream(ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"{{{}}},\\\".toStream).count(_ == StartGroup) shouldBe 3\\n\\n    parseStream(\\\"{{{},{},{{}}}},\\\".toStream) shouldBe Stream(\\n      Stream(ExpectOpen),\\n      repeat(2, StartGroup),\\n      repeat(2, Stream(StartGroup, CloseGroup, ExpectOpen)).flatten,\\n      repeat(2, StartGroup),\\n      repeat(4, CloseGroup),\\n      Stream(ExpectOpen)\\n    ).flatten\\n\\n    parseStream(\\\"{{{},{},{{}}}},\\\".toStream).count(_ == StartGroup) shouldBe 6\\n\\n    parseStream(\\\"{<a>,<a>,<a>,<a>},\\\".toStream).count(_ == StartGroup) shouldBe 1\\n    parseStream(\\\"{{<a>},{<a>},{<a>},{<a>}},\\\".toStream).count(_ == StartGroup) shouldBe 5\\n    parseStream(\\\"{{<!>},{<!>},{<!>},{<a>}},\\\".toStream).count(_ == StartGroup) shouldBe 2\\n\\n  }\\n\\n  test(\\\"can calculate the group score\\\") {\\n\\n    scoreGroups(parseStream(\\\"{},\\\".toStream)) shouldBe 1\\n    scoreGroups(parseStream(\\\"{{{}}},\\\".toStream)) shouldBe 6\\n    scoreGroups(parseStream(\\\"{{},{}},\\\".toStream)) shouldBe 5\\n    scoreGroups(parseStream(\\\"{{{},{},{{}}}},\\\".toStream)) shouldBe 16\\n    scoreGroups(parseStream(\\\"{<a>,<a>,<a>,<a>},\\\".toStream)) shouldBe 1\\n    scoreGroups(parseStream(\\\"{{<ab>},{<ab>},{<ab>},{<ab>}},\\\".toStream)) shouldBe 9\\n    scoreGroups(parseStream(\\\"{{<!!>},{<!!>},{<!!>},{<!!>}},\\\".toStream)) shouldBe 9\\n    scoreGroups(parseStream(\\\"{{<a!>},{<a!>},{<a!>},{<ab>}},\\\".toStream)) shouldBe 3\\n\\n  }\\n}\\n// defined class Day9Part1Test\\n\\n(new Day9Part1Test).execute()\\n// Day9Part1Test:\\n// - can parse stream\\n// - can calculate the group score\\n```\\n\\nWith those passing, I can get the score for the full puzzle input.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\ndef input = Source.fromResource(\\\"day9input.txt\\\").toStream\\n// input: scala.collection.immutable.Stream[Char]\\n\\nscoreGroups(parseStream(input))\\n// res1: Int = 23588\\n```\\n\\n## Part 2\\n\\nFor this I needed to analyse the garbage instead of the groups. You may have noted the comment about StartGarbage not existing when I wrote part 1. This was because there was no need to distinguish if we'd just read the opening < of a garbage sequence, and the rest of the sequence. Part two however asked for just that. So I refactored the states to distinguish start from in, and the rest was just counting.\\n\\n```scala\\ndef countGarbageChars(states: Stream[State]): Int =\\n  states.count(_ == InGarbage)\\n// countGarbageChars: (states: Stream[Day9.State])Int\\n```\\n\\nThe parsing tests still work, so the refactor had been completed correctly. Reworking the tests for part 2 gives the following.\\n\\n```scala\\nclass Day9Part2Test extends FunSuite with Matchers {\\n  test(\\\"can count garbage chars\\\") {\\n    countGarbageChars(parseStream(\\\"<>,\\\".toStream)) shouldBe 0\\n    countGarbageChars(parseStream(\\\"<random characters>,\\\".toStream)) shouldBe 17\\n    countGarbageChars(parseStream(\\\"<<<<>,\\\".toStream)) shouldBe 3\\n    countGarbageChars(parseStream(\\\"<{!>}>,\\\".toStream)) shouldBe 2\\n    countGarbageChars(parseStream(\\\"<!!>,\\\".toStream)) shouldBe 0\\n    countGarbageChars(parseStream(\\\"<!!!>>,\\\".toStream)) shouldBe 0\\n    countGarbageChars(parseStream(\\\"<{o\\\\\\\"i!a,<{i<a>,\\\".toStream)) shouldBe 10\\n    countGarbageChars(parseStream(\\\"{{<!!>},{<!!>},{<!!>},{<!!>}},\\\".toStream)) shouldBe 0\\n    countGarbageChars(parseStream(\\\"{{<a!>},{<a!>},{<a!>},{<ab>}},\\\".toStream)) shouldBe 17\\n  }\\n}\\n// defined class Day9Part2Test\\n\\n(new Day9Part2Test).execute()\\n// Day9Part2Test:\\n// - can count garbage chars\\n```\\n\\nThis can then be applied to the puzzle input\\n\\n```scala\\ncountGarbageChars(parseStream(input))\\n// res3: Int = 10045\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/9\">Advent of Code 2017 - Day 9</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today's task is kind of a twist on ensuring your curly braces match up. Not really much of a problem now that compilers and IDEs can do that for you. The twist is that as well as the curly braces there are angle braces, and these change the rules for how characters should be parsed when encountered.</p>\n<p>This puzzle is crying out for a state machine. I used a bunch of case classes, probably more than was needed for the puzzle given that the provided stream doesn't need validating against the syntax. For the puzzle I only need to enough interpretation to keep track of nesting depth, parsing mode (garbage/not), and when a group closes. I decided to instead essentially emit a state between each character. This then had a function to get the next state given the following character. Whilst a bit more verbose, it makes it easier to read what is going on, and is more likely to be reusable for part 2.</p>\n<pre><code class=\"language-scala\">object Day9 {\n  sealed trait State {\n    def apply(char: Char): State\n  }\n\n  case object ExpectOpen extends State {\n    override def apply(char: Char): State = char match {\n      case '{' =&gt; StartGroup\n      case '&lt;' =&gt; StartGarbage\n      case _ =&gt; Error(&quot;ExpectOpen: expected '{' or '&lt;'; got &quot; + char)\n    }\n  }\n\n  case object StartGroup extends State {\n    override def apply(char: Char): State = char match {\n      case '{' =&gt; StartGroup\n      case '&lt;' =&gt; StartGarbage\n      case '}' =&gt; CloseGroup\n      case _ =&gt; Error(&quot;ExpectOpen: expected '{', '}', or '&lt;'; got &quot; + char)\n    }\n  }\n\n  case object CloseGroup extends State {\n    override def apply(char: Char): State = char match {\n      case ',' =&gt; ExpectOpen\n      case '}' =&gt; CloseGroup\n      case _ =&gt; Error(&quot;StartGroup: expected '}' or ','; got &quot; + char)\n    }\n  }\n\n  case object InGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case '&gt;' =&gt; CloseGarbage\n      case '!' =&gt; Escaped\n      case _ =&gt; InGarbage\n    }\n  }\n\n  // In initially for part 1 this didn't exist and there was just InGarbage.\n  // It is easier to include it here than have to redefine all the states again \n  // for part 2\n  case object StartGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case '&gt;' =&gt; CloseGarbage\n      case '!' =&gt; Escaped\n      case _ =&gt; InGarbage\n    }\n  }\n\n  case object Escaped extends State {\n    override def apply(char: Char): State = StartGarbage\n  }\n\n  case object CloseGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case ',' =&gt; ExpectOpen\n      case '}' =&gt; CloseGroup\n      case _ =&gt; Error(&quot;StartGroup: expected '}' or ','; got &quot; + char)\n    }\n  }\n\n  case class Error(msg: String) extends State {\n    override def apply(char: Char): State = this\n  }\n}\n// defined object Day9\n</code></pre>\n<p>To map the stream of chars from the input to a stream of states I can pull a nifty trick of lazily defining a Stream starting with the initial state. Then to get the rest of that stream I append the Stream[Chars] zipped with the stream itself. Since the first value is defined, that gets zipped with the first character, which is enough to compute the second state. Thanks to the lazy evaluation, that second state is then available to be zipped with the second Char, producing a third state, and so on...</p>\n<pre><code class=\"language-scala\">import Day9._\n// import Day9._\n\ndef parseStream(chars: Stream[Char]): Stream[State] = {\n\n  lazy val states: Stream[State] =\n    ExpectOpen #:: states.zip(chars).map { case (s, c) =&gt; s(c) }\n\n  states\n}\n// parseStream: (chars: Stream[Char])Stream[Day9.State]\n</code></pre>\n<p>Now there is a stream of states it is possible to filter to just the ones needed to calculate the current depth (Start Group increments, End Group decrements) and a running total (one of Start or End Group, I chose End as it means the current value of depth is the correct depth to add to the score.)</p>\n<pre><code class=\"language-scala\">def scoreGroups(states: Stream[State]): Int = {\n  def iter(states: Stream[State], depth: Int = 0, score: Int = 0): Int =\n    states match {\n      case Stream.Empty =&gt; score\n      case StartGroup #:: tail =&gt; iter(tail, depth + 1, score)\n      case CloseGroup #:: tail =&gt; iter(tail, depth - 1, score + depth)\n      case _ #:: tail =&gt; iter(tail, depth, score)\n    }\n\n  iter(states)\n}\n// scoreGroups: (states: Stream[Day9.State])Int\n</code></pre>\n<p>Both the parsing and the reduction need some testing. Today there is a wealth of test cases from the puzzle description. Even abstracting out some repeated patterns the stream<br>\nparsing tests are quite verbose, but as I'm essentially mapping each character to multiple words that is expected.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day9Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can parse stream&quot;) {\n\n    def repeat[T](n: Int, value: T): Stream[T] = {\n      if (n == 0) Stream.empty\n      else value #:: repeat(n - 1, value)\n    }\n\n    parseStream(&quot;&lt;&gt;,&quot;.toStream) shouldBe Stream(ExpectOpen, StartGarbage, CloseGarbage, ExpectOpen)\n\n    parseStream(&quot;&lt;random characters&gt;,&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(17, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;&lt;&lt;&lt;&lt;&gt;,&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(3, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;&lt;{!&gt;}&gt;,&quot;.toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      InGarbage,\n      Escaped,\n      StartGarbage,\n      InGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(&quot;&lt;!!&gt;,&quot;.toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(&quot;&lt;!!!&gt;&gt;,&quot;.toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(&quot;&lt;{o\\&quot;i!a,&lt;{i&lt;a&gt;,&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(4, InGarbage),\n      Stream(Escaped, StartGarbage),\n      repeat(6, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;{},&quot;.toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGroup,\n      CloseGroup,\n      ExpectOpen\n    )\n\n    parseStream(&quot;{},&quot;.toStream).count(_ == StartGroup) shouldBe 1\n\n    parseStream(&quot;{{{}}},&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(3, StartGroup),\n      repeat(3, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;{{{}}},&quot;.toStream).count(_ == StartGroup) shouldBe 3\n\n    parseStream(&quot;{{},{}},&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(2, StartGroup),\n      Stream(CloseGroup, ExpectOpen, StartGroup),\n      repeat(2, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;{{{}}},&quot;.toStream).count(_ == StartGroup) shouldBe 3\n\n    parseStream(&quot;{{{},{},{{}}}},&quot;.toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(2, StartGroup),\n      repeat(2, Stream(StartGroup, CloseGroup, ExpectOpen)).flatten,\n      repeat(2, StartGroup),\n      repeat(4, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(&quot;{{{},{},{{}}}},&quot;.toStream).count(_ == StartGroup) shouldBe 6\n\n    parseStream(&quot;{&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;},&quot;.toStream).count(_ == StartGroup) shouldBe 1\n    parseStream(&quot;{{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;}},&quot;.toStream).count(_ == StartGroup) shouldBe 5\n    parseStream(&quot;{{&lt;!&gt;},{&lt;!&gt;},{&lt;!&gt;},{&lt;a&gt;}},&quot;.toStream).count(_ == StartGroup) shouldBe 2\n\n  }\n\n  test(&quot;can calculate the group score&quot;) {\n\n    scoreGroups(parseStream(&quot;{},&quot;.toStream)) shouldBe 1\n    scoreGroups(parseStream(&quot;{{{}}},&quot;.toStream)) shouldBe 6\n    scoreGroups(parseStream(&quot;{{},{}},&quot;.toStream)) shouldBe 5\n    scoreGroups(parseStream(&quot;{{{},{},{{}}}},&quot;.toStream)) shouldBe 16\n    scoreGroups(parseStream(&quot;{&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;},&quot;.toStream)) shouldBe 1\n    scoreGroups(parseStream(&quot;{{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;}},&quot;.toStream)) shouldBe 9\n    scoreGroups(parseStream(&quot;{{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;}},&quot;.toStream)) shouldBe 9\n    scoreGroups(parseStream(&quot;{{&lt;a!&gt;},{&lt;a!&gt;},{&lt;a!&gt;},{&lt;ab&gt;}},&quot;.toStream)) shouldBe 3\n\n  }\n}\n// defined class Day9Part1Test\n\n(new Day9Part1Test).execute()\n// Day9Part1Test:\n// - can parse stream\n// - can calculate the group score\n</code></pre>\n<p>With those passing, I can get the score for the full puzzle input.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\ndef input = Source.fromResource(&quot;day9input.txt&quot;).toStream\n// input: scala.collection.immutable.Stream[Char]\n\nscoreGroups(parseStream(input))\n// res1: Int = 23588\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For this I needed to analyse the garbage instead of the groups. You may have noted the comment about StartGarbage not existing when I wrote part 1. This was because there was no need to distinguish if we'd just read the opening &lt; of a garbage sequence, and the rest of the sequence. Part two however asked for just that. So I refactored the states to distinguish start from in, and the rest was just counting.</p>\n<pre><code class=\"language-scala\">def countGarbageChars(states: Stream[State]): Int =\n  states.count(_ == InGarbage)\n// countGarbageChars: (states: Stream[Day9.State])Int\n</code></pre>\n<p>The parsing tests still work, so the refactor had been completed correctly. Reworking the tests for part 2 gives the following.</p>\n<pre><code class=\"language-scala\">class Day9Part2Test extends FunSuite with Matchers {\n  test(&quot;can count garbage chars&quot;) {\n    countGarbageChars(parseStream(&quot;&lt;&gt;,&quot;.toStream)) shouldBe 0\n    countGarbageChars(parseStream(&quot;&lt;random characters&gt;,&quot;.toStream)) shouldBe 17\n    countGarbageChars(parseStream(&quot;&lt;&lt;&lt;&lt;&gt;,&quot;.toStream)) shouldBe 3\n    countGarbageChars(parseStream(&quot;&lt;{!&gt;}&gt;,&quot;.toStream)) shouldBe 2\n    countGarbageChars(parseStream(&quot;&lt;!!&gt;,&quot;.toStream)) shouldBe 0\n    countGarbageChars(parseStream(&quot;&lt;!!!&gt;&gt;,&quot;.toStream)) shouldBe 0\n    countGarbageChars(parseStream(&quot;&lt;{o\\&quot;i!a,&lt;{i&lt;a&gt;,&quot;.toStream)) shouldBe 10\n    countGarbageChars(parseStream(&quot;{{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;}},&quot;.toStream)) shouldBe 0\n    countGarbageChars(parseStream(&quot;{{&lt;a!&gt;},{&lt;a!&gt;},{&lt;a!&gt;},{&lt;ab&gt;}},&quot;.toStream)) shouldBe 17\n  }\n}\n// defined class Day9Part2Test\n\n(new Day9Part2Test).execute()\n// Day9Part2Test:\n// - can count garbage chars\n</code></pre>\n<p>This can then be applied to the puzzle input</p>\n<pre><code class=\"language-scala\">countGarbageChars(parseStream(input))\n// res3: Int = 10045\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a34731e9c9605113d0a499d","plaintext":"A solution for Advent of Code 2017 - Day 9 [http://adventofcode.com/2017/day/9]\n\nPart 1\nToday's task is kind of a twist on ensuring your curly braces match up. Not\nreally much of a problem now that compilers and IDEs can do that for you. The\ntwist is that as well as the curly braces there are angle braces, and these\nchange the rules for how characters should be parsed when encountered.\n\nThis puzzle is crying out for a state machine. I used a bunch of case classes,\nprobably more than was needed for the puzzle given that the provided stream\ndoesn't need validating against the syntax. For the puzzle I only need to enough\ninterpretation to keep track of nesting depth, parsing mode (garbage/not), and\nwhen a group closes. I decided to instead essentially emit a state between each\ncharacter. This then had a function to get the next state given the following\ncharacter. Whilst a bit more verbose, it makes it easier to read what is going\non, and is more likely to be reusable for part 2.\n\nobject Day9 {\n  sealed trait State {\n    def apply(char: Char): State\n  }\n\n  case object ExpectOpen extends State {\n    override def apply(char: Char): State = char match {\n      case '{' => StartGroup\n      case '<' => StartGarbage\n      case _ => Error(\"ExpectOpen: expected '{' or '<'; got \" + char)\n    }\n  }\n\n  case object StartGroup extends State {\n    override def apply(char: Char): State = char match {\n      case '{' => StartGroup\n      case '<' => StartGarbage\n      case '}' => CloseGroup\n      case _ => Error(\"ExpectOpen: expected '{', '}', or '<'; got \" + char)\n    }\n  }\n\n  case object CloseGroup extends State {\n    override def apply(char: Char): State = char match {\n      case ',' => ExpectOpen\n      case '}' => CloseGroup\n      case _ => Error(\"StartGroup: expected '}' or ','; got \" + char)\n    }\n  }\n\n  case object InGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case '>' => CloseGarbage\n      case '!' => Escaped\n      case _ => InGarbage\n    }\n  }\n\n  // In initially for part 1 this didn't exist and there was just InGarbage.\n  // It is easier to include it here than have to redefine all the states again \n  // for part 2\n  case object StartGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case '>' => CloseGarbage\n      case '!' => Escaped\n      case _ => InGarbage\n    }\n  }\n\n  case object Escaped extends State {\n    override def apply(char: Char): State = StartGarbage\n  }\n\n  case object CloseGarbage extends State {\n    override def apply(char: Char): State = char match {\n      case ',' => ExpectOpen\n      case '}' => CloseGroup\n      case _ => Error(\"StartGroup: expected '}' or ','; got \" + char)\n    }\n  }\n\n  case class Error(msg: String) extends State {\n    override def apply(char: Char): State = this\n  }\n}\n// defined object Day9\n\n\nTo map the stream of chars from the input to a stream of states I can pull a\nnifty trick of lazily defining a Stream starting with the initial state. Then to\nget the rest of that stream I append the Stream[Chars] zipped with the stream\nitself. Since the first value is defined, that gets zipped with the first\ncharacter, which is enough to compute the second state. Thanks to the lazy\nevaluation, that second state is then available to be zipped with the second\nChar, producing a third state, and so on...\n\nimport Day9._\n// import Day9._\n\ndef parseStream(chars: Stream[Char]): Stream[State] = {\n\n  lazy val states: Stream[State] =\n    ExpectOpen #:: states.zip(chars).map { case (s, c) => s(c) }\n\n  states\n}\n// parseStream: (chars: Stream[Char])Stream[Day9.State]\n\n\nNow there is a stream of states it is possible to filter to just the ones needed\nto calculate the current depth (Start Group increments, End Group decrements)\nand a running total (one of Start or End Group, I chose End as it means the\ncurrent value of depth is the correct depth to add to the score.)\n\ndef scoreGroups(states: Stream[State]): Int = {\n  def iter(states: Stream[State], depth: Int = 0, score: Int = 0): Int =\n    states match {\n      case Stream.Empty => score\n      case StartGroup #:: tail => iter(tail, depth + 1, score)\n      case CloseGroup #:: tail => iter(tail, depth - 1, score + depth)\n      case _ #:: tail => iter(tail, depth, score)\n    }\n\n  iter(states)\n}\n// scoreGroups: (states: Stream[Day9.State])Int\n\n\nBoth the parsing and the reduction need some testing. Today there is a wealth of\ntest cases from the puzzle description. Even abstracting out some repeated\npatterns the stream\nparsing tests are quite verbose, but as I'm essentially mapping each character\nto multiple words that is expected.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day9Part1Test extends FunSuite with Matchers {\n\n  test(\"can parse stream\") {\n\n    def repeat[T](n: Int, value: T): Stream[T] = {\n      if (n == 0) Stream.empty\n      else value #:: repeat(n - 1, value)\n    }\n\n    parseStream(\"<>,\".toStream) shouldBe Stream(ExpectOpen, StartGarbage, CloseGarbage, ExpectOpen)\n\n    parseStream(\"<random characters>,\".toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(17, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(\"<<<<>,\".toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(3, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(\"<{!>}>,\".toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      InGarbage,\n      Escaped,\n      StartGarbage,\n      InGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(\"<!!>,\".toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(\"<!!!>>,\".toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      Escaped,\n      StartGarbage,\n      CloseGarbage,\n      ExpectOpen\n    )\n\n    parseStream(\"<{o\\\"i!a,<{i<a>,\".toStream) shouldBe Stream(\n      Stream(ExpectOpen, StartGarbage),\n      repeat(4, InGarbage),\n      Stream(Escaped, StartGarbage),\n      repeat(6, InGarbage),\n      Stream(CloseGarbage, ExpectOpen)\n    ).flatten\n\n    parseStream(\"{},\".toStream) shouldBe Stream(\n      ExpectOpen,\n      StartGroup,\n      CloseGroup,\n      ExpectOpen\n    )\n\n    parseStream(\"{},\".toStream).count(_ == StartGroup) shouldBe 1\n\n    parseStream(\"{{{}}},\".toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(3, StartGroup),\n      repeat(3, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(\"{{{}}},\".toStream).count(_ == StartGroup) shouldBe 3\n\n    parseStream(\"{{},{}},\".toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(2, StartGroup),\n      Stream(CloseGroup, ExpectOpen, StartGroup),\n      repeat(2, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(\"{{{}}},\".toStream).count(_ == StartGroup) shouldBe 3\n\n    parseStream(\"{{{},{},{{}}}},\".toStream) shouldBe Stream(\n      Stream(ExpectOpen),\n      repeat(2, StartGroup),\n      repeat(2, Stream(StartGroup, CloseGroup, ExpectOpen)).flatten,\n      repeat(2, StartGroup),\n      repeat(4, CloseGroup),\n      Stream(ExpectOpen)\n    ).flatten\n\n    parseStream(\"{{{},{},{{}}}},\".toStream).count(_ == StartGroup) shouldBe 6\n\n    parseStream(\"{<a>,<a>,<a>,<a>},\".toStream).count(_ == StartGroup) shouldBe 1\n    parseStream(\"{{<a>},{<a>},{<a>},{<a>}},\".toStream).count(_ == StartGroup) shouldBe 5\n    parseStream(\"{{<!>},{<!>},{<!>},{<a>}},\".toStream).count(_ == StartGroup) shouldBe 2\n\n  }\n\n  test(\"can calculate the group score\") {\n\n    scoreGroups(parseStream(\"{},\".toStream)) shouldBe 1\n    scoreGroups(parseStream(\"{{{}}},\".toStream)) shouldBe 6\n    scoreGroups(parseStream(\"{{},{}},\".toStream)) shouldBe 5\n    scoreGroups(parseStream(\"{{{},{},{{}}}},\".toStream)) shouldBe 16\n    scoreGroups(parseStream(\"{<a>,<a>,<a>,<a>},\".toStream)) shouldBe 1\n    scoreGroups(parseStream(\"{{<ab>},{<ab>},{<ab>},{<ab>}},\".toStream)) shouldBe 9\n    scoreGroups(parseStream(\"{{<!!>},{<!!>},{<!!>},{<!!>}},\".toStream)) shouldBe 9\n    scoreGroups(parseStream(\"{{<a!>},{<a!>},{<a!>},{<ab>}},\".toStream)) shouldBe 3\n\n  }\n}\n// defined class Day9Part1Test\n\n(new Day9Part1Test).execute()\n// Day9Part1Test:\n// - can parse stream\n// - can calculate the group score\n\n\nWith those passing, I can get the score for the full puzzle input.\n\nimport scala.io.Source\n// import scala.io.Source\n\ndef input = Source.fromResource(\"day9input.txt\").toStream\n// input: scala.collection.immutable.Stream[Char]\n\nscoreGroups(parseStream(input))\n// res1: Int = 23588\n\n\nPart 2\nFor this I needed to analyse the garbage instead of the groups. You may have\nnoted the comment about StartGarbage not existing when I wrote part 1. This was\nbecause there was no need to distinguish if we'd just read the opening < of a\ngarbage sequence, and the rest of the sequence. Part two however asked for just\nthat. So I refactored the states to distinguish start from in, and the rest was\njust counting.\n\ndef countGarbageChars(states: Stream[State]): Int =\n  states.count(_ == InGarbage)\n// countGarbageChars: (states: Stream[Day9.State])Int\n\n\nThe parsing tests still work, so the refactor had been completed correctly.\nReworking the tests for part 2 gives the following.\n\nclass Day9Part2Test extends FunSuite with Matchers {\n  test(\"can count garbage chars\") {\n    countGarbageChars(parseStream(\"<>,\".toStream)) shouldBe 0\n    countGarbageChars(parseStream(\"<random characters>,\".toStream)) shouldBe 17\n    countGarbageChars(parseStream(\"<<<<>,\".toStream)) shouldBe 3\n    countGarbageChars(parseStream(\"<{!>}>,\".toStream)) shouldBe 2\n    countGarbageChars(parseStream(\"<!!>,\".toStream)) shouldBe 0\n    countGarbageChars(parseStream(\"<!!!>>,\".toStream)) shouldBe 0\n    countGarbageChars(parseStream(\"<{o\\\"i!a,<{i<a>,\".toStream)) shouldBe 10\n    countGarbageChars(parseStream(\"{{<!!>},{<!!>},{<!!>},{<!!>}},\".toStream)) shouldBe 0\n    countGarbageChars(parseStream(\"{{<a!>},{<a!>},{<a!>},{<ab>}},\".toStream)) shouldBe 17\n  }\n}\n// defined class Day9Part2Test\n\n(new Day9Part2Test).execute()\n// Day9Part2Test:\n// - can count garbage chars\n\n\nThis can then be applied to the puzzle input\n\ncountGarbageChars(parseStream(input))\n// res3: Int = 10045","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-13.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-16T01:13:02.000Z","updated_at":"2017-12-16T05:00:00.000Z","published_at":"2017-12-16T05:00:00.000Z","custom_excerpt":"Advent of Code - Day 9","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a35a28a9c9605113d0a49a4","uuid":"a96c50db-0e77-4e78-bfe6-3825e8fbba17","title":"Knot Hash","slug":"aoc-2017-day-10-knot-hash","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 10](http://adventofcode.com/2017/day/10)\\n\\n## Part 1\\n\\nThe first part of today's task is to implement a round of a convoluted hashing algorithm inspired by trying to represent the act of knotting a sequence of integers.\\n\\nMy code is mostly just following the recipe provided. It is in two parts as part two turns out to require re-running the algorithm multiple times, passing on some of the internal state. The second function is merely a wrapper round the implementation that formats the output correctly.\\n\\n```scala\\ndef hashRound(lengths: List[Int],\\n              hash: Vector[Int],\\n              position: Int = 0,\\n              skipSize: Int = 0): (Vector[Int], Int, Int) = {\\n  lengths match {\\n    case Nil => (hash, position, skipSize)\\n    case h :: t =>\\n      val newHash =\\n        if (position + h < hash.length) {\\n          val (pre, rest) = hash.splitAt(position)\\n          val (mid, post) = rest.splitAt(h)\\n\\n          pre ++ mid.reverse ++ post\\n        }\\n        else {\\n          val (rest, end) = hash.splitAt(position)\\n          val (start, mid) = rest.splitAt((position + h) % hash.length)\\n          val (rEnd, rStart) = (end ++ start).reverse.splitAt(end.length)\\n\\n          rStart ++ mid ++ rEnd\\n        }\\n\\n      hashRound(\\n        t,\\n        newHash,\\n        (position + h + skipSize) % hash.length,\\n        skipSize + 1\\n      )\\n  }\\n}\\n// hashRound: (lengths: List[Int], hash: Vector[Int], position: Int, skipSize: Int)(Vector[Int], Int, Int)\\n\\ndef hash(lengths: List[Int],\\n         listSize: Int,\\n         position: Int = 0,\\n         skipSize: Int = 0): Vector[Int] =\\n  hashRound(lengths, Vector.range(0, listSize))._1\\n// hash: (lengths: List[Int], listSize: Int, position: Int, skipSize: Int)Vector[Int]\\n``` \\n\\nI could have used a single formula to calculate the new position using modulus calculations to treat is at a continuous list, but it would have been much harder to understand what it was doing if I need to revisit this code.\\n\\nThere was only one example, but since it is recursive I can use the sub-steps to add in some extra test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day10Part1Test extends FunSuite with Matchers {\\n  test(\\\"can hash sequence\\\") {\\n    hash(List(), 5) shouldBe Vector(0, 1, 2, 3, 4)\\n    hash(List(3), 5) shouldBe Vector(2, 1, 0, 3, 4)\\n    hash(List(3, 4), 5) shouldBe Vector(4, 3, 0, 1, 2)\\n    hash(List(3, 4, 1), 5) shouldBe Vector(4, 3, 0, 1, 2)\\n    hash(List(3, 4, 1, 5), 5) shouldBe Vector(3, 4, 2, 1, 0)\\n  }\\n}\\n// defined class Day10Part1Test\\n\\n(new Day10Part1Test).execute()\\n// Day10Part1Test:\\n// - can hash sequence\\n```\\n\\nThe input can now be hashed, and the solution required was the first two values multiplied together.\\n\\n```scala\\nval input = \\\"197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63\\\"\\n// input: String = 197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63\\n\\nval output = hash(input.split(\\\",\\\").map(_.toInt).toList, 256)\\n// output: Vector[Int] = Vector(158, 254, 196, 195, 194, 193, 192, 191, 190, 189, 188, 151, 152, 153, 154, 155, 156, 157, 247, 246, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 64, 63, 62, 61, 60, 59, 54, 56, 55, 57, 58, 53, 52, 51, 50, 49, 20, 21, 22, 23, 201, 38, 3...\\n\\noutput(0) * output(1)\\n// res1: Int = 40132\\n```\\n## Part 2\\n\\nThis is quite an extension on the above, and make the output look more like a hash, even if that is just because it is more efficient to display binary data as hexadecimal characters so by their nature of having no inherent structure themselves, hexadecimal strings is the default output.\\n\\nWhilst a lot more work is done by the computer, the actual task is still just following a recipe\\n\\n```scala\\ndef knotHash(input: String, listSize: Int = 256): String = {\\n  val lengths = input.toList.map(_.toInt) ++ List(17, 31, 73, 47, 23)\\n  val (sparseHash, _, _) =\\n    (0 until 64)\\n      .foldLeft((Vector.range(0, listSize), 0, 0)) {\\n        case ((h, p, s), _) => hashRound(lengths, h, p, s)\\n      }\\n\\n  sparseHash\\n    .grouped(16)\\n    .map(_.reduce(_ ^ _))\\n    .map(\\\"%02x\\\".format(_))\\n    .mkString\\n}\\n// knotHash: (input: String, listSize: Int)String\\n```\\n\\nWith this part having many more steps a walk-through isn't provided. There are however a few test cases.\\n\\n```scala\\nclass Day10Part2Test extends FunSuite with Matchers {\\n  test(\\\"can run full knot hash\\\")\\n  {\\n    knotHash(\\\"\\\") shouldBe \\\"a2582a3a0e66e6e86e3812dcb672a272\\\"\\n    knotHash(\\\"AoC 2017\\\") shouldBe \\\"33efeb34ea91902bb2f59c9920caa6cd\\\"\\n    knotHash(\\\"1,2,3\\\") shouldBe \\\"3efbe78a8d82f29979031a4aa0b16a9d\\\"\\n    knotHash(\\\"1,2,4\\\") shouldBe \\\"63960835bcdc130f0b66d7ff4f6a5a8e\\\"\\n  }\\n}\\n// defined class Day10Part2Test\\n\\n(new Day10Part2Test).execute()\\n// Day10Part2Test:\\n// - can run full knot hash\\n```\\n\\nThe input can now be hashed, giving me my second solution\\n\\n```scala\\nknotHash(input)\\n// res3: String = 35b028fe2c958793f7d5a61d07a008c8\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/10\">Advent of Code 2017 - Day 10</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>The first part of today's task is to implement a round of a convoluted hashing algorithm inspired by trying to represent the act of knotting a sequence of integers.</p>\n<p>My code is mostly just following the recipe provided. It is in two parts as part two turns out to require re-running the algorithm multiple times, passing on some of the internal state. The second function is merely a wrapper round the implementation that formats the output correctly.</p>\n<pre><code class=\"language-scala\">def hashRound(lengths: List[Int],\n              hash: Vector[Int],\n              position: Int = 0,\n              skipSize: Int = 0): (Vector[Int], Int, Int) = {\n  lengths match {\n    case Nil =&gt; (hash, position, skipSize)\n    case h :: t =&gt;\n      val newHash =\n        if (position + h &lt; hash.length) {\n          val (pre, rest) = hash.splitAt(position)\n          val (mid, post) = rest.splitAt(h)\n\n          pre ++ mid.reverse ++ post\n        }\n        else {\n          val (rest, end) = hash.splitAt(position)\n          val (start, mid) = rest.splitAt((position + h) % hash.length)\n          val (rEnd, rStart) = (end ++ start).reverse.splitAt(end.length)\n\n          rStart ++ mid ++ rEnd\n        }\n\n      hashRound(\n        t,\n        newHash,\n        (position + h + skipSize) % hash.length,\n        skipSize + 1\n      )\n  }\n}\n// hashRound: (lengths: List[Int], hash: Vector[Int], position: Int, skipSize: Int)(Vector[Int], Int, Int)\n\ndef hash(lengths: List[Int],\n         listSize: Int,\n         position: Int = 0,\n         skipSize: Int = 0): Vector[Int] =\n  hashRound(lengths, Vector.range(0, listSize))._1\n// hash: (lengths: List[Int], listSize: Int, position: Int, skipSize: Int)Vector[Int]\n</code></pre>\n<p>I could have used a single formula to calculate the new position using modulus calculations to treat is at a continuous list, but it would have been much harder to understand what it was doing if I need to revisit this code.</p>\n<p>There was only one example, but since it is recursive I can use the sub-steps to add in some extra test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day10Part1Test extends FunSuite with Matchers {\n  test(&quot;can hash sequence&quot;) {\n    hash(List(), 5) shouldBe Vector(0, 1, 2, 3, 4)\n    hash(List(3), 5) shouldBe Vector(2, 1, 0, 3, 4)\n    hash(List(3, 4), 5) shouldBe Vector(4, 3, 0, 1, 2)\n    hash(List(3, 4, 1), 5) shouldBe Vector(4, 3, 0, 1, 2)\n    hash(List(3, 4, 1, 5), 5) shouldBe Vector(3, 4, 2, 1, 0)\n  }\n}\n// defined class Day10Part1Test\n\n(new Day10Part1Test).execute()\n// Day10Part1Test:\n// - can hash sequence\n</code></pre>\n<p>The input can now be hashed, and the solution required was the first two values multiplied together.</p>\n<pre><code class=\"language-scala\">val input = &quot;197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63&quot;\n// input: String = 197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63\n\nval output = hash(input.split(&quot;,&quot;).map(_.toInt).toList, 256)\n// output: Vector[Int] = Vector(158, 254, 196, 195, 194, 193, 192, 191, 190, 189, 188, 151, 152, 153, 154, 155, 156, 157, 247, 246, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 64, 63, 62, 61, 60, 59, 54, 56, 55, 57, 58, 53, 52, 51, 50, 49, 20, 21, 22, 23, 201, 38, 3...\n\noutput(0) * output(1)\n// res1: Int = 40132\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>This is quite an extension on the above, and make the output look more like a hash, even if that is just because it is more efficient to display binary data as hexadecimal characters so by their nature of having no inherent structure themselves, hexadecimal strings is the default output.</p>\n<p>Whilst a lot more work is done by the computer, the actual task is still just following a recipe</p>\n<pre><code class=\"language-scala\">def knotHash(input: String, listSize: Int = 256): String = {\n  val lengths = input.toList.map(_.toInt) ++ List(17, 31, 73, 47, 23)\n  val (sparseHash, _, _) =\n    (0 until 64)\n      .foldLeft((Vector.range(0, listSize), 0, 0)) {\n        case ((h, p, s), _) =&gt; hashRound(lengths, h, p, s)\n      }\n\n  sparseHash\n    .grouped(16)\n    .map(_.reduce(_ ^ _))\n    .map(&quot;%02x&quot;.format(_))\n    .mkString\n}\n// knotHash: (input: String, listSize: Int)String\n</code></pre>\n<p>With this part having many more steps a walk-through isn't provided. There are however a few test cases.</p>\n<pre><code class=\"language-scala\">class Day10Part2Test extends FunSuite with Matchers {\n  test(&quot;can run full knot hash&quot;)\n  {\n    knotHash(&quot;&quot;) shouldBe &quot;a2582a3a0e66e6e86e3812dcb672a272&quot;\n    knotHash(&quot;AoC 2017&quot;) shouldBe &quot;33efeb34ea91902bb2f59c9920caa6cd&quot;\n    knotHash(&quot;1,2,3&quot;) shouldBe &quot;3efbe78a8d82f29979031a4aa0b16a9d&quot;\n    knotHash(&quot;1,2,4&quot;) shouldBe &quot;63960835bcdc130f0b66d7ff4f6a5a8e&quot;\n  }\n}\n// defined class Day10Part2Test\n\n(new Day10Part2Test).execute()\n// Day10Part2Test:\n// - can run full knot hash\n</code></pre>\n<p>The input can now be hashed, giving me my second solution</p>\n<pre><code class=\"language-scala\">knotHash(input)\n// res3: String = 35b028fe2c958793f7d5a61d07a008c8\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a35a28a9c9605113d0a49a4","plaintext":"A solution for Advent of Code 2017 - Day 10\n[http://adventofcode.com/2017/day/10]\n\nPart 1\nThe first part of today's task is to implement a round of a convoluted hashing\nalgorithm inspired by trying to represent the act of knotting a sequence of\nintegers.\n\nMy code is mostly just following the recipe provided. It is in two parts as part\ntwo turns out to require re-running the algorithm multiple times, passing on\nsome of the internal state. The second function is merely a wrapper round the\nimplementation that formats the output correctly.\n\ndef hashRound(lengths: List[Int],\n              hash: Vector[Int],\n              position: Int = 0,\n              skipSize: Int = 0): (Vector[Int], Int, Int) = {\n  lengths match {\n    case Nil => (hash, position, skipSize)\n    case h :: t =>\n      val newHash =\n        if (position + h < hash.length) {\n          val (pre, rest) = hash.splitAt(position)\n          val (mid, post) = rest.splitAt(h)\n\n          pre ++ mid.reverse ++ post\n        }\n        else {\n          val (rest, end) = hash.splitAt(position)\n          val (start, mid) = rest.splitAt((position + h) % hash.length)\n          val (rEnd, rStart) = (end ++ start).reverse.splitAt(end.length)\n\n          rStart ++ mid ++ rEnd\n        }\n\n      hashRound(\n        t,\n        newHash,\n        (position + h + skipSize) % hash.length,\n        skipSize + 1\n      )\n  }\n}\n// hashRound: (lengths: List[Int], hash: Vector[Int], position: Int, skipSize: Int)(Vector[Int], Int, Int)\n\ndef hash(lengths: List[Int],\n         listSize: Int,\n         position: Int = 0,\n         skipSize: Int = 0): Vector[Int] =\n  hashRound(lengths, Vector.range(0, listSize))._1\n// hash: (lengths: List[Int], listSize: Int, position: Int, skipSize: Int)Vector[Int]\n\n\nI could have used a single formula to calculate the new position using modulus\ncalculations to treat is at a continuous list, but it would have been much\nharder to understand what it was doing if I need to revisit this code.\n\nThere was only one example, but since it is recursive I can use the sub-steps to\nadd in some extra test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day10Part1Test extends FunSuite with Matchers {\n  test(\"can hash sequence\") {\n    hash(List(), 5) shouldBe Vector(0, 1, 2, 3, 4)\n    hash(List(3), 5) shouldBe Vector(2, 1, 0, 3, 4)\n    hash(List(3, 4), 5) shouldBe Vector(4, 3, 0, 1, 2)\n    hash(List(3, 4, 1), 5) shouldBe Vector(4, 3, 0, 1, 2)\n    hash(List(3, 4, 1, 5), 5) shouldBe Vector(3, 4, 2, 1, 0)\n  }\n}\n// defined class Day10Part1Test\n\n(new Day10Part1Test).execute()\n// Day10Part1Test:\n// - can hash sequence\n\n\nThe input can now be hashed, and the solution required was the first two values\nmultiplied together.\n\nval input = \"197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63\"\n// input: String = 197,97,204,108,1,29,5,71,0,50,2,255,248,78,254,63\n\nval output = hash(input.split(\",\").map(_.toInt).toList, 256)\n// output: Vector[Int] = Vector(158, 254, 196, 195, 194, 193, 192, 191, 190, 189, 188, 151, 152, 153, 154, 155, 156, 157, 247, 246, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 64, 63, 62, 61, 60, 59, 54, 56, 55, 57, 58, 53, 52, 51, 50, 49, 20, 21, 22, 23, 201, 38, 3...\n\noutput(0) * output(1)\n// res1: Int = 40132\n\n\nPart 2\nThis is quite an extension on the above, and make the output look more like a\nhash, even if that is just because it is more efficient to display binary data\nas hexadecimal characters so by their nature of having no inherent structure\nthemselves, hexadecimal strings is the default output.\n\nWhilst a lot more work is done by the computer, the actual task is still just\nfollowing a recipe\n\ndef knotHash(input: String, listSize: Int = 256): String = {\n  val lengths = input.toList.map(_.toInt) ++ List(17, 31, 73, 47, 23)\n  val (sparseHash, _, _) =\n    (0 until 64)\n      .foldLeft((Vector.range(0, listSize), 0, 0)) {\n        case ((h, p, s), _) => hashRound(lengths, h, p, s)\n      }\n\n  sparseHash\n    .grouped(16)\n    .map(_.reduce(_ ^ _))\n    .map(\"%02x\".format(_))\n    .mkString\n}\n// knotHash: (input: String, listSize: Int)String\n\n\nWith this part having many more steps a walk-through isn't provided. There are\nhowever a few test cases.\n\nclass Day10Part2Test extends FunSuite with Matchers {\n  test(\"can run full knot hash\")\n  {\n    knotHash(\"\") shouldBe \"a2582a3a0e66e6e86e3812dcb672a272\"\n    knotHash(\"AoC 2017\") shouldBe \"33efeb34ea91902bb2f59c9920caa6cd\"\n    knotHash(\"1,2,3\") shouldBe \"3efbe78a8d82f29979031a4aa0b16a9d\"\n    knotHash(\"1,2,4\") shouldBe \"63960835bcdc130f0b66d7ff4f6a5a8e\"\n  }\n}\n// defined class Day10Part2Test\n\n(new Day10Part2Test).execute()\n// Day10Part2Test:\n// - can run full knot hash\n\n\nThe input can now be hashed, giving me my second solution\n\nknotHash(input)\n// res3: String = 35b028fe2c958793f7d5a61d07a008c8","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-14.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-16T22:47:38.000Z","updated_at":"2017-12-17T05:00:00.000Z","published_at":"2017-12-17T05:00:00.000Z","custom_excerpt":"Advent of Code - Day 10","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a39a9969c9605113d0a49b3","uuid":"323c19e6-e99c-41e9-80ec-4fad21297290","title":"Digital Plumber","slug":"aoc-2017-day-12-digital-plumber","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 12](http://adventofcode.com/2017/day/12)\\n\\n## Part 1\\n\\nToday's challenge is essentially a clustering problem. Before I can solve it, I'll need the puzzle input in a useful format. I pondered processing the input a line at a time, but it seemed I would get a simpler implementation from 'walking' around the graph. To do this I need to look up nodes by index, so parsing the whole file into a Vector seemed more suitable.\\n\\n```scala\\nimport scala.collection.BitSet\\n// import scala.collection.BitSet\\n\\nval LineMatcher = \\\"^\\\\\\\\d+ <-> ((?:\\\\\\\\d+(?:, )?)+)$\\\".r\\n// LineMatcher: scala.util.matching.Regex = ^\\\\d+ <-> ((?:\\\\d+(?:, )?)+)$\\n\\ndef parseInput(lines: TraversableOnce[String]): Vector[Set[Int]] =\\n  lines.toVector.collect {\\n    case LineMatcher(edges) => edges.split(\\\", \\\").map(_.toInt).toSet\\n  }\\n// parseInput: (lines: TraversableOnce[String])Vector[Set[Int]]\\n```\\n\\nI now need to wander around the graph finding all the connected nodes starting with element 0. The edges being undirected and both nodes having the information about the edge to other one means I can just keep adding all a nodes children to my list to check, and discard any I've seen before. I can use a Set to keep track of visited nodes and when I have no more to check, the size of the set is also the solution to the puzzle.\\n\\n```scala\\ndef clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\\n    case Nil => matches\\n    case e +: es if matches.contains(e) => iter(es, matches)\\n    case e +: es => iter(es ++ edges(e), matches + e)\\n  }\\n\\n  iter(edges(root).toSeq, BitSet(root))\\n}\\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\\n```\\n\\nFor testing there was only one sample in the puzzle description. This was simple\\nto tweak into a set of test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day12Part1Test extends FunSuite with Matchers {\\n  test(\\\"Can parse input\\\") {\\n    parseInput(\\n      \\\"\\\"\\\"0 <-> 2\\n        |1 <-> 1\\n        |2 <-> 0, 3, 4\\n        |3 <-> 2, 4\\n        |4 <-> 2, 3, 6\\n        |5 <-> 6\\n        |6 <-> 4, 5\\\"\\\"\\\".stripMargin.lines\\n    ) shouldBe Vector(\\n      Set(2),\\n      Set(1),\\n      Set(0, 3, 4),\\n      Set(2, 4),\\n      Set(2, 3, 6),\\n      Set(6),\\n      Set(4, 5)\\n    )\\n  }\\n\\n  test(\\\"Can find size of cluster\\\") {\\n    clusterWith(\\n      0,\\n      Vector(\\n        Set(2),\\n        Set(1),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3, 6),\\n        Set(6),\\n        Set(4, 5)\\n      )\\n    ).size shouldBe 6\\n\\n    clusterWith(\\n      0,\\n      Vector(\\n        Set(2),\\n        Set(1),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(5)\\n      )\\n    ).size shouldBe 4\\n\\n    clusterWith(\\n      0,\\n      Vector(\\n        Set(2),\\n        Set(6),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(1, 5)\\n      )\\n    ).size shouldBe 4\\n\\n    clusterWith(\\n      0,\\n      Vector(\\n        Set(2),\\n        Set(6),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(1, 5)\\n      )\\n    ).size shouldBe 4\\n\\n    clusterWith(\\n      1,\\n      Vector(\\n        Set(2),\\n        Set(6),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(1, 5)\\n      )\\n    ).size shouldBe 3\\n  }\\n}\\n// defined class Day12Part1Test\\n\\n(new Day12Part1Test).execute()\\n// Day12Part1Test:\\n// - Can parse input\\n// - Can find size of cluster\\n```\\n\\nI originally had the start node and the returning of the size of the set built into clusterWith, but extracted it when I needed the full set for any node for part 2.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\ndef input = parseInput(Source.fromResource(\\\"day12input.txt\\\").getLines())\\n// input: Vector[Set[Int]]\\n\\nclusterWith(0, input).size\\n// res1: Int = 145\\n```\\n\\n## Part 2\\n\\nGiven that I had part 1 written, the easiest solution would be to reuse its feature of building a set of connected nodes. As I go through the nodes in order if it's in a cluster I've already seen I can ignore it and continue. If instead it is new, use part 1 to find the rest of its cluster and add those to the list of covered nodes. If increment a counter each time I do this I then have the puzzle solution.\\n\\n```scala\\ndef countClusters(edges: Vector[Set[Int]]): Int = {\\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\\n    case Nil => count\\n    case e +: es if matches.contains(e) => iter(es, matches, count)\\n    case e +: es => iter(es, matches ++ clusterWith(e, edges), count + 1)\\n  }\\n\\n  iter(edges.indices, BitSet.empty, 0)\\n}\\n// countClusters: (edges: Vector[Set[Int]])Int\\n```\\nThe example from part one is not amazing for testing this part. The nodes are all connected except one, which is only connected to itself. I built a few with multiple multi node clusters and also some simple base cases.\\n\\n```scala\\nclass Day12Part2Test extends FunSuite with Matchers {\\n  test(\\\"Can count clusters\\\") {\\n    countClusters(\\n      Vector(\\n        Set(2),\\n        Set(1),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3, 6),\\n        Set(6),\\n        Set(4, 5)\\n      )\\n    ) shouldBe 2\\n  \\n    countClusters(\\n      Vector(\\n        Set(0)\\n      )\\n    ) shouldBe 1\\n  \\n    countClusters(\\n      Vector(\\n        Set(1),\\n        Set(0)\\n      )\\n    ) shouldBe 1\\n  \\n    countClusters(\\n      Vector(\\n        Set(0),\\n        Set(1)\\n      )\\n    ) shouldBe 2\\n  \\n    countClusters(\\n      Vector(\\n        Set(1, 2),\\n        Set(0),\\n        Set(0)\\n      )\\n    ) shouldBe 1\\n  \\n    countClusters(\\n      Vector(\\n        Set(0),\\n        Set(1),\\n        Set(2)\\n      )\\n    ) shouldBe 3\\n  \\n    countClusters(\\n      Vector(\\n        Set(2),\\n        Set(6),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(1, 5)\\n      )\\n    ) shouldBe 2\\n  \\n    countClusters(\\n      Vector(\\n        Set(2),\\n        Set(1),\\n        Set(0, 3, 4),\\n        Set(2, 4),\\n        Set(2, 3),\\n        Set(6),\\n        Set(5)\\n      )\\n    ) shouldBe 3\\n  \\n    countClusters(\\n      Vector(\\n        Set(2),\\n        Set(3),\\n        Set(0, 4),\\n        Set(1),\\n        Set(2),\\n        Set(6),\\n        Set(5)\\n      )\\n    ) shouldBe 3\\n  \\n  }\\n}\\n// defined class Day12Part2Test\\n\\n(new Day12Part2Test).execute()\\n// Day12Part2Test:\\n// - Can count clusters\\n```\\n\\nAnd this can now process the puzzle input.\\n\\n```scala\\ncountClusters(input)\\n// res3: Int = 207\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/12\">Advent of Code 2017 - Day 12</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today's challenge is essentially a clustering problem. Before I can solve it, I'll need the puzzle input in a useful format. I pondered processing the input a line at a time, but it seemed I would get a simpler implementation from 'walking' around the graph. To do this I need to look up nodes by index, so parsing the whole file into a Vector seemed more suitable.</p>\n<pre><code class=\"language-scala\">import scala.collection.BitSet\n// import scala.collection.BitSet\n\nval LineMatcher = &quot;^\\\\d+ &lt;-&gt; ((?:\\\\d+(?:, )?)+)$&quot;.r\n// LineMatcher: scala.util.matching.Regex = ^\\d+ &lt;-&gt; ((?:\\d+(?:, )?)+)$\n\ndef parseInput(lines: TraversableOnce[String]): Vector[Set[Int]] =\n  lines.toVector.collect {\n    case LineMatcher(edges) =&gt; edges.split(&quot;, &quot;).map(_.toInt).toSet\n  }\n// parseInput: (lines: TraversableOnce[String])Vector[Set[Int]]\n</code></pre>\n<p>I now need to wander around the graph finding all the connected nodes starting with element 0. The edges being undirected and both nodes having the information about the edge to other one means I can just keep adding all a nodes children to my list to check, and discard any I've seen before. I can use a Set to keep track of visited nodes and when I have no more to check, the size of the set is also the solution to the puzzle.</p>\n<pre><code class=\"language-scala\">def clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\n    case Nil =&gt; matches\n    case e +: es if matches.contains(e) =&gt; iter(es, matches)\n    case e +: es =&gt; iter(es ++ edges(e), matches + e)\n  }\n\n  iter(edges(root).toSeq, BitSet(root))\n}\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\n</code></pre>\n<p>For testing there was only one sample in the puzzle description. This was simple<br>\nto tweak into a set of test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day12Part1Test extends FunSuite with Matchers {\n  test(&quot;Can parse input&quot;) {\n    parseInput(\n      &quot;&quot;&quot;0 &lt;-&gt; 2\n        |1 &lt;-&gt; 1\n        |2 &lt;-&gt; 0, 3, 4\n        |3 &lt;-&gt; 2, 4\n        |4 &lt;-&gt; 2, 3, 6\n        |5 &lt;-&gt; 6\n        |6 &lt;-&gt; 4, 5&quot;&quot;&quot;.stripMargin.lines\n    ) shouldBe Vector(\n      Set(2),\n      Set(1),\n      Set(0, 3, 4),\n      Set(2, 4),\n      Set(2, 3, 6),\n      Set(6),\n      Set(4, 5)\n    )\n  }\n\n  test(&quot;Can find size of cluster&quot;) {\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3, 6),\n        Set(6),\n        Set(4, 5)\n      )\n    ).size shouldBe 6\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      1,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 3\n  }\n}\n// defined class Day12Part1Test\n\n(new Day12Part1Test).execute()\n// Day12Part1Test:\n// - Can parse input\n// - Can find size of cluster\n</code></pre>\n<p>I originally had the start node and the returning of the size of the set built into clusterWith, but extracted it when I needed the full set for any node for part 2.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\ndef input = parseInput(Source.fromResource(&quot;day12input.txt&quot;).getLines())\n// input: Vector[Set[Int]]\n\nclusterWith(0, input).size\n// res1: Int = 145\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Given that I had part 1 written, the easiest solution would be to reuse its feature of building a set of connected nodes. As I go through the nodes in order if it's in a cluster I've already seen I can ignore it and continue. If instead it is new, use part 1 to find the rest of its cluster and add those to the list of covered nodes. If increment a counter each time I do this I then have the puzzle solution.</p>\n<pre><code class=\"language-scala\">def countClusters(edges: Vector[Set[Int]]): Int = {\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\n    case Nil =&gt; count\n    case e +: es if matches.contains(e) =&gt; iter(es, matches, count)\n    case e +: es =&gt; iter(es, matches ++ clusterWith(e, edges), count + 1)\n  }\n\n  iter(edges.indices, BitSet.empty, 0)\n}\n// countClusters: (edges: Vector[Set[Int]])Int\n</code></pre>\n<p>The example from part one is not amazing for testing this part. The nodes are all connected except one, which is only connected to itself. I built a few with multiple multi node clusters and also some simple base cases.</p>\n<pre><code class=\"language-scala\">class Day12Part2Test extends FunSuite with Matchers {\n  test(&quot;Can count clusters&quot;) {\n    countClusters(\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3, 6),\n        Set(6),\n        Set(4, 5)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(1),\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(0),\n        Set(1)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(1, 2),\n        Set(0),\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(0),\n        Set(1),\n        Set(2)\n      )\n    ) shouldBe 3\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(5)\n      )\n    ) shouldBe 3\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(3),\n        Set(0, 4),\n        Set(1),\n        Set(2),\n        Set(6),\n        Set(5)\n      )\n    ) shouldBe 3\n  \n  }\n}\n// defined class Day12Part2Test\n\n(new Day12Part2Test).execute()\n// Day12Part2Test:\n// - Can count clusters\n</code></pre>\n<p>And this can now process the puzzle input.</p>\n<pre><code class=\"language-scala\">countClusters(input)\n// res3: Int = 207\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a39a9969c9605113d0a49b3","plaintext":"A solution for Advent of Code 2017 - Day 12\n[http://adventofcode.com/2017/day/12]\n\nPart 1\nToday's challenge is essentially a clustering problem. Before I can solve it,\nI'll need the puzzle input in a useful format. I pondered processing the input a\nline at a time, but it seemed I would get a simpler implementation from\n'walking' around the graph. To do this I need to look up nodes by index, so\nparsing the whole file into a Vector seemed more suitable.\n\nimport scala.collection.BitSet\n// import scala.collection.BitSet\n\nval LineMatcher = \"^\\\\d+ <-> ((?:\\\\d+(?:, )?)+)$\".r\n// LineMatcher: scala.util.matching.Regex = ^\\d+ <-> ((?:\\d+(?:, )?)+)$\n\ndef parseInput(lines: TraversableOnce[String]): Vector[Set[Int]] =\n  lines.toVector.collect {\n    case LineMatcher(edges) => edges.split(\", \").map(_.toInt).toSet\n  }\n// parseInput: (lines: TraversableOnce[String])Vector[Set[Int]]\n\n\nI now need to wander around the graph finding all the connected nodes starting\nwith element 0. The edges being undirected and both nodes having the information\nabout the edge to other one means I can just keep adding all a nodes children to\nmy list to check, and discard any I've seen before. I can use a Set to keep\ntrack of visited nodes and when I have no more to check, the size of the set is\nalso the solution to the puzzle.\n\ndef clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\n    case Nil => matches\n    case e +: es if matches.contains(e) => iter(es, matches)\n    case e +: es => iter(es ++ edges(e), matches + e)\n  }\n\n  iter(edges(root).toSeq, BitSet(root))\n}\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\n\n\nFor testing there was only one sample in the puzzle description. This was simple\nto tweak into a set of test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day12Part1Test extends FunSuite with Matchers {\n  test(\"Can parse input\") {\n    parseInput(\n      \"\"\"0 <-> 2\n        |1 <-> 1\n        |2 <-> 0, 3, 4\n        |3 <-> 2, 4\n        |4 <-> 2, 3, 6\n        |5 <-> 6\n        |6 <-> 4, 5\"\"\".stripMargin.lines\n    ) shouldBe Vector(\n      Set(2),\n      Set(1),\n      Set(0, 3, 4),\n      Set(2, 4),\n      Set(2, 3, 6),\n      Set(6),\n      Set(4, 5)\n    )\n  }\n\n  test(\"Can find size of cluster\") {\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3, 6),\n        Set(6),\n        Set(4, 5)\n      )\n    ).size shouldBe 6\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      0,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 4\n\n    clusterWith(\n      1,\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ).size shouldBe 3\n  }\n}\n// defined class Day12Part1Test\n\n(new Day12Part1Test).execute()\n// Day12Part1Test:\n// - Can parse input\n// - Can find size of cluster\n\n\nI originally had the start node and the returning of the size of the set built\ninto clusterWith, but extracted it when I needed the full set for any node for\npart 2.\n\nimport scala.io.Source\n// import scala.io.Source\n\ndef input = parseInput(Source.fromResource(\"day12input.txt\").getLines())\n// input: Vector[Set[Int]]\n\nclusterWith(0, input).size\n// res1: Int = 145\n\n\nPart 2\nGiven that I had part 1 written, the easiest solution would be to reuse its\nfeature of building a set of connected nodes. As I go through the nodes in order\nif it's in a cluster I've already seen I can ignore it and continue. If instead\nit is new, use part 1 to find the rest of its cluster and add those to the list\nof covered nodes. If increment a counter each time I do this I then have the\npuzzle solution.\n\ndef countClusters(edges: Vector[Set[Int]]): Int = {\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\n    case Nil => count\n    case e +: es if matches.contains(e) => iter(es, matches, count)\n    case e +: es => iter(es, matches ++ clusterWith(e, edges), count + 1)\n  }\n\n  iter(edges.indices, BitSet.empty, 0)\n}\n// countClusters: (edges: Vector[Set[Int]])Int\n\n\nThe example from part one is not amazing for testing this part. The nodes are\nall connected except one, which is only connected to itself. I built a few with\nmultiple multi node clusters and also some simple base cases.\n\nclass Day12Part2Test extends FunSuite with Matchers {\n  test(\"Can count clusters\") {\n    countClusters(\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3, 6),\n        Set(6),\n        Set(4, 5)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(1),\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(0),\n        Set(1)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(1, 2),\n        Set(0),\n        Set(0)\n      )\n    ) shouldBe 1\n  \n    countClusters(\n      Vector(\n        Set(0),\n        Set(1),\n        Set(2)\n      )\n    ) shouldBe 3\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(6),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(1, 5)\n      )\n    ) shouldBe 2\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(1),\n        Set(0, 3, 4),\n        Set(2, 4),\n        Set(2, 3),\n        Set(6),\n        Set(5)\n      )\n    ) shouldBe 3\n  \n    countClusters(\n      Vector(\n        Set(2),\n        Set(3),\n        Set(0, 4),\n        Set(1),\n        Set(2),\n        Set(6),\n        Set(5)\n      )\n    ) shouldBe 3\n  \n  }\n}\n// defined class Day12Part2Test\n\n(new Day12Part2Test).execute()\n// Day12Part2Test:\n// - Can count clusters\n\n\nAnd this can now process the puzzle input.\n\ncountClusters(input)\n// res3: Int = 207","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-15.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-20T00:06:46.000Z","updated_at":"2017-12-20T00:38:04.000Z","published_at":"2017-12-19T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 12","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a39b0549c9605113d0a49ba","uuid":"9a816ec8-9dff-44e7-890f-d02e8c55a5ab","title":"Packet Scanners","slug":"aoc-2017-day-13-packet-scanners","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 13](http://adventofcode.com/2017/day/13)\\n\\n## Part 1\\n\\nThe input is fairly easy to get into a useful form. \\n\\n```scala\\ncase class Layer(depth: Int, range: Int)\\n// defined class Layer\\n\\nval LineMatcher = \\\"(\\\\\\\\d+): (\\\\\\\\d+)\\\".r\\n// LineMatcher: scala.util.matching.Regex = (\\\\d+): (\\\\d+)\\n\\ndef parseLines(lines: TraversableOnce[String]): Seq[Layer] =\\n  lines.toSeq.collect { case LineMatcher(d, r) => Layer(d.toInt, r.toInt) }\\n// parseLines: (lines: TraversableOnce[String])Seq[Layer]\\n```\\n\\nI briefly considered simulating the 'firewall', but I realised that each 'security scanner' will be at position 0 every `2 x Layer.range - 2` seconds. Since we will be at each layer at `Layer.depth` seconds, I can calculate if a bot will detect me with a single calculation for its layer. The full solution is easy to express as a recipe for the collections library.\\n\\n```scala\\ndef calcTripSeverity(layers: Seq[Layer]): Int = (\\n  layers\\n    .filter(l => l.depth % (2 * l.range - 2) == 0)\\n    .map(l => l.depth * l.range)\\n    .sum\\n)\\n// calcTripSeverity: (layers: Seq[Layer])Int\\n```\\n\\nThis can now be tested...\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day13Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"testParseLines\\\") {\\n    parseLines(\\n      \\\"\\\"\\\"0: 3\\n        |1: 2\\n        |4: 4\\n        |6: 4\\n      \\\"\\\"\\\".stripMargin.lines\\n    ) shouldBe Seq(\\n      Layer(0, 3),\\n      Layer(1, 2),\\n      Layer(4, 4),\\n      Layer(6, 4)\\n    )\\n  }\\n\\n  test(\\\"testCalcTripSeverity\\\") {\\n    calcTripSeverity(Seq(\\n      Layer(0, 3),\\n      Layer(1, 2),\\n      Layer(4, 4),\\n      Layer(6, 4)\\n    )) shouldBe 24\\n\\n    calcTripSeverity(Seq(\\n      Layer(0, 3),\\n      Layer(1, 2),\\n      Layer(4, 3),\\n      Layer(5, 7),\\n      Layer(6, 4)\\n    )) shouldBe 36\\n  }\\n}\\n// defined class Day13Part1Test\\n\\n(new Day13Part1Test).execute()\\n// Day13Part1Test:\\n// - testParseLines\\n// - testCalcTripSeverity\\n```\\n... and run.\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\ndef input = parseLines(Source.fromResource(\\\"day13input.txt\\\").getLines())\\n// input: Seq[Layer]\\n\\ncalcTripSeverity(input)\\n// res1: Int = 1900\\n```\\n\\n## Part 2\\n\\nThis required finding a safe time-slice to cross the 'firewall'. I initially tried to reuse part 1 a bit more in this, but was caught out by the scanner in layer 0 detecting me, even though it added 0 severity. In the end it was easier to write a new recipe with the same check.\\n\\n```scala\\ndef calcSafeTrip(layers: Seq[Layer]): Int = (\\n  Stream.from(0)\\n    .filter(offset =>\\n      layers.forall(l =>\\n        (l.depth + offset) % (2 * l.range - 2) != 0\\n      )\\n    )\\n    .head\\n  )\\n// calcSafeTrip: (layers: Seq[Layer])Int\\n```\\n\\nThis can then be tested with the example given\\n\\n```scala\\nclass Day13Part2Test extends FunSuite with Matchers {\\n  test(\\\"testCalcSafeTrip\\\") {\\n    calcSafeTrip(Seq(\\n      Layer(0, 3),\\n      Layer(1, 2),\\n      Layer(4, 4),\\n      Layer(6, 4)\\n    )) shouldBe 10\\n  }\\n}\\n// defined class Day13Part2Test\\n\\n(new Day13Part2Test).execute()\\n// Day13Part2Test:\\n// - testCalcSafeTrip\\n```\\n\\nThe code can now be run. Despite the large delay, the solution takes roughly 2 seconds to run both parts.\\n\\n```scala\\ncalcSafeTrip(input)\\n// res3: Int = 3966414\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/13\">Advent of Code 2017 - Day 13</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>The input is fairly easy to get into a useful form.</p>\n<pre><code class=\"language-scala\">case class Layer(depth: Int, range: Int)\n// defined class Layer\n\nval LineMatcher = &quot;(\\\\d+): (\\\\d+)&quot;.r\n// LineMatcher: scala.util.matching.Regex = (\\d+): (\\d+)\n\ndef parseLines(lines: TraversableOnce[String]): Seq[Layer] =\n  lines.toSeq.collect { case LineMatcher(d, r) =&gt; Layer(d.toInt, r.toInt) }\n// parseLines: (lines: TraversableOnce[String])Seq[Layer]\n</code></pre>\n<p>I briefly considered simulating the 'firewall', but I realised that each 'security scanner' will be at position 0 every <code>2 x Layer.range - 2</code> seconds. Since we will be at each layer at <code>Layer.depth</code> seconds, I can calculate if a bot will detect me with a single calculation for its layer. The full solution is easy to express as a recipe for the collections library.</p>\n<pre><code class=\"language-scala\">def calcTripSeverity(layers: Seq[Layer]): Int = (\n  layers\n    .filter(l =&gt; l.depth % (2 * l.range - 2) == 0)\n    .map(l =&gt; l.depth * l.range)\n    .sum\n)\n// calcTripSeverity: (layers: Seq[Layer])Int\n</code></pre>\n<p>This can now be tested...</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day13Part1Test extends FunSuite with Matchers {\n\n  test(&quot;testParseLines&quot;) {\n    parseLines(\n      &quot;&quot;&quot;0: 3\n        |1: 2\n        |4: 4\n        |6: 4\n      &quot;&quot;&quot;.stripMargin.lines\n    ) shouldBe Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )\n  }\n\n  test(&quot;testCalcTripSeverity&quot;) {\n    calcTripSeverity(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )) shouldBe 24\n\n    calcTripSeverity(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 3),\n      Layer(5, 7),\n      Layer(6, 4)\n    )) shouldBe 36\n  }\n}\n// defined class Day13Part1Test\n\n(new Day13Part1Test).execute()\n// Day13Part1Test:\n// - testParseLines\n// - testCalcTripSeverity\n</code></pre>\n<p>... and run.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\ndef input = parseLines(Source.fromResource(&quot;day13input.txt&quot;).getLines())\n// input: Seq[Layer]\n\ncalcTripSeverity(input)\n// res1: Int = 1900\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>This required finding a safe time-slice to cross the 'firewall'. I initially tried to reuse part 1 a bit more in this, but was caught out by the scanner in layer 0 detecting me, even though it added 0 severity. In the end it was easier to write a new recipe with the same check.</p>\n<pre><code class=\"language-scala\">def calcSafeTrip(layers: Seq[Layer]): Int = (\n  Stream.from(0)\n    .filter(offset =&gt;\n      layers.forall(l =&gt;\n        (l.depth + offset) % (2 * l.range - 2) != 0\n      )\n    )\n    .head\n  )\n// calcSafeTrip: (layers: Seq[Layer])Int\n</code></pre>\n<p>This can then be tested with the example given</p>\n<pre><code class=\"language-scala\">class Day13Part2Test extends FunSuite with Matchers {\n  test(&quot;testCalcSafeTrip&quot;) {\n    calcSafeTrip(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )) shouldBe 10\n  }\n}\n// defined class Day13Part2Test\n\n(new Day13Part2Test).execute()\n// Day13Part2Test:\n// - testCalcSafeTrip\n</code></pre>\n<p>The code can now be run. Despite the large delay, the solution takes roughly 2 seconds to run both parts.</p>\n<pre><code class=\"language-scala\">calcSafeTrip(input)\n// res3: Int = 3966414\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a39b0549c9605113d0a49ba","plaintext":"A solution for Advent of Code 2017 - Day 13\n[http://adventofcode.com/2017/day/13]\n\nPart 1\nThe input is fairly easy to get into a useful form.\n\ncase class Layer(depth: Int, range: Int)\n// defined class Layer\n\nval LineMatcher = \"(\\\\d+): (\\\\d+)\".r\n// LineMatcher: scala.util.matching.Regex = (\\d+): (\\d+)\n\ndef parseLines(lines: TraversableOnce[String]): Seq[Layer] =\n  lines.toSeq.collect { case LineMatcher(d, r) => Layer(d.toInt, r.toInt) }\n// parseLines: (lines: TraversableOnce[String])Seq[Layer]\n\n\nI briefly considered simulating the 'firewall', but I realised that each\n'security scanner' will be at position 0 every 2 x Layer.range - 2 seconds.\nSince we will be at each layer at Layer.depth seconds, I can calculate if a bot\nwill detect me with a single calculation for its layer. The full solution is\neasy to express as a recipe for the collections library.\n\ndef calcTripSeverity(layers: Seq[Layer]): Int = (\n  layers\n    .filter(l => l.depth % (2 * l.range - 2) == 0)\n    .map(l => l.depth * l.range)\n    .sum\n)\n// calcTripSeverity: (layers: Seq[Layer])Int\n\n\nThis can now be tested...\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day13Part1Test extends FunSuite with Matchers {\n\n  test(\"testParseLines\") {\n    parseLines(\n      \"\"\"0: 3\n        |1: 2\n        |4: 4\n        |6: 4\n      \"\"\".stripMargin.lines\n    ) shouldBe Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )\n  }\n\n  test(\"testCalcTripSeverity\") {\n    calcTripSeverity(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )) shouldBe 24\n\n    calcTripSeverity(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 3),\n      Layer(5, 7),\n      Layer(6, 4)\n    )) shouldBe 36\n  }\n}\n// defined class Day13Part1Test\n\n(new Day13Part1Test).execute()\n// Day13Part1Test:\n// - testParseLines\n// - testCalcTripSeverity\n\n\n... and run.\n\nimport scala.io.Source\n// import scala.io.Source\n\ndef input = parseLines(Source.fromResource(\"day13input.txt\").getLines())\n// input: Seq[Layer]\n\ncalcTripSeverity(input)\n// res1: Int = 1900\n\n\nPart 2\nThis required finding a safe time-slice to cross the 'firewall'. I initially\ntried to reuse part 1 a bit more in this, but was caught out by the scanner in\nlayer 0 detecting me, even though it added 0 severity. In the end it was easier\nto write a new recipe with the same check.\n\ndef calcSafeTrip(layers: Seq[Layer]): Int = (\n  Stream.from(0)\n    .filter(offset =>\n      layers.forall(l =>\n        (l.depth + offset) % (2 * l.range - 2) != 0\n      )\n    )\n    .head\n  )\n// calcSafeTrip: (layers: Seq[Layer])Int\n\n\nThis can then be tested with the example given\n\nclass Day13Part2Test extends FunSuite with Matchers {\n  test(\"testCalcSafeTrip\") {\n    calcSafeTrip(Seq(\n      Layer(0, 3),\n      Layer(1, 2),\n      Layer(4, 4),\n      Layer(6, 4)\n    )) shouldBe 10\n  }\n}\n// defined class Day13Part2Test\n\n(new Day13Part2Test).execute()\n// Day13Part2Test:\n// - testCalcSafeTrip\n\n\nThe code can now be run. Despite the large delay, the solution takes roughly 2\nseconds to run both parts.\n\ncalcSafeTrip(input)\n// res3: Int = 3966414","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-16.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-20T00:35:32.000Z","updated_at":"2017-12-20T05:00:00.000Z","published_at":"2017-12-20T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 13","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3a8a539c9605113d0a49c3","uuid":"a54fa025-b347-457a-b4a6-689fbc3ef73f","title":"Time Fact","slug":"time-fact","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"<blockquote id=\\\"fact\\\" cite=\\\"https://xkcd.com/1930/\\\">\\n    Hello\\n</blockquote>\\n<div class=\\\"post-full-footer-right\\\">\\n    <a id=\\\"load-fact\\\" class=\\\"author-card-button\\\" href=\\\"#\\\">Load a new fact</a>\\n</div>\\n\\n<p></p>\\n\\nTime facts are generated using the specification provided by [XKCD: Calendar Facts](https://xkcd.com/1930/)\\n\\n![XKCD 1930](https://imgs.xkcd.com/comics/calendar_facts.png)\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]],[1,\"p\",[]]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><blockquote id=\"fact\" cite=\"https://xkcd.com/1930/\">\n    Hello\n</blockquote>\n<div class=\"post-full-footer-right\">\n    <a id=\"load-fact\" class=\"author-card-button\" href=\"#\">Load a new fact</a>\n</div>\n<p></p>\n<p>Time facts are generated using the specification provided by <a href=\"https://xkcd.com/1930/\">XKCD: Calendar Facts</a></p>\n<p><img src=\"https://imgs.xkcd.com/comics/calendar_facts.png\" alt=\"XKCD 1930\" loading=\"lazy\"></p>\n<!--kg-card-end: markdown--><p></p>","comment_id":"5a3a8a539c9605113d0a49c3","plaintext":"> Hello\nLoad a new fact\n\nTime facts are generated using the specification provided by XKCD: Calendar\nFacts [https://xkcd.com/1930/]","feature_image":"__GHOST_URL__/content/images/2021/06/coding-2.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-20T16:05:39.000Z","updated_at":"2021-06-13T00:44:18.000Z","published_at":"2017-12-20T14:25:00.000Z","custom_excerpt":"Time facts generated using the specification provided by XKCD: Calendar Facts","codeinjection_head":"<style>\n    .gh-content #fact {\n        color: hsla(0,0%,100%,.75);\n    }\n</style>","codeinjection_foot":"<script>\n    const loadFact = () => {\n        const fact = document.getElementById('fact')\n        \n        fetch(\"https://blog.goblinoid.co.uk/api/time-fact\")\n            .then(res => res.json())\n            .then(res => fact.innerHTML = res.fact)\n    }\n    \n    window.onload = () => {\n        loadFact()\n        document.getElementById('load-fact')\n            .onclick = e => {e.preventDefault(); loadFact()}\n    }\n</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3b04e59c9605113d0a49c6","uuid":"6b4d90f3-3beb-4e24-ba66-04e477bdea53","title":"Disk Defragmentation","slug":"aoc-2017-day-14-disk-defragmentation","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 14](http://adventofcode.com/2017/day/14)\\n\\n## Part 1\\n\\nFor the first part we need to reuse the implementation for [day 10](https://blog.goblinoid.co.uk/aoc-2017-day-10-knot-hash/)\\n\\n```scala\\nimport Day10._\\n// import Day10._\\n```\\n\\nWith that available I can now use it to run the repeated hash on the input, convert it to a binary representation and count the bits that have been set.\\n\\n```scala\\ndef countBits(hexString: String): Int = (\\n  hexString\\n    .grouped(4).map(s => Integer.parseInt(s, 16).toBinaryString)\\n    .mkString(\\\"\\\")\\n    .count(_ == '1')\\n)\\n// countBits: (hexString: String)Int\\n\\ndef countUsed(key: String): Int = (\\n  (0 to 127)\\n    .map(i => Day10.knotHash(s\\\"$key-$i\\\"))\\n    .map(countBits)\\n    .sum\\n)\\n// countUsed: (key: String)Int\\n```\\n\\nCheck that it works:\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day14Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"testCountBits\\\") {\\n    countBits(\\\"0\\\") shouldBe 0\\n    countBits(\\\"1\\\") shouldBe 1\\n    countBits(\\\"e\\\") shouldBe 3\\n    countBits(\\\"f\\\") shouldBe 4\\n    countBits(\\\"ff\\\") shouldBe 8\\n    countBits(\\\"1248\\\") shouldBe 4\\n    countBits(\\\"137f\\\") shouldBe 10\\n    countBits(\\\"f0000000000000000000000000000001\\\") shouldBe 5\\n  }\\n\\n  test(\\\"testCountUsed\\\") {\\n    countUsed(\\\"flqrgnkx\\\") shouldBe 8108\\n  }\\n}\\n// defined class Day14Part1Test\\n\\n(new Day14Part1Test).execute()\\n// Day14Part1Test:\\n// - testCountBits\\n// - testCountUsed\\n```\\n\\nRun for the puzzle input:\\n\\n```scala\\ncountUsed(\\\"xlqgujun\\\")\\n// res1: Int = 8204\\n```\\n\\n## Part 2\\n\\nToday's theme seems to be code reuse. This one is slightly less specific but the challenge allows me to reuse the clustering from [day 12](https://blog.goblinoid.co.uk/aoc-2017-day-12-digital-plumber/) if I can munge the input into the same input. The only hiccup is that for day 12 it is assumed that the nodes are sequentially numbered, and have at least one connection. For this puzzle we want to ignore the 0 bits. I added a small change to the algorithm in so that a number of nodes can be excluded from the algorithm using a map, and build a mask of all the 0 bits as I transform the data into the expected `Vector[Set[Int]]` format.\\n\\n```scala\\nimport scala.collection.BitSet\\n// import scala.collection.BitSet\\n\\ndef drawBits(hexString: String): String = (\\n  hexString\\n    .grouped(4).map(s => Integer.parseInt(s, 16).toBinaryString.formatted(\\\"%16s\\\").replaceAll(\\\" \\\", \\\"0\\\"))\\n    .mkString(\\\"\\\")\\n)\\n// drawBits: (hexString: String)String\\n\\ndef clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\\n    case Nil => matches\\n    case e +: es if matches.contains(e) => iter(es, matches)\\n    case e +: es => iter(es ++ edges(e), matches + e)\\n  }\\n  \\n  iter(edges(root).toSeq, BitSet(root))\\n}\\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\\n\\ndef countClusters(edges: Vector[Set[Int]], mask: Vector[Boolean]): Int = {\\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\\n    case Nil => count\\n    case e +: es if matches.contains(e) => iter(es, matches, count)\\n    case e +: es => iter(es, matches ++ clusterWith(e, edges), count + 1)\\n  }\\n  \\n  iter(edges.indices.filter(e => mask(e)), BitSet.empty, 0)\\n}\\n// countClusters: (edges: Vector[Set[Int]], mask: Vector[Boolean])Int\\n\\ndef countRegions(key: String): Int = {\\n  val matrix = Vector.iterate(0, 128)(_ + 1).map(i => drawBits(Day10.knotHash(s\\\"$key-$i\\\")))\\n  val edgesWithMask: Vector[(Set[Int], Boolean)] = (for(x <- 0 to 127; y <- 0 to 127) yield {\\n    (Set((-1, 0), (0, -1), (1, 0), (0,1)).collect {\\n      case (dx, dy) if matrix.isDefinedAt(x + dx) && matrix(x + dx).isDefinedAt(y + dy) && matrix(x + dx)(y + dy) == matrix(x)(y)\\n      => y + dy + 128 * (x + dx)\\n    }, matrix(x)(y) == '1')\\n  }).toVector\\n\\n  val edges = edgesWithMask.map(_._1)\\n  val mask = edgesWithMask.map(_._2)\\n\\n  countClusters(edges, mask)\\n}\\n// countRegions: (key: String)Int\\n```\\n\\nTest that we can generate correct output for the example given\\n\\n```scala\\nclass Day14Part2Test extends FunSuite with Matchers {\\n  test(\\\"testCountRegions\\\") {\\n    countRegions(\\\"flqrgnkx\\\") shouldBe 1242\\n  }\\n}\\n// defined class Day14Part2Test\\n\\n(new Day14Part2Test).execute()\\n// Day14Part2Test:\\n// - testCountRegions\\n```\\n\\nWith that working I can input the puzzle input and submit a solution\\n\\n```scala\\ncountRegions(\\\"xlqgujun\\\")\\n// res3: Int = 1089\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/14\">Advent of Code 2017 - Day 14</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>For the first part we need to reuse the implementation for <a href=\"https://blog.goblinoid.co.uk/aoc-2017-day-10-knot-hash/\">day 10</a></p>\n<pre><code class=\"language-scala\">import Day10._\n// import Day10._\n</code></pre>\n<p>With that available I can now use it to run the repeated hash on the input, convert it to a binary representation and count the bits that have been set.</p>\n<pre><code class=\"language-scala\">def countBits(hexString: String): Int = (\n  hexString\n    .grouped(4).map(s =&gt; Integer.parseInt(s, 16).toBinaryString)\n    .mkString(&quot;&quot;)\n    .count(_ == '1')\n)\n// countBits: (hexString: String)Int\n\ndef countUsed(key: String): Int = (\n  (0 to 127)\n    .map(i =&gt; Day10.knotHash(s&quot;$key-$i&quot;))\n    .map(countBits)\n    .sum\n)\n// countUsed: (key: String)Int\n</code></pre>\n<p>Check that it works:</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day14Part1Test extends FunSuite with Matchers {\n\n  test(&quot;testCountBits&quot;) {\n    countBits(&quot;0&quot;) shouldBe 0\n    countBits(&quot;1&quot;) shouldBe 1\n    countBits(&quot;e&quot;) shouldBe 3\n    countBits(&quot;f&quot;) shouldBe 4\n    countBits(&quot;ff&quot;) shouldBe 8\n    countBits(&quot;1248&quot;) shouldBe 4\n    countBits(&quot;137f&quot;) shouldBe 10\n    countBits(&quot;f0000000000000000000000000000001&quot;) shouldBe 5\n  }\n\n  test(&quot;testCountUsed&quot;) {\n    countUsed(&quot;flqrgnkx&quot;) shouldBe 8108\n  }\n}\n// defined class Day14Part1Test\n\n(new Day14Part1Test).execute()\n// Day14Part1Test:\n// - testCountBits\n// - testCountUsed\n</code></pre>\n<p>Run for the puzzle input:</p>\n<pre><code class=\"language-scala\">countUsed(&quot;xlqgujun&quot;)\n// res1: Int = 8204\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Today's theme seems to be code reuse. This one is slightly less specific but the challenge allows me to reuse the clustering from <a href=\"https://blog.goblinoid.co.uk/aoc-2017-day-12-digital-plumber/\">day 12</a> if I can munge the input into the same input. The only hiccup is that for day 12 it is assumed that the nodes are sequentially numbered, and have at least one connection. For this puzzle we want to ignore the 0 bits. I added a small change to the algorithm in so that a number of nodes can be excluded from the algorithm using a map, and build a mask of all the 0 bits as I transform the data into the expected <code>Vector[Set[Int]]</code> format.</p>\n<pre><code class=\"language-scala\">import scala.collection.BitSet\n// import scala.collection.BitSet\n\ndef drawBits(hexString: String): String = (\n  hexString\n    .grouped(4).map(s =&gt; Integer.parseInt(s, 16).toBinaryString.formatted(&quot;%16s&quot;).replaceAll(&quot; &quot;, &quot;0&quot;))\n    .mkString(&quot;&quot;)\n)\n// drawBits: (hexString: String)String\n\ndef clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\n    case Nil =&gt; matches\n    case e +: es if matches.contains(e) =&gt; iter(es, matches)\n    case e +: es =&gt; iter(es ++ edges(e), matches + e)\n  }\n  \n  iter(edges(root).toSeq, BitSet(root))\n}\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\n\ndef countClusters(edges: Vector[Set[Int]], mask: Vector[Boolean]): Int = {\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\n    case Nil =&gt; count\n    case e +: es if matches.contains(e) =&gt; iter(es, matches, count)\n    case e +: es =&gt; iter(es, matches ++ clusterWith(e, edges), count + 1)\n  }\n  \n  iter(edges.indices.filter(e =&gt; mask(e)), BitSet.empty, 0)\n}\n// countClusters: (edges: Vector[Set[Int]], mask: Vector[Boolean])Int\n\ndef countRegions(key: String): Int = {\n  val matrix = Vector.iterate(0, 128)(_ + 1).map(i =&gt; drawBits(Day10.knotHash(s&quot;$key-$i&quot;)))\n  val edgesWithMask: Vector[(Set[Int], Boolean)] = (for(x &lt;- 0 to 127; y &lt;- 0 to 127) yield {\n    (Set((-1, 0), (0, -1), (1, 0), (0,1)).collect {\n      case (dx, dy) if matrix.isDefinedAt(x + dx) &amp;&amp; matrix(x + dx).isDefinedAt(y + dy) &amp;&amp; matrix(x + dx)(y + dy) == matrix(x)(y)\n      =&gt; y + dy + 128 * (x + dx)\n    }, matrix(x)(y) == '1')\n  }).toVector\n\n  val edges = edgesWithMask.map(_._1)\n  val mask = edgesWithMask.map(_._2)\n\n  countClusters(edges, mask)\n}\n// countRegions: (key: String)Int\n</code></pre>\n<p>Test that we can generate correct output for the example given</p>\n<pre><code class=\"language-scala\">class Day14Part2Test extends FunSuite with Matchers {\n  test(&quot;testCountRegions&quot;) {\n    countRegions(&quot;flqrgnkx&quot;) shouldBe 1242\n  }\n}\n// defined class Day14Part2Test\n\n(new Day14Part2Test).execute()\n// Day14Part2Test:\n// - testCountRegions\n</code></pre>\n<p>With that working I can input the puzzle input and submit a solution</p>\n<pre><code class=\"language-scala\">countRegions(&quot;xlqgujun&quot;)\n// res3: Int = 1089\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3b04e59c9605113d0a49c6","plaintext":"A solution for Advent of Code 2017 - Day 14\n[http://adventofcode.com/2017/day/14]\n\nPart 1\nFor the first part we need to reuse the implementation for day 10\n[https://blog.goblinoid.co.uk/aoc-2017-day-10-knot-hash/]\n\nimport Day10._\n// import Day10._\n\n\nWith that available I can now use it to run the repeated hash on the input,\nconvert it to a binary representation and count the bits that have been set.\n\ndef countBits(hexString: String): Int = (\n  hexString\n    .grouped(4).map(s => Integer.parseInt(s, 16).toBinaryString)\n    .mkString(\"\")\n    .count(_ == '1')\n)\n// countBits: (hexString: String)Int\n\ndef countUsed(key: String): Int = (\n  (0 to 127)\n    .map(i => Day10.knotHash(s\"$key-$i\"))\n    .map(countBits)\n    .sum\n)\n// countUsed: (key: String)Int\n\n\nCheck that it works:\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day14Part1Test extends FunSuite with Matchers {\n\n  test(\"testCountBits\") {\n    countBits(\"0\") shouldBe 0\n    countBits(\"1\") shouldBe 1\n    countBits(\"e\") shouldBe 3\n    countBits(\"f\") shouldBe 4\n    countBits(\"ff\") shouldBe 8\n    countBits(\"1248\") shouldBe 4\n    countBits(\"137f\") shouldBe 10\n    countBits(\"f0000000000000000000000000000001\") shouldBe 5\n  }\n\n  test(\"testCountUsed\") {\n    countUsed(\"flqrgnkx\") shouldBe 8108\n  }\n}\n// defined class Day14Part1Test\n\n(new Day14Part1Test).execute()\n// Day14Part1Test:\n// - testCountBits\n// - testCountUsed\n\n\nRun for the puzzle input:\n\ncountUsed(\"xlqgujun\")\n// res1: Int = 8204\n\n\nPart 2\nToday's theme seems to be code reuse. This one is slightly less specific but the\nchallenge allows me to reuse the clustering from day 12\n[https://blog.goblinoid.co.uk/aoc-2017-day-12-digital-plumber/] if I can munge\nthe input into the same input. The only hiccup is that for day 12 it is assumed\nthat the nodes are sequentially numbered, and have at least one connection. For\nthis puzzle we want to ignore the 0 bits. I added a small change to the\nalgorithm in so that a number of nodes can be excluded from the algorithm using\na map, and build a mask of all the 0 bits as I transform the data into the\nexpected Vector[Set[Int]] format.\n\nimport scala.collection.BitSet\n// import scala.collection.BitSet\n\ndef drawBits(hexString: String): String = (\n  hexString\n    .grouped(4).map(s => Integer.parseInt(s, 16).toBinaryString.formatted(\"%16s\").replaceAll(\" \", \"0\"))\n    .mkString(\"\")\n)\n// drawBits: (hexString: String)String\n\ndef clusterWith(root: Int, edges: Vector[Set[Int]]): BitSet = {\n  def iter(linkedEdges: Seq[Int], matches: BitSet): BitSet = linkedEdges match {\n    case Nil => matches\n    case e +: es if matches.contains(e) => iter(es, matches)\n    case e +: es => iter(es ++ edges(e), matches + e)\n  }\n  \n  iter(edges(root).toSeq, BitSet(root))\n}\n// clusterWith: (root: Int, edges: Vector[Set[Int]])scala.collection.BitSet\n\ndef countClusters(edges: Vector[Set[Int]], mask: Vector[Boolean]): Int = {\n  def iter(toProcess: Seq[Int], matches: BitSet, count: Int): Int = toProcess match {\n    case Nil => count\n    case e +: es if matches.contains(e) => iter(es, matches, count)\n    case e +: es => iter(es, matches ++ clusterWith(e, edges), count + 1)\n  }\n  \n  iter(edges.indices.filter(e => mask(e)), BitSet.empty, 0)\n}\n// countClusters: (edges: Vector[Set[Int]], mask: Vector[Boolean])Int\n\ndef countRegions(key: String): Int = {\n  val matrix = Vector.iterate(0, 128)(_ + 1).map(i => drawBits(Day10.knotHash(s\"$key-$i\")))\n  val edgesWithMask: Vector[(Set[Int], Boolean)] = (for(x <- 0 to 127; y <- 0 to 127) yield {\n    (Set((-1, 0), (0, -1), (1, 0), (0,1)).collect {\n      case (dx, dy) if matrix.isDefinedAt(x + dx) && matrix(x + dx).isDefinedAt(y + dy) && matrix(x + dx)(y + dy) == matrix(x)(y)\n      => y + dy + 128 * (x + dx)\n    }, matrix(x)(y) == '1')\n  }).toVector\n\n  val edges = edgesWithMask.map(_._1)\n  val mask = edgesWithMask.map(_._2)\n\n  countClusters(edges, mask)\n}\n// countRegions: (key: String)Int\n\n\nTest that we can generate correct output for the example given\n\nclass Day14Part2Test extends FunSuite with Matchers {\n  test(\"testCountRegions\") {\n    countRegions(\"flqrgnkx\") shouldBe 1242\n  }\n}\n// defined class Day14Part2Test\n\n(new Day14Part2Test).execute()\n// Day14Part2Test:\n// - testCountRegions\n\n\nWith that working I can input the puzzle input and submit a solution\n\ncountRegions(\"xlqgujun\")\n// res3: Int = 1089","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-17.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-21T00:48:37.000Z","updated_at":"2017-12-21T05:00:00.000Z","published_at":"2017-12-21T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 14","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3c411b9c9605113d0a49cd","uuid":"80d3c4e0-957d-4116-9322-5baa8c751d50","title":"Dueling Generators","slug":"aoc-2017-day-15","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 15](http://adventofcode.com/2017/day/15)\\n\\n## Part 1\\n\\nI took a while trying to generate the sequences using scala streams, but there seems to be no easy way to make them tail recursive, even though their laziness is the main feature. I then discovered Iterator.iterate which does exactly what I want. \\n\\n```scala\\ndef buildIterator(start: Int, factor: Long): Iterator[Int] =\\n  Iterator.iterate(start)(i => ((i * factor) % 2147483647).toInt).drop(1)\\n// buildIterator: (start: Int, factor: Long)Iterator[Int]\\n```\\n\\nI made the least significant bit comparator take in the number of bits required so that it was easier to write extra test cases,\\n\\n```scala\\ndef buildLSBComparator(numBits: Int): ((Int, Int)) => Boolean = {\\n  val mask = (1 << numBits) - 1\\n\\n  (p: (Int, Int)) => (p._1 & mask) == (p._2 & mask)\\n}\\n// buildLSBComparator: (numBits: Int)((Int, Int)) => Boolean\\n```\\n\\nFinally given two iterators, I need to be able to count the number that match for a given number of iterations.\\n\\n```scala\\ndef countMatches(a: Iterator[Int], b: Iterator[Int], iterations: Int): Int = {\\n  a.take(iterations)\\n    .zip(b.take(iterations))\\n    .count(buildLSBComparator(16))\\n}\\n// countMatches: (a: Iterator[Int], b: Iterator[Int], iterations: Int)Int\\n```\\n\\nTests for all of the above can be built from the puzzle description\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day15Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can build generator\\\") {\\n    buildIterator(65, 16807).take(5).toSeq shouldBe Seq(\\n      1092455,\\n      1181022009,\\n      245556042,\\n      1744312007,\\n      1352636452\\n    )\\n\\n    buildIterator(8921, 48271).take(5).toSeq shouldBe Seq(\\n      430625591,\\n      1233683848,\\n      1431495498,\\n      137874439,\\n      285222916\\n    )\\n  }\\n\\n  test(\\\"can compare bits\\\") {\\n    buildLSBComparator(5)((1092455, 430625591)) shouldBe false\\n    buildLSBComparator(5)((1181022009, 1233683848)) shouldBe false\\n    buildLSBComparator(5)((245556042, 1431495498)) shouldBe true\\n    buildLSBComparator(5)((1744312007, 137874439)) shouldBe true\\n    buildLSBComparator(5)((1352636452, 285222916)) shouldBe true\\n\\n    buildLSBComparator(16)((1092455, 430625591)) shouldBe false\\n    buildLSBComparator(16)((1181022009, 1233683848)) shouldBe false\\n    buildLSBComparator(16)((245556042, 1431495498)) shouldBe true\\n    buildLSBComparator(16)((1744312007, 137874439)) shouldBe false\\n    buildLSBComparator(16)((1352636452, 285222916)) shouldBe false\\n  }\\n\\n  test(\\\"can count matches\\\") {\\n    countMatches(\\n      buildIterator(65, 16807),\\n      buildIterator(8921, 48271),\\n      5\\n    ) shouldBe 1\\n\\n    countMatches(\\n      buildIterator(65, 16807),\\n      buildIterator(8921, 48271),\\n      40000000\\n    ) shouldBe 588\\n  }\\n}\\n// defined class Day15Part1Test\\n\\n(new Day15Part1Test).execute()\\n// Day15Part1Test:\\n// - can build generator\\n// - can compare bits\\n// - can count matches\\n```\\n\\nAll looks good. I can now run this for my puzzle input.\\n\\n```scala\\ncountMatches(\\n  buildIterator(591, 16807),\\n  buildIterator(393, 48271),\\n  40000000\\n)\\n// res1: Int = 619\\n```\\n\\n## Part 2\\n\\nPart 2 just involved filtering out values that are not divisible by a certain factor.\\n\\n```scala\\ndef filterIterator(start: Int, factor: Long, divisor: Int): Iterator[Int] =\\n  buildIterator(start, factor).filter(_ % divisor == 0)\\n// filterIterator: (start: Int, factor: Long, divisor: Int)Iterator[Int]\\n```\\n\\nWhich is simple enough, but I'll test it anyway since there were examples provided.\\n\\n```scala\\nclass Day15Part2Test extends FunSuite with Matchers {\\n  test(\\\"can filter results\\\") {\\n    filterIterator(65, 16807, 4).take(5).toSeq shouldBe Seq (\\n      1352636452,\\n      1992081072,\\n      530830436,\\n      1980017072,\\n      740335192\\n    )\\n\\n    filterIterator(8921, 48271, 8).take(5).toSeq shouldBe Seq (\\n      1233683848,\\n      862516352,\\n      1159784568,\\n      1616057672,\\n      412269392\\n    )\\n  }\\n}\\n// defined class Day15Part2Test\\n\\n(new Day15Part2Test).execute()\\n// Day15Part2Test:\\n// - can filter results\\n```\\n\\nI now need to refactor my above solution to use the filters and reduced iteration count.\\n\\n```scala\\ncountMatches(\\n  filterIterator(591, 16807, 4),\\n  filterIterator(393, 48271, 8),\\n  5000000\\n)\\n// res3: Int = 290\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/15\">Advent of Code 2017 - Day 15</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>I took a while trying to generate the sequences using scala streams, but there seems to be no easy way to make them tail recursive, even though their laziness is the main feature. I then discovered Iterator.iterate which does exactly what I want.</p>\n<pre><code class=\"language-scala\">def buildIterator(start: Int, factor: Long): Iterator[Int] =\n  Iterator.iterate(start)(i =&gt; ((i * factor) % 2147483647).toInt).drop(1)\n// buildIterator: (start: Int, factor: Long)Iterator[Int]\n</code></pre>\n<p>I made the least significant bit comparator take in the number of bits required so that it was easier to write extra test cases,</p>\n<pre><code class=\"language-scala\">def buildLSBComparator(numBits: Int): ((Int, Int)) =&gt; Boolean = {\n  val mask = (1 &lt;&lt; numBits) - 1\n\n  (p: (Int, Int)) =&gt; (p._1 &amp; mask) == (p._2 &amp; mask)\n}\n// buildLSBComparator: (numBits: Int)((Int, Int)) =&gt; Boolean\n</code></pre>\n<p>Finally given two iterators, I need to be able to count the number that match for a given number of iterations.</p>\n<pre><code class=\"language-scala\">def countMatches(a: Iterator[Int], b: Iterator[Int], iterations: Int): Int = {\n  a.take(iterations)\n    .zip(b.take(iterations))\n    .count(buildLSBComparator(16))\n}\n// countMatches: (a: Iterator[Int], b: Iterator[Int], iterations: Int)Int\n</code></pre>\n<p>Tests for all of the above can be built from the puzzle description</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day15Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can build generator&quot;) {\n    buildIterator(65, 16807).take(5).toSeq shouldBe Seq(\n      1092455,\n      1181022009,\n      245556042,\n      1744312007,\n      1352636452\n    )\n\n    buildIterator(8921, 48271).take(5).toSeq shouldBe Seq(\n      430625591,\n      1233683848,\n      1431495498,\n      137874439,\n      285222916\n    )\n  }\n\n  test(&quot;can compare bits&quot;) {\n    buildLSBComparator(5)((1092455, 430625591)) shouldBe false\n    buildLSBComparator(5)((1181022009, 1233683848)) shouldBe false\n    buildLSBComparator(5)((245556042, 1431495498)) shouldBe true\n    buildLSBComparator(5)((1744312007, 137874439)) shouldBe true\n    buildLSBComparator(5)((1352636452, 285222916)) shouldBe true\n\n    buildLSBComparator(16)((1092455, 430625591)) shouldBe false\n    buildLSBComparator(16)((1181022009, 1233683848)) shouldBe false\n    buildLSBComparator(16)((245556042, 1431495498)) shouldBe true\n    buildLSBComparator(16)((1744312007, 137874439)) shouldBe false\n    buildLSBComparator(16)((1352636452, 285222916)) shouldBe false\n  }\n\n  test(&quot;can count matches&quot;) {\n    countMatches(\n      buildIterator(65, 16807),\n      buildIterator(8921, 48271),\n      5\n    ) shouldBe 1\n\n    countMatches(\n      buildIterator(65, 16807),\n      buildIterator(8921, 48271),\n      40000000\n    ) shouldBe 588\n  }\n}\n// defined class Day15Part1Test\n\n(new Day15Part1Test).execute()\n// Day15Part1Test:\n// - can build generator\n// - can compare bits\n// - can count matches\n</code></pre>\n<p>All looks good. I can now run this for my puzzle input.</p>\n<pre><code class=\"language-scala\">countMatches(\n  buildIterator(591, 16807),\n  buildIterator(393, 48271),\n  40000000\n)\n// res1: Int = 619\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Part 2 just involved filtering out values that are not divisible by a certain factor.</p>\n<pre><code class=\"language-scala\">def filterIterator(start: Int, factor: Long, divisor: Int): Iterator[Int] =\n  buildIterator(start, factor).filter(_ % divisor == 0)\n// filterIterator: (start: Int, factor: Long, divisor: Int)Iterator[Int]\n</code></pre>\n<p>Which is simple enough, but I'll test it anyway since there were examples provided.</p>\n<pre><code class=\"language-scala\">class Day15Part2Test extends FunSuite with Matchers {\n  test(&quot;can filter results&quot;) {\n    filterIterator(65, 16807, 4).take(5).toSeq shouldBe Seq (\n      1352636452,\n      1992081072,\n      530830436,\n      1980017072,\n      740335192\n    )\n\n    filterIterator(8921, 48271, 8).take(5).toSeq shouldBe Seq (\n      1233683848,\n      862516352,\n      1159784568,\n      1616057672,\n      412269392\n    )\n  }\n}\n// defined class Day15Part2Test\n\n(new Day15Part2Test).execute()\n// Day15Part2Test:\n// - can filter results\n</code></pre>\n<p>I now need to refactor my above solution to use the filters and reduced iteration count.</p>\n<pre><code class=\"language-scala\">countMatches(\n  filterIterator(591, 16807, 4),\n  filterIterator(393, 48271, 8),\n  5000000\n)\n// res3: Int = 290\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3c411b9c9605113d0a49cd","plaintext":"A solution for Advent of Code 2017 - Day 15\n[http://adventofcode.com/2017/day/15]\n\nPart 1\nI took a while trying to generate the sequences using scala streams, but there\nseems to be no easy way to make them tail recursive, even though their laziness\nis the main feature. I then discovered Iterator.iterate which does exactly what\nI want.\n\ndef buildIterator(start: Int, factor: Long): Iterator[Int] =\n  Iterator.iterate(start)(i => ((i * factor) % 2147483647).toInt).drop(1)\n// buildIterator: (start: Int, factor: Long)Iterator[Int]\n\n\nI made the least significant bit comparator take in the number of bits required\nso that it was easier to write extra test cases,\n\ndef buildLSBComparator(numBits: Int): ((Int, Int)) => Boolean = {\n  val mask = (1 << numBits) - 1\n\n  (p: (Int, Int)) => (p._1 & mask) == (p._2 & mask)\n}\n// buildLSBComparator: (numBits: Int)((Int, Int)) => Boolean\n\n\nFinally given two iterators, I need to be able to count the number that match\nfor a given number of iterations.\n\ndef countMatches(a: Iterator[Int], b: Iterator[Int], iterations: Int): Int = {\n  a.take(iterations)\n    .zip(b.take(iterations))\n    .count(buildLSBComparator(16))\n}\n// countMatches: (a: Iterator[Int], b: Iterator[Int], iterations: Int)Int\n\n\nTests for all of the above can be built from the puzzle description\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day15Part1Test extends FunSuite with Matchers {\n\n  test(\"can build generator\") {\n    buildIterator(65, 16807).take(5).toSeq shouldBe Seq(\n      1092455,\n      1181022009,\n      245556042,\n      1744312007,\n      1352636452\n    )\n\n    buildIterator(8921, 48271).take(5).toSeq shouldBe Seq(\n      430625591,\n      1233683848,\n      1431495498,\n      137874439,\n      285222916\n    )\n  }\n\n  test(\"can compare bits\") {\n    buildLSBComparator(5)((1092455, 430625591)) shouldBe false\n    buildLSBComparator(5)((1181022009, 1233683848)) shouldBe false\n    buildLSBComparator(5)((245556042, 1431495498)) shouldBe true\n    buildLSBComparator(5)((1744312007, 137874439)) shouldBe true\n    buildLSBComparator(5)((1352636452, 285222916)) shouldBe true\n\n    buildLSBComparator(16)((1092455, 430625591)) shouldBe false\n    buildLSBComparator(16)((1181022009, 1233683848)) shouldBe false\n    buildLSBComparator(16)((245556042, 1431495498)) shouldBe true\n    buildLSBComparator(16)((1744312007, 137874439)) shouldBe false\n    buildLSBComparator(16)((1352636452, 285222916)) shouldBe false\n  }\n\n  test(\"can count matches\") {\n    countMatches(\n      buildIterator(65, 16807),\n      buildIterator(8921, 48271),\n      5\n    ) shouldBe 1\n\n    countMatches(\n      buildIterator(65, 16807),\n      buildIterator(8921, 48271),\n      40000000\n    ) shouldBe 588\n  }\n}\n// defined class Day15Part1Test\n\n(new Day15Part1Test).execute()\n// Day15Part1Test:\n// - can build generator\n// - can compare bits\n// - can count matches\n\n\nAll looks good. I can now run this for my puzzle input.\n\ncountMatches(\n  buildIterator(591, 16807),\n  buildIterator(393, 48271),\n  40000000\n)\n// res1: Int = 619\n\n\nPart 2\nPart 2 just involved filtering out values that are not divisible by a certain\nfactor.\n\ndef filterIterator(start: Int, factor: Long, divisor: Int): Iterator[Int] =\n  buildIterator(start, factor).filter(_ % divisor == 0)\n// filterIterator: (start: Int, factor: Long, divisor: Int)Iterator[Int]\n\n\nWhich is simple enough, but I'll test it anyway since there were examples\nprovided.\n\nclass Day15Part2Test extends FunSuite with Matchers {\n  test(\"can filter results\") {\n    filterIterator(65, 16807, 4).take(5).toSeq shouldBe Seq (\n      1352636452,\n      1992081072,\n      530830436,\n      1980017072,\n      740335192\n    )\n\n    filterIterator(8921, 48271, 8).take(5).toSeq shouldBe Seq (\n      1233683848,\n      862516352,\n      1159784568,\n      1616057672,\n      412269392\n    )\n  }\n}\n// defined class Day15Part2Test\n\n(new Day15Part2Test).execute()\n// Day15Part2Test:\n// - can filter results\n\n\nI now need to refactor my above solution to use the filters and reduced\niteration count.\n\ncountMatches(\n  filterIterator(591, 16807, 4),\n  filterIterator(393, 48271, 8),\n  5000000\n)\n// res3: Int = 290","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-18.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-21T23:17:47.000Z","updated_at":"2017-12-22T05:00:00.000Z","published_at":"2017-12-22T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 15","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3db3339c9605113d0a49d8","uuid":"c48856b3-5362-436c-b1a7-c66f67c37d8a","title":"Permutation Promenade","slug":"aoc-2017-day-16-permutation-promenade","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 16](http://adventofcode.com/2017/day/16)\\n\\n## Part 1\\n\\nPart one is effectively just parsing the input.\\n\\n```scala\\nval Spin = \\\"s(\\\\\\\\d+)\\\".r\\n// Spin: scala.util.matching.Regex = s(\\\\d+)\\n\\nval Exchange = \\\"x(\\\\\\\\d+)/(\\\\\\\\d+)\\\".r\\n// Exchange: scala.util.matching.Regex = x(\\\\d+)/(\\\\d+)\\n\\nval Partner = \\\"p([a-z])/([a-z])\\\".r\\n// Partner: scala.util.matching.Regex = p([a-z])/([a-z])\\n\\ndef applyInstruction(instruction: String, programs: Vector[Char]): Vector[Char] =\\n  instruction match {\\n    case Spin(n) => programs.takeRight(n.toInt) ++ programs.dropRight(n.toInt)\\n    case Exchange(a,b) =>\\n      programs\\n        .updated(a.toInt, programs(b.toInt))\\n        .updated(b.toInt, programs(a.toInt))\\n    case Partner(a, b) =>\\n      programs\\n          .updated(programs.indexOf(a.charAt(0)), b.charAt(0))\\n          .updated(programs.indexOf(b.charAt(0)), a.charAt(0))\\n\\n  }\\n// applyInstruction: (instruction: String, programs: Vector[Char])Vector[Char]\\n\\ndef applyInstructions(instructions: Array[String], programs: Vector[Char]): Vector[Char] =\\n  instructions.foldLeft(programs){ case( ps, i) => applyInstruction(i, ps) }\\n// applyInstructions: (instructions: Array[String], programs: Vector[Char])Vector[Char]\\n```\\n\\nThis assumes the input string has already been split on commas. The examples given in the instructions convert nicely to test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day16Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can apply an instruction\\\") {\\n    applyInstruction(\\\"s1\\\", \\\"abcde\\\".toVector) shouldBe \\\"eabcd\\\".toVector\\n    applyInstruction(\\\"x3/4\\\", \\\"eabcd\\\".toVector) shouldBe \\\"eabdc\\\".toVector\\n    applyInstruction(\\\"pe/b\\\", \\\"eabdc\\\".toVector) shouldBe \\\"baedc\\\".toVector\\n  }\\n\\n  test(\\\"can apply program\\\") {\\n    applyInstructions(\\\"s1,x3/4,pe/b\\\".split(','), \\\"abcde\\\".toVector) shouldBe \\\"baedc\\\".toVector\\n  }\\n}\\n// defined class Day16Part1Test\\n\\n(new Day16Part1Test).execute()\\n// Day16Part1Test:\\n// - can apply an instruction\\n// - can apply program\\n```\\n\\nRunning with the puzzle input gives the correct output.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = Source.fromResource(\\\"day16input.txt\\\").mkString.trim.split(',')\\n// input: Array[String] = Array(x6/13, pk/n, x9/2, pl/o, x12/1, pm/n, s10, x13/7, s7, x1/11, s9, x13/10, pa/d, x5/9, s12, x10/4, s5, x0/7, s11, x12/6, s6, x9/14, s15, x8/5, s14, x9/6, s11, x5/15, ph/c, x4/8, pj/m, x6/14, s11, x11/7, s13, x0/1, s9, x6/8, s6, pg/b, s13, x14/11, pa/i, x15/4, s6, x12/2, pg/c, s9, x13/3, s13, x10/15, pk/a, x7/12, s6, x5/6, s5, x1/0, pp/f, x12/15, s4, x1/10, pl/e, x0/7, s4, x9/11, s13, x12/3, pi/c, s13, x8/10, pd/m, x3/15, pf/n, s7, x1/11, s9, x2/0, pi/d, x1/15, s2, x9/8, s11, x11/13, pg/l, x9/0, pd/j, x8/10, pk/o, x7/3, s4, x2/8, pg/j, x13/4, s6, x9/2, pk/p, s8, po/b, x14/13, s7, x8/12, s4, x11/10, s3, pp/j, x3/14, pe/l, x11/8, s10, x4/2, s15, x0/7, s13, x14/5, pf/i, x0/7, s4, x15/12, pc/p, s10, x11/13, pe/m, x14/12, s4, x5/1, pp/f, x4/3, pm/h, x14/8, pe/a, x15...\\n\\napplyInstructions(input, \\\"abcdefghijklmnop\\\".toVector).mkString\\n// res1: String = cknmidebghlajpfo\\n```\\n\\n## Part 2\\n\\nPart two is a bit trickier. I must admit I tried just running the program a billion times, but it was going nowhere fast. I then noted that hopefully the output would eventually repeat. I already had a function that could find the loop size of a repeating program. I needed to make it work with strings, and since I was reusing it I made it generic.\\n\\n```scala\\ndef countLoopSize[T](sequence: Vector[T], update: Vector[T] => Vector[T]): (Int, Int, Map[Vector[T], Int]) = {\\n  def iter(state: Vector[T],\\n           seen: Map[Vector[T], Int] = Map.empty,\\n           count: Int = 0): (Int, Int, Map[Vector[T], Int]) =\\n    if (seen.isDefinedAt(state)) (count, count - seen(state), seen)\\n    else iter(update(state), seen.updated(state, count), count + 1)\\n    \\n  iter(sequence)\\n}\\n// countLoopSize: [T](sequence: Vector[T], update: Vector[T] => Vector[T])(Int, Int, Map[Vector[T],Int])\\n```\\n\\nI could then use the output from that to work out at what point round the loop the programs would be after 1 billion iterations.\\n\\n```scala\\ndef applyRepeatInstructions(n: Int, instructions: Array[String], programs: Vector[Char]): Vector[Char] = {\\n  val (count, loopSize, seen) = countLoopSize(programs, (ps:Vector[Char]) => applyInstructions(instructions, ps))\\n  val prefix = count - loopSize\\n\\n  seen.find { case (_, i) => i == prefix + ((n - prefix) % loopSize)}.get._1\\n}\\n// applyRepeatInstructions: (n: Int, instructions: Array[String], programs: Vector[Char])Vector[Char]\\n```\\n\\nI don't really have sample looping data to test this scenario, but I can ensure the refactor of countLoopSize works by running the Day 6 test case through the new function.\\n\\n\\n\\n```scala\\nclass Day16Part2Test extends FunSuite with Matchers {\\n  test(\\\"refactor count loop size\\\") {\\n      countLoopSize(Vector(0, 2, 7, 0), Day6.redistribute)._2 shouldBe 4\\n      countLoopSize(Vector(2, 4, 1, 2), Day6.redistribute)._2 shouldBe 4\\n      countLoopSize(Vector(3, 1, 2, 3), Day6.redistribute)._2 shouldBe 4\\n      countLoopSize(Vector(23), Day6.redistribute)._2 shouldBe 1\\n      countLoopSize(Vector(4, 2), Day6.redistribute)._2 shouldBe 2\\n      countLoopSize(Vector(5, 1), Day6.redistribute)._2 shouldBe 2\\n  }\\n}\\n// defined class Day16Part2Test\\n\\n(new Day16Part2Test).execute()\\n// Day16Part2Test:\\n// - refactor count loop size\\n```\\n\\nNow I run today's input through the loop counter and hope that it does in fact repeat (spoiler: it does).\\n\\n```scala\\napplyRepeatInstructions(1000000000, input, \\\"abcdefghijklmnop\\\".toVector).mkString\\n// res3: String = cbolhmkgfpenidaj\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/16\">Advent of Code 2017 - Day 16</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Part one is effectively just parsing the input.</p>\n<pre><code class=\"language-scala\">val Spin = &quot;s(\\\\d+)&quot;.r\n// Spin: scala.util.matching.Regex = s(\\d+)\n\nval Exchange = &quot;x(\\\\d+)/(\\\\d+)&quot;.r\n// Exchange: scala.util.matching.Regex = x(\\d+)/(\\d+)\n\nval Partner = &quot;p([a-z])/([a-z])&quot;.r\n// Partner: scala.util.matching.Regex = p([a-z])/([a-z])\n\ndef applyInstruction(instruction: String, programs: Vector[Char]): Vector[Char] =\n  instruction match {\n    case Spin(n) =&gt; programs.takeRight(n.toInt) ++ programs.dropRight(n.toInt)\n    case Exchange(a,b) =&gt;\n      programs\n        .updated(a.toInt, programs(b.toInt))\n        .updated(b.toInt, programs(a.toInt))\n    case Partner(a, b) =&gt;\n      programs\n          .updated(programs.indexOf(a.charAt(0)), b.charAt(0))\n          .updated(programs.indexOf(b.charAt(0)), a.charAt(0))\n\n  }\n// applyInstruction: (instruction: String, programs: Vector[Char])Vector[Char]\n\ndef applyInstructions(instructions: Array[String], programs: Vector[Char]): Vector[Char] =\n  instructions.foldLeft(programs){ case( ps, i) =&gt; applyInstruction(i, ps) }\n// applyInstructions: (instructions: Array[String], programs: Vector[Char])Vector[Char]\n</code></pre>\n<p>This assumes the input string has already been split on commas. The examples given in the instructions convert nicely to test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day16Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can apply an instruction&quot;) {\n    applyInstruction(&quot;s1&quot;, &quot;abcde&quot;.toVector) shouldBe &quot;eabcd&quot;.toVector\n    applyInstruction(&quot;x3/4&quot;, &quot;eabcd&quot;.toVector) shouldBe &quot;eabdc&quot;.toVector\n    applyInstruction(&quot;pe/b&quot;, &quot;eabdc&quot;.toVector) shouldBe &quot;baedc&quot;.toVector\n  }\n\n  test(&quot;can apply program&quot;) {\n    applyInstructions(&quot;s1,x3/4,pe/b&quot;.split(','), &quot;abcde&quot;.toVector) shouldBe &quot;baedc&quot;.toVector\n  }\n}\n// defined class Day16Part1Test\n\n(new Day16Part1Test).execute()\n// Day16Part1Test:\n// - can apply an instruction\n// - can apply program\n</code></pre>\n<p>Running with the puzzle input gives the correct output.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = Source.fromResource(&quot;day16input.txt&quot;).mkString.trim.split(',')\n// input: Array[String] = Array(x6/13, pk/n, x9/2, pl/o, x12/1, pm/n, s10, x13/7, s7, x1/11, s9, x13/10, pa/d, x5/9, s12, x10/4, s5, x0/7, s11, x12/6, s6, x9/14, s15, x8/5, s14, x9/6, s11, x5/15, ph/c, x4/8, pj/m, x6/14, s11, x11/7, s13, x0/1, s9, x6/8, s6, pg/b, s13, x14/11, pa/i, x15/4, s6, x12/2, pg/c, s9, x13/3, s13, x10/15, pk/a, x7/12, s6, x5/6, s5, x1/0, pp/f, x12/15, s4, x1/10, pl/e, x0/7, s4, x9/11, s13, x12/3, pi/c, s13, x8/10, pd/m, x3/15, pf/n, s7, x1/11, s9, x2/0, pi/d, x1/15, s2, x9/8, s11, x11/13, pg/l, x9/0, pd/j, x8/10, pk/o, x7/3, s4, x2/8, pg/j, x13/4, s6, x9/2, pk/p, s8, po/b, x14/13, s7, x8/12, s4, x11/10, s3, pp/j, x3/14, pe/l, x11/8, s10, x4/2, s15, x0/7, s13, x14/5, pf/i, x0/7, s4, x15/12, pc/p, s10, x11/13, pe/m, x14/12, s4, x5/1, pp/f, x4/3, pm/h, x14/8, pe/a, x15...\n\napplyInstructions(input, &quot;abcdefghijklmnop&quot;.toVector).mkString\n// res1: String = cknmidebghlajpfo\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Part two is a bit trickier. I must admit I tried just running the program a billion times, but it was going nowhere fast. I then noted that hopefully the output would eventually repeat. I already had a function that could find the loop size of a repeating program. I needed to make it work with strings, and since I was reusing it I made it generic.</p>\n<pre><code class=\"language-scala\">def countLoopSize[T](sequence: Vector[T], update: Vector[T] =&gt; Vector[T]): (Int, Int, Map[Vector[T], Int]) = {\n  def iter(state: Vector[T],\n           seen: Map[Vector[T], Int] = Map.empty,\n           count: Int = 0): (Int, Int, Map[Vector[T], Int]) =\n    if (seen.isDefinedAt(state)) (count, count - seen(state), seen)\n    else iter(update(state), seen.updated(state, count), count + 1)\n    \n  iter(sequence)\n}\n// countLoopSize: [T](sequence: Vector[T], update: Vector[T] =&gt; Vector[T])(Int, Int, Map[Vector[T],Int])\n</code></pre>\n<p>I could then use the output from that to work out at what point round the loop the programs would be after 1 billion iterations.</p>\n<pre><code class=\"language-scala\">def applyRepeatInstructions(n: Int, instructions: Array[String], programs: Vector[Char]): Vector[Char] = {\n  val (count, loopSize, seen) = countLoopSize(programs, (ps:Vector[Char]) =&gt; applyInstructions(instructions, ps))\n  val prefix = count - loopSize\n\n  seen.find { case (_, i) =&gt; i == prefix + ((n - prefix) % loopSize)}.get._1\n}\n// applyRepeatInstructions: (n: Int, instructions: Array[String], programs: Vector[Char])Vector[Char]\n</code></pre>\n<p>I don't really have sample looping data to test this scenario, but I can ensure the refactor of countLoopSize works by running the Day 6 test case through the new function.</p>\n<pre><code class=\"language-scala\">class Day16Part2Test extends FunSuite with Matchers {\n  test(&quot;refactor count loop size&quot;) {\n      countLoopSize(Vector(0, 2, 7, 0), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(2, 4, 1, 2), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(3, 1, 2, 3), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(23), Day6.redistribute)._2 shouldBe 1\n      countLoopSize(Vector(4, 2), Day6.redistribute)._2 shouldBe 2\n      countLoopSize(Vector(5, 1), Day6.redistribute)._2 shouldBe 2\n  }\n}\n// defined class Day16Part2Test\n\n(new Day16Part2Test).execute()\n// Day16Part2Test:\n// - refactor count loop size\n</code></pre>\n<p>Now I run today's input through the loop counter and hope that it does in fact repeat (spoiler: it does).</p>\n<pre><code class=\"language-scala\">applyRepeatInstructions(1000000000, input, &quot;abcdefghijklmnop&quot;.toVector).mkString\n// res3: String = cbolhmkgfpenidaj\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3db3339c9605113d0a49d8","plaintext":"A solution for Advent of Code 2017 - Day 16\n[http://adventofcode.com/2017/day/16]\n\nPart 1\nPart one is effectively just parsing the input.\n\nval Spin = \"s(\\\\d+)\".r\n// Spin: scala.util.matching.Regex = s(\\d+)\n\nval Exchange = \"x(\\\\d+)/(\\\\d+)\".r\n// Exchange: scala.util.matching.Regex = x(\\d+)/(\\d+)\n\nval Partner = \"p([a-z])/([a-z])\".r\n// Partner: scala.util.matching.Regex = p([a-z])/([a-z])\n\ndef applyInstruction(instruction: String, programs: Vector[Char]): Vector[Char] =\n  instruction match {\n    case Spin(n) => programs.takeRight(n.toInt) ++ programs.dropRight(n.toInt)\n    case Exchange(a,b) =>\n      programs\n        .updated(a.toInt, programs(b.toInt))\n        .updated(b.toInt, programs(a.toInt))\n    case Partner(a, b) =>\n      programs\n          .updated(programs.indexOf(a.charAt(0)), b.charAt(0))\n          .updated(programs.indexOf(b.charAt(0)), a.charAt(0))\n\n  }\n// applyInstruction: (instruction: String, programs: Vector[Char])Vector[Char]\n\ndef applyInstructions(instructions: Array[String], programs: Vector[Char]): Vector[Char] =\n  instructions.foldLeft(programs){ case( ps, i) => applyInstruction(i, ps) }\n// applyInstructions: (instructions: Array[String], programs: Vector[Char])Vector[Char]\n\n\nThis assumes the input string has already been split on commas. The examples\ngiven in the instructions convert nicely to test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day16Part1Test extends FunSuite with Matchers {\n\n  test(\"can apply an instruction\") {\n    applyInstruction(\"s1\", \"abcde\".toVector) shouldBe \"eabcd\".toVector\n    applyInstruction(\"x3/4\", \"eabcd\".toVector) shouldBe \"eabdc\".toVector\n    applyInstruction(\"pe/b\", \"eabdc\".toVector) shouldBe \"baedc\".toVector\n  }\n\n  test(\"can apply program\") {\n    applyInstructions(\"s1,x3/4,pe/b\".split(','), \"abcde\".toVector) shouldBe \"baedc\".toVector\n  }\n}\n// defined class Day16Part1Test\n\n(new Day16Part1Test).execute()\n// Day16Part1Test:\n// - can apply an instruction\n// - can apply program\n\n\nRunning with the puzzle input gives the correct output.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = Source.fromResource(\"day16input.txt\").mkString.trim.split(',')\n// input: Array[String] = Array(x6/13, pk/n, x9/2, pl/o, x12/1, pm/n, s10, x13/7, s7, x1/11, s9, x13/10, pa/d, x5/9, s12, x10/4, s5, x0/7, s11, x12/6, s6, x9/14, s15, x8/5, s14, x9/6, s11, x5/15, ph/c, x4/8, pj/m, x6/14, s11, x11/7, s13, x0/1, s9, x6/8, s6, pg/b, s13, x14/11, pa/i, x15/4, s6, x12/2, pg/c, s9, x13/3, s13, x10/15, pk/a, x7/12, s6, x5/6, s5, x1/0, pp/f, x12/15, s4, x1/10, pl/e, x0/7, s4, x9/11, s13, x12/3, pi/c, s13, x8/10, pd/m, x3/15, pf/n, s7, x1/11, s9, x2/0, pi/d, x1/15, s2, x9/8, s11, x11/13, pg/l, x9/0, pd/j, x8/10, pk/o, x7/3, s4, x2/8, pg/j, x13/4, s6, x9/2, pk/p, s8, po/b, x14/13, s7, x8/12, s4, x11/10, s3, pp/j, x3/14, pe/l, x11/8, s10, x4/2, s15, x0/7, s13, x14/5, pf/i, x0/7, s4, x15/12, pc/p, s10, x11/13, pe/m, x14/12, s4, x5/1, pp/f, x4/3, pm/h, x14/8, pe/a, x15...\n\napplyInstructions(input, \"abcdefghijklmnop\".toVector).mkString\n// res1: String = cknmidebghlajpfo\n\n\nPart 2\nPart two is a bit trickier. I must admit I tried just running the program a\nbillion times, but it was going nowhere fast. I then noted that hopefully the\noutput would eventually repeat. I already had a function that could find the\nloop size of a repeating program. I needed to make it work with strings, and\nsince I was reusing it I made it generic.\n\ndef countLoopSize[T](sequence: Vector[T], update: Vector[T] => Vector[T]): (Int, Int, Map[Vector[T], Int]) = {\n  def iter(state: Vector[T],\n           seen: Map[Vector[T], Int] = Map.empty,\n           count: Int = 0): (Int, Int, Map[Vector[T], Int]) =\n    if (seen.isDefinedAt(state)) (count, count - seen(state), seen)\n    else iter(update(state), seen.updated(state, count), count + 1)\n    \n  iter(sequence)\n}\n// countLoopSize: [T](sequence: Vector[T], update: Vector[T] => Vector[T])(Int, Int, Map[Vector[T],Int])\n\n\nI could then use the output from that to work out at what point round the loop\nthe programs would be after 1 billion iterations.\n\ndef applyRepeatInstructions(n: Int, instructions: Array[String], programs: Vector[Char]): Vector[Char] = {\n  val (count, loopSize, seen) = countLoopSize(programs, (ps:Vector[Char]) => applyInstructions(instructions, ps))\n  val prefix = count - loopSize\n\n  seen.find { case (_, i) => i == prefix + ((n - prefix) % loopSize)}.get._1\n}\n// applyRepeatInstructions: (n: Int, instructions: Array[String], programs: Vector[Char])Vector[Char]\n\n\nI don't really have sample looping data to test this scenario, but I can ensure\nthe refactor of countLoopSize works by running the Day 6 test case through the\nnew function.\n\nclass Day16Part2Test extends FunSuite with Matchers {\n  test(\"refactor count loop size\") {\n      countLoopSize(Vector(0, 2, 7, 0), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(2, 4, 1, 2), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(3, 1, 2, 3), Day6.redistribute)._2 shouldBe 4\n      countLoopSize(Vector(23), Day6.redistribute)._2 shouldBe 1\n      countLoopSize(Vector(4, 2), Day6.redistribute)._2 shouldBe 2\n      countLoopSize(Vector(5, 1), Day6.redistribute)._2 shouldBe 2\n  }\n}\n// defined class Day16Part2Test\n\n(new Day16Part2Test).execute()\n// Day16Part2Test:\n// - refactor count loop size\n\n\nNow I run today's input through the loop counter and hope that it does in fact\nrepeat (spoiler: it does).\n\napplyRepeatInstructions(1000000000, input, \"abcdefghijklmnop\".toVector).mkString\n// res3: String = cbolhmkgfpenidaj","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-19.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-23T01:36:51.000Z","updated_at":"2017-12-23T05:00:00.000Z","published_at":"2017-12-23T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 16","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a3ee0de9c9605113d0a49df","uuid":"010cd822-8160-452a-90ef-a050e8192a72","title":"Spinlock","slug":"aoc-2017-day-17-spinlock","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"# Spinlock\\n\\nA solution for [Advent of Code 2017 - Day 17](http://adventofcode.com/2017/day/17)\\n\\n## Part 1\\n\\nFor part one it was mostly just building a vector one element at at time. \\n\\n```scala\\ndef spin(iterations:Int,\\n         step: Int,\\n         pos: Int = 0,\\n         buffer: Vector[Int] = Vector(0),\\n         current: Int = 0): (Int, Vector[Int]) = (\\n  if(current == iterations) (pos, buffer)\\n  else {\\n    val splitPos = ((pos + step) % buffer.length) + 1\\n    val (pre, post) = buffer.splitAt(splitPos)\\n    spin(iterations,step,splitPos, pre ++ Vector(current + 1) ++ post, current + 1)\\n  }\\n)\\n// spin: (iterations: Int, step: Int, pos: Int, buffer: Vector[Int], current: Int)(Int, Vector[Int])\\n\\ndef getSubsequentValue(target: Int, step:Int): Int = {\\n  val (pos, buffer) = spin(target, step)\\n  buffer((pos + 1) % buffer.length)\\n}\\n// getSubsequentValue: (target: Int, step: Int)Int\\n```\\n\\nThe walk-through did give a fairly large number of test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day17Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can spin buffer\\\") {\\n    spin(0, 3) shouldBe (0, Vector(0))\\n    spin(1, 3) shouldBe (1, Vector(0,1))\\n    spin(2, 3) shouldBe (1, Vector(0,2,1))\\n    spin(3, 3) shouldBe (2, Vector(0,2,3,1))\\n    spin(4, 3) shouldBe (2, Vector(0,2,4,3,1))\\n    spin(5, 3) shouldBe (1, Vector(0,5,2,4,3,1))\\n    spin(6, 3) shouldBe (5, Vector(0,5,2,4,3,6,1))\\n    spin(7, 3) shouldBe (2, Vector(0,5,7,2,4,3,6,1))\\n    spin(8, 3) shouldBe (6, Vector(0,5,7,2,4,3,8,6,1))\\n    spin(9, 3) shouldBe (1, Vector(0,9,5,7,2,4,3,8,6,1))\\n  }\\n  \\n  test(\\\"can determine following value\\\") {\\n    getSubsequentValue(0, 3) shouldBe 0\\n    getSubsequentValue(1, 3) shouldBe 0\\n    getSubsequentValue(2, 3) shouldBe 1\\n    getSubsequentValue(3, 3) shouldBe 1\\n    getSubsequentValue(4, 3) shouldBe 3\\n    getSubsequentValue(5, 3) shouldBe 2\\n    getSubsequentValue(6, 3) shouldBe 1\\n    getSubsequentValue(7, 3) shouldBe 2\\n    getSubsequentValue(8, 3) shouldBe 6\\n    getSubsequentValue(9, 3) shouldBe 5\\n\\n    getSubsequentValue(2017, 3) shouldBe 638\\n  }\\n}\\n// defined class Day17Part1Test\\n\\n(new Day17Part1Test).execute()\\n// Day17Part1Test:\\n// - can spin buffer\\n// - can determine following value\\n```\\n\\nThis can then be run with the required step count for the puzzle.\\n\\n```scala\\ngetSubsequentValue(2017, 337)\\n// res1: Int = 600\\n```\\n\\n## Part 2\\n\\nFor part two it is not really feasible to build the full 50 million entry Vector. However as I'm just tracking the number after 0, all I need to keep track of is\\n* The current position of the 0 value, increments by one if a number would be   inserted at or before the current 0 value,\\n* The current value after 0, changes if the insertion position is exactly one  more than the current position.\\n* The current insertion position.\\n\\n```scala\\ndef trackZero(iterations: Int,\\n              step: Int,\\n              currPos: Int = 0,\\n              zeroPos: Int = 0,\\n              valueAfterZero: Int = 0,\\n              current: Int = 0): Int = (\\n  if(current == iterations) valueAfterZero\\n  else {\\n    val newPos = \\n      if(current == 0) 1 \\n      else ((currPos + step) % (current + 1)) + 1\\n    \\n    trackZero(\\n      iterations,\\n      step,\\n      newPos,\\n      if(newPos <= zeroPos) zeroPos + 1 else zeroPos,\\n      if(newPos == zeroPos + 1) current + 1 else valueAfterZero,\\n      current + 1\\n    )\\n  }\\n)\\n// trackZero: (iterations: Int, step: Int, currPos: Int, zeroPos: Int, valueAfterZero: Int, current: Int)Int\\n```\\n\\nI can reuse the previous test cases and also the output from the first part\\ncan be used.\\n\\n```scala\\nclass Day17Part2Test extends FunSuite with Matchers {\\n\\n  test(\\\"can track number after zero\\\")\\n  {\\n    trackZero(0, 3) shouldBe 0\\n    trackZero(1, 3) shouldBe 1\\n    trackZero(2, 3) shouldBe 2\\n    trackZero(3, 3) shouldBe 2\\n    trackZero(4, 3) shouldBe 2\\n    trackZero(5, 3) shouldBe 5\\n    trackZero(6, 3) shouldBe 5\\n    trackZero(7, 3) shouldBe 5\\n    trackZero(8, 3) shouldBe 5\\n    trackZero(9, 3) shouldBe 9\\n\\n    val (_, buffer) = spin(2017, 3)\\n\\n    trackZero(2017, 3) shouldBe buffer(buffer.indexOf(0) + 1)\\n  }\\n}\\n// defined class Day17Part2Test\\n\\n(new Day17Part2Test).execute()\\n// Day17Part2Test:\\n// - can track number after zero\\n```\\nAnd now I'm able to complete the puzzle\\n\\n```scala\\ntrackZero(50000000, 337)\\n// res3: Int = 31220910\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><h1 id=\"spinlock\">Spinlock</h1>\n<p>A solution for <a href=\"http://adventofcode.com/2017/day/17\">Advent of Code 2017 - Day 17</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>For part one it was mostly just building a vector one element at at time.</p>\n<pre><code class=\"language-scala\">def spin(iterations:Int,\n         step: Int,\n         pos: Int = 0,\n         buffer: Vector[Int] = Vector(0),\n         current: Int = 0): (Int, Vector[Int]) = (\n  if(current == iterations) (pos, buffer)\n  else {\n    val splitPos = ((pos + step) % buffer.length) + 1\n    val (pre, post) = buffer.splitAt(splitPos)\n    spin(iterations,step,splitPos, pre ++ Vector(current + 1) ++ post, current + 1)\n  }\n)\n// spin: (iterations: Int, step: Int, pos: Int, buffer: Vector[Int], current: Int)(Int, Vector[Int])\n\ndef getSubsequentValue(target: Int, step:Int): Int = {\n  val (pos, buffer) = spin(target, step)\n  buffer((pos + 1) % buffer.length)\n}\n// getSubsequentValue: (target: Int, step: Int)Int\n</code></pre>\n<p>The walk-through did give a fairly large number of test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day17Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can spin buffer&quot;) {\n    spin(0, 3) shouldBe (0, Vector(0))\n    spin(1, 3) shouldBe (1, Vector(0,1))\n    spin(2, 3) shouldBe (1, Vector(0,2,1))\n    spin(3, 3) shouldBe (2, Vector(0,2,3,1))\n    spin(4, 3) shouldBe (2, Vector(0,2,4,3,1))\n    spin(5, 3) shouldBe (1, Vector(0,5,2,4,3,1))\n    spin(6, 3) shouldBe (5, Vector(0,5,2,4,3,6,1))\n    spin(7, 3) shouldBe (2, Vector(0,5,7,2,4,3,6,1))\n    spin(8, 3) shouldBe (6, Vector(0,5,7,2,4,3,8,6,1))\n    spin(9, 3) shouldBe (1, Vector(0,9,5,7,2,4,3,8,6,1))\n  }\n  \n  test(&quot;can determine following value&quot;) {\n    getSubsequentValue(0, 3) shouldBe 0\n    getSubsequentValue(1, 3) shouldBe 0\n    getSubsequentValue(2, 3) shouldBe 1\n    getSubsequentValue(3, 3) shouldBe 1\n    getSubsequentValue(4, 3) shouldBe 3\n    getSubsequentValue(5, 3) shouldBe 2\n    getSubsequentValue(6, 3) shouldBe 1\n    getSubsequentValue(7, 3) shouldBe 2\n    getSubsequentValue(8, 3) shouldBe 6\n    getSubsequentValue(9, 3) shouldBe 5\n\n    getSubsequentValue(2017, 3) shouldBe 638\n  }\n}\n// defined class Day17Part1Test\n\n(new Day17Part1Test).execute()\n// Day17Part1Test:\n// - can spin buffer\n// - can determine following value\n</code></pre>\n<p>This can then be run with the required step count for the puzzle.</p>\n<pre><code class=\"language-scala\">getSubsequentValue(2017, 337)\n// res1: Int = 600\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For part two it is not really feasible to build the full 50 million entry Vector. However as I'm just tracking the number after 0, all I need to keep track of is</p>\n<ul>\n<li>The current position of the 0 value, increments by one if a number would be   inserted at or before the current 0 value,</li>\n<li>The current value after 0, changes if the insertion position is exactly one  more than the current position.</li>\n<li>The current insertion position.</li>\n</ul>\n<pre><code class=\"language-scala\">def trackZero(iterations: Int,\n              step: Int,\n              currPos: Int = 0,\n              zeroPos: Int = 0,\n              valueAfterZero: Int = 0,\n              current: Int = 0): Int = (\n  if(current == iterations) valueAfterZero\n  else {\n    val newPos = \n      if(current == 0) 1 \n      else ((currPos + step) % (current + 1)) + 1\n    \n    trackZero(\n      iterations,\n      step,\n      newPos,\n      if(newPos &lt;= zeroPos) zeroPos + 1 else zeroPos,\n      if(newPos == zeroPos + 1) current + 1 else valueAfterZero,\n      current + 1\n    )\n  }\n)\n// trackZero: (iterations: Int, step: Int, currPos: Int, zeroPos: Int, valueAfterZero: Int, current: Int)Int\n</code></pre>\n<p>I can reuse the previous test cases and also the output from the first part<br>\ncan be used.</p>\n<pre><code class=\"language-scala\">class Day17Part2Test extends FunSuite with Matchers {\n\n  test(&quot;can track number after zero&quot;)\n  {\n    trackZero(0, 3) shouldBe 0\n    trackZero(1, 3) shouldBe 1\n    trackZero(2, 3) shouldBe 2\n    trackZero(3, 3) shouldBe 2\n    trackZero(4, 3) shouldBe 2\n    trackZero(5, 3) shouldBe 5\n    trackZero(6, 3) shouldBe 5\n    trackZero(7, 3) shouldBe 5\n    trackZero(8, 3) shouldBe 5\n    trackZero(9, 3) shouldBe 9\n\n    val (_, buffer) = spin(2017, 3)\n\n    trackZero(2017, 3) shouldBe buffer(buffer.indexOf(0) + 1)\n  }\n}\n// defined class Day17Part2Test\n\n(new Day17Part2Test).execute()\n// Day17Part2Test:\n// - can track number after zero\n</code></pre>\n<p>And now I'm able to complete the puzzle</p>\n<pre><code class=\"language-scala\">trackZero(50000000, 337)\n// res3: Int = 31220910\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a3ee0de9c9605113d0a49df","plaintext":"Spinlock\nA solution for Advent of Code 2017 - Day 17\n[http://adventofcode.com/2017/day/17]\n\nPart 1\nFor part one it was mostly just building a vector one element at at time.\n\ndef spin(iterations:Int,\n         step: Int,\n         pos: Int = 0,\n         buffer: Vector[Int] = Vector(0),\n         current: Int = 0): (Int, Vector[Int]) = (\n  if(current == iterations) (pos, buffer)\n  else {\n    val splitPos = ((pos + step) % buffer.length) + 1\n    val (pre, post) = buffer.splitAt(splitPos)\n    spin(iterations,step,splitPos, pre ++ Vector(current + 1) ++ post, current + 1)\n  }\n)\n// spin: (iterations: Int, step: Int, pos: Int, buffer: Vector[Int], current: Int)(Int, Vector[Int])\n\ndef getSubsequentValue(target: Int, step:Int): Int = {\n  val (pos, buffer) = spin(target, step)\n  buffer((pos + 1) % buffer.length)\n}\n// getSubsequentValue: (target: Int, step: Int)Int\n\n\nThe walk-through did give a fairly large number of test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day17Part1Test extends FunSuite with Matchers {\n\n  test(\"can spin buffer\") {\n    spin(0, 3) shouldBe (0, Vector(0))\n    spin(1, 3) shouldBe (1, Vector(0,1))\n    spin(2, 3) shouldBe (1, Vector(0,2,1))\n    spin(3, 3) shouldBe (2, Vector(0,2,3,1))\n    spin(4, 3) shouldBe (2, Vector(0,2,4,3,1))\n    spin(5, 3) shouldBe (1, Vector(0,5,2,4,3,1))\n    spin(6, 3) shouldBe (5, Vector(0,5,2,4,3,6,1))\n    spin(7, 3) shouldBe (2, Vector(0,5,7,2,4,3,6,1))\n    spin(8, 3) shouldBe (6, Vector(0,5,7,2,4,3,8,6,1))\n    spin(9, 3) shouldBe (1, Vector(0,9,5,7,2,4,3,8,6,1))\n  }\n  \n  test(\"can determine following value\") {\n    getSubsequentValue(0, 3) shouldBe 0\n    getSubsequentValue(1, 3) shouldBe 0\n    getSubsequentValue(2, 3) shouldBe 1\n    getSubsequentValue(3, 3) shouldBe 1\n    getSubsequentValue(4, 3) shouldBe 3\n    getSubsequentValue(5, 3) shouldBe 2\n    getSubsequentValue(6, 3) shouldBe 1\n    getSubsequentValue(7, 3) shouldBe 2\n    getSubsequentValue(8, 3) shouldBe 6\n    getSubsequentValue(9, 3) shouldBe 5\n\n    getSubsequentValue(2017, 3) shouldBe 638\n  }\n}\n// defined class Day17Part1Test\n\n(new Day17Part1Test).execute()\n// Day17Part1Test:\n// - can spin buffer\n// - can determine following value\n\n\nThis can then be run with the required step count for the puzzle.\n\ngetSubsequentValue(2017, 337)\n// res1: Int = 600\n\n\nPart 2\nFor part two it is not really feasible to build the full 50 million entry\nVector. However as I'm just tracking the number after 0, all I need to keep\ntrack of is\n\n * The current position of the 0 value, increments by one if a number would be\n   inserted at or before the current 0 value,\n * The current value after 0, changes if the insertion position is exactly one\n   more than the current position.\n * The current insertion position.\n\ndef trackZero(iterations: Int,\n              step: Int,\n              currPos: Int = 0,\n              zeroPos: Int = 0,\n              valueAfterZero: Int = 0,\n              current: Int = 0): Int = (\n  if(current == iterations) valueAfterZero\n  else {\n    val newPos = \n      if(current == 0) 1 \n      else ((currPos + step) % (current + 1)) + 1\n    \n    trackZero(\n      iterations,\n      step,\n      newPos,\n      if(newPos <= zeroPos) zeroPos + 1 else zeroPos,\n      if(newPos == zeroPos + 1) current + 1 else valueAfterZero,\n      current + 1\n    )\n  }\n)\n// trackZero: (iterations: Int, step: Int, currPos: Int, zeroPos: Int, valueAfterZero: Int, current: Int)Int\n\n\nI can reuse the previous test cases and also the output from the first part\ncan be used.\n\nclass Day17Part2Test extends FunSuite with Matchers {\n\n  test(\"can track number after zero\")\n  {\n    trackZero(0, 3) shouldBe 0\n    trackZero(1, 3) shouldBe 1\n    trackZero(2, 3) shouldBe 2\n    trackZero(3, 3) shouldBe 2\n    trackZero(4, 3) shouldBe 2\n    trackZero(5, 3) shouldBe 5\n    trackZero(6, 3) shouldBe 5\n    trackZero(7, 3) shouldBe 5\n    trackZero(8, 3) shouldBe 5\n    trackZero(9, 3) shouldBe 9\n\n    val (_, buffer) = spin(2017, 3)\n\n    trackZero(2017, 3) shouldBe buffer(buffer.indexOf(0) + 1)\n  }\n}\n// defined class Day17Part2Test\n\n(new Day17Part2Test).execute()\n// Day17Part2Test:\n// - can track number after zero\n\n\nAnd now I'm able to complete the puzzle\n\ntrackZero(50000000, 337)\n// res3: Int = 31220910","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-20.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-23T23:03:58.000Z","updated_at":"2017-12-24T05:00:00.000Z","published_at":"2017-12-24T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 17","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a404d849c9605113d0a49e9","uuid":"11cd84e4-8fa0-4aae-9feb-d0438889241a","title":"Duet","slug":"aoc-2017-day-18-duet","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 18](http://adventofcode.com/2017/day/18)\\n\\n## Part 1\\n\\nToday is mostly parsing assembly-like instructions. I started with a way to represent an instruction, and also that the values can either be literal integers, or a reference to a labeled register.\\n\\n```scala\\nsealed trait Value {\\n  def getValue(registers: Map[Char, Long]): Long\\n}\\n// defined trait Value\\n\\ncase class Ref(register: Char) extends Value {\\n  override def getValue(registers: Map[Char, Long]): Long = registers.getOrElse(register, 0)\\n}\\n// defined class Ref\\n\\ncase class Literal(value: Long) extends Value {\\n  override def getValue(registers: Map[Char, Long]): Long = value\\n}\\n// defined class Literal\\n\\ncase object EmptyValue extends Value {\\n  override def getValue(registers: Map[Char, Long]): Long = throw new RuntimeException(\\\"Trying to get empty value\\\")\\n}\\n// defined object EmptyValue\\n\\ncase class Instruction(command: String, register: Char, value: Value)\\n// defined class Instruction\\n\\nval LineMatcher = \\\"(snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\\\\\\\d+)))?\\\".r\\n// LineMatcher: scala.util.matching.Regex = (snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\\\d+)))?\\n\\ndef instFromLine(line: String): Instruction = line match {\\n  case LineMatcher(c, r, ref, _) if ref != null =>\\n    Instruction(\\n      c,\\n      r.charAt(0),\\n      Ref(ref.charAt(0))\\n    )\\n  case LineMatcher(c, r, _, lit) if lit != null => Instruction(c, r.charAt(0), Literal(lit.toLong))\\n  case LineMatcher(c, r, _, _) => Instruction(c, r.charAt(0), EmptyValue)\\n  // This was quite a late bugfix. I hadn't realised that a literal could also be\\n  // in the first value position. I had intended to refactor the parsing to \\n  // handle this better, but day 23 gave me the opportunity to re-do similar\\n  // instruction parsing and so I left this as is.\\n  case \\\"jgz 1 3\\\" => Instruction(\\\"jmp\\\", 'z', Literal(3))\\n}\\n// instFromLine: (line: String)Instruction\\n\\ndef parseLines(lines: TraversableOnce[String]): Vector[Instruction] = lines.map(instFromLine).toVector\\n// parseLines: (lines: TraversableOnce[String])Vector[Instruction]\\n```\\n\\nRunning the program until the first `rcv` was just a case of matching against the instructions, and updating the registers, position, and latest `snd` value as appropriate until a valid `rcv` was reached.\\n\\n```scala\\ndef getRcv(program: Vector[Instruction]): Option[Long] = {\\n  def iter(registers: Map[Char, Long],\\n           position: Int,\\n           sent: Option[Long]): Option[Long] = (\\n    if (!program.isDefinedAt(position)) None\\n    else program(position) match {\\n      case Instruction(\\\"snd\\\", r, _) => iter(registers, position + 1, Some(registers(r)))\\n      case Instruction(\\\"set\\\", r, v) => iter(registers.updated(r, v.getValue(registers)), position + 1, sent)\\n      case Instruction(\\\"add\\\", r, v) => iter(registers.updated(r, registers(r) + v.getValue(registers)), position + 1, sent)\\n      case Instruction(\\\"mul\\\", r, v) => iter(registers.updated(r, registers(r) * v.getValue(registers)), position + 1, sent)\\n      case Instruction(\\\"mod\\\", r, v) => iter(registers.updated(r, registers(r) % v.getValue(registers)), position + 1, sent)\\n      case Instruction(\\\"jgz\\\", r, v) if registers(r) > 0 => iter(registers, position + v.getValue(registers).toInt, sent)\\n      case Instruction(\\\"jgz\\\", _, _) => iter(registers, position + 1, sent)\\n      case Instruction(\\\"rcv\\\", r, _) if registers(r) != 0 => sent\\n      case Instruction(\\\"rcv\\\", _, _) => iter(registers, position + 1, sent)\\n    }\\n  )\\n  iter(Map.empty.withDefaultValue(0), 0, None)\\n}\\n// getRcv: (program: Vector[Instruction])Option[Long]\\n```\\n\\nI can use the provided example to test my parsing and that the instructions are being run correctly.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day18Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"testInstFromLine\\\") {\\n    instFromLine(\\\"set a 1\\\") shouldBe Instruction(\\\"set\\\", 'a', Literal(1))\\n    instFromLine(\\\"add a 2\\\") shouldBe Instruction(\\\"add\\\", 'a', Literal(2))\\n    instFromLine(\\\"mul a a\\\") shouldBe Instruction(\\\"mul\\\", 'a', Ref('a'))\\n    instFromLine(\\\"mod a 5\\\") shouldBe Instruction(\\\"mod\\\", 'a', Literal(5))\\n    instFromLine(\\\"snd a\\\") shouldBe Instruction(\\\"snd\\\", 'a', EmptyValue)\\n    instFromLine(\\\"set a 0\\\") shouldBe Instruction(\\\"set\\\", 'a', Literal(0))\\n    instFromLine(\\\"rcv a\\\") shouldBe Instruction(\\\"rcv\\\", 'a', EmptyValue)\\n    instFromLine(\\\"jgz a -1\\\") shouldBe Instruction(\\\"jgz\\\", 'a', Literal(-1))\\n    instFromLine(\\\"set a 1\\\") shouldBe Instruction(\\\"set\\\", 'a', Literal(1))\\n    instFromLine(\\\"jgz a -2\\\") shouldBe Instruction(\\\"jgz\\\", 'a', Literal(-2))\\n  }\\n\\n  test(\\\"testParseLines\\\") {\\n    parseLines(\\n      \\\"\\\"\\\"set a 1\\n        |add a 2\\n        |mul a a\\n        |mod a 5\\n        |snd a\\n        |set a 0\\n        |rcv a\\n        |jgz a -1\\n        |set a 1\\n        |jgz a -2\\\"\\\"\\\".stripMargin.lines\\n    ) shouldBe Vector(\\n      Instruction(\\\"set\\\", 'a', Literal(1)),\\n      Instruction(\\\"add\\\", 'a', Literal(2)),\\n      Instruction(\\\"mul\\\", 'a', Ref('a')),\\n      Instruction(\\\"mod\\\", 'a', Literal(5)),\\n      Instruction(\\\"snd\\\", 'a', EmptyValue),\\n      Instruction(\\\"set\\\", 'a', Literal(0)),\\n      Instruction(\\\"rcv\\\", 'a', EmptyValue),\\n      Instruction(\\\"jgz\\\", 'a', Literal(-1)),\\n      Instruction(\\\"set\\\", 'a', Literal(1)),\\n      Instruction(\\\"jgz\\\", 'a', Literal(-2))\\n    )\\n  }\\n\\n  test(\\\"findRcv\\\") {\\n    getRcv(Vector(\\n      Instruction(\\\"set\\\", 'a', Literal(1)),\\n      Instruction(\\\"add\\\", 'a', Literal(2)),\\n      Instruction(\\\"mul\\\", 'a', Ref('a')),\\n      Instruction(\\\"mod\\\", 'a', Literal(5)),\\n      Instruction(\\\"snd\\\", 'a', EmptyValue),\\n      Instruction(\\\"set\\\", 'a', Literal(0)),\\n      Instruction(\\\"rcv\\\", 'a', EmptyValue),\\n      Instruction(\\\"jgz\\\", 'a', Literal(-1)),\\n      Instruction(\\\"set\\\", 'a', Literal(1)),\\n      Instruction(\\\"jgz\\\", 'a', Literal(-2))\\n    )) shouldBe Some(4)\\n  }\\n}\\n// defined class Day18Part1Test\\n\\n(new Day18Part1Test).execute()\\n// Day18Part1Test:\\n// - testInstFromLine\\n// - testParseLines\\n// - findRcv\\n```\\n\\nThat all seems to be working, I can now run the puzzle program and get the first `rcv`'d value.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval program = parseLines(Source.fromResource(\\\"day18input.txt\\\").getLines())\\n// program: Vector[Instruction] = Vector(Instruction(set,i,Literal(31)), Instruction(set,a,Literal(1)), Instruction(mul,p,Literal(17)), Instruction(jgz,p,Ref(p)), Instruction(mul,a,Literal(2)), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-2)), Instruction(add,a,Literal(-1)), Instruction(set,i,Literal(127)), Instruction(set,p,Literal(622)), Instruction(mul,p,Literal(8505)), Instruction(mod,p,Ref(a)), Instruction(mul,p,Literal(129749)), Instruction(add,p,Literal(12345)), Instruction(mod,p,Ref(a)), Instruction(set,b,Ref(p)), Instruction(mod,b,Literal(10000)), Instruction(snd,b,EmptyValue), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-9)), Instruction(jgz,a,Literal(3)), Instruction(rcv,b,EmptyValue), Instruction(jgz,b,Literal(-1)), Instruction(set,f,Literal(0)), Ins...\\n\\ngetRcv(program)\\n// res1: Option[Long] = Some(9423)\\n```\\n\\n## Part 2\\n\\nFor part two I need to implement some form of concurrency. I eventually opted for running each process in turn until a `rcv` was encountered for which there was no input, storing a buffer of `snd` values as it ran. That buffer could then be sent the other process which would run until it had exhausted it and so on.\\n\\nIf either terminated, the other was run until it was out of inputs. If a program sent nothing and the other was waiting for input, both were also considered terminated.\\n\\nWhen handing over control I was also needed to keep track of where the next value needed to be stored if it was sent.\\n\\n```scala\\ncase class Prog(label: String,\\n                registers: Map[Char, Long],\\n                position: Int,\\n                sentCount: Int = 0,\\n                term: Boolean = false,\\n                target: Option[Char] = None)\\n// defined class Prog\\n\\ndef runConcurrent(program: Vector[Instruction]): Int  = {\\n  def runUntilRecv(prog: Prog, incoming: Seq[Long], outgoing: Seq[Long]): (Prog, Seq[Long]) =\\n    if (prog.term || !program.isDefinedAt(prog.position)) (prog.copy(term = true), outgoing)\\n    else program(prog.position) match {\\n      case Instruction(\\\"snd\\\", r, _) =>\\n        runUntilRecv(\\n          prog.copy(\\n            position = prog.position + 1,\\n            sentCount = prog.sentCount + 1\\n          ),\\n          incoming,\\n          outgoing :+ prog.registers(r)\\n        )\\n      case Instruction(\\\"set\\\", r, v) =>\\n        runUntilRecv(\\n          prog.copy(\\n            registers = prog.registers.updated(r, v.getValue(prog.registers)),\\n            position = prog.position + 1\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"add\\\", r, v) =>\\n        runUntilRecv(\\n          prog.copy(\\n            registers = prog.registers.updated(r, prog.registers(r) + v.getValue(prog.registers)),\\n            position = prog.position + 1\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"mul\\\", r, v) =>\\n        runUntilRecv(\\n          prog.copy(\\n            registers = prog.registers.updated(r, prog.registers(r) * v.getValue(prog.registers)),\\n            position = prog.position + 1\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"mod\\\", r, v) =>\\n        runUntilRecv(\\n          prog.copy(\\n            registers = prog.registers.updated(r, prog.registers(r) % v.getValue(prog.registers)),\\n            position = prog.position + 1\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"jgz\\\", r, v) if prog.registers(r) > 0 =>\\n        runUntilRecv(\\n          prog.copy(\\n            position = prog.position + v.getValue(prog.registers).toInt\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"jgz\\\", _, _) =>\\n        runUntilRecv(\\n          prog.copy(\\n            position = prog.position + 1\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"jmp\\\", _, i) =>\\n        runUntilRecv(\\n          prog.copy(\\n            position = prog.position + i.getValue(prog.registers).toInt\\n          ),\\n          incoming,\\n          outgoing\\n        )\\n      case Instruction(\\\"rcv\\\", r, _) =>\\n        incoming match {\\n          case i +: is => runUntilRecv(\\n            prog.copy(\\n              registers = prog.registers.updated(r, i),\\n              position = prog.position + 1\\n            ),\\n            is,\\n            outgoing\\n          )\\n          case Nil => (prog.copy(target = Some(r), position = prog.position + 1), outgoing)\\n        }\\n    }\\n\\n  def iter(p0: Prog, p1: Prog, incoming: Seq[Long]): (Prog, Prog) = {\\n    if (incoming == Nil && p0.target.isDefined) (p0, p1)\\n    else {\\n      val (newP0, outgoing) = incoming match {\\n        case i +: is if p0.target.isDefined => runUntilRecv(\\n          p0.copy(\\n            registers = p0.registers.updated(p0.target.get, i),\\n            target = None\\n          ),\\n          is,\\n          Nil\\n        )\\n        case is => runUntilRecv(p0, is, Nil)\\n      }\\n\\n      iter(p1, newP0, outgoing)\\n    }\\n  }\\n\\n  val (pa, pb) = iter(\\n    Prog(\\\"Prog 0\\\", Map('p' -> 0l).withDefaultValue(0), 0),\\n    Prog(\\\"Prog 1\\\", Map('p' -> 1l).withDefaultValue(0), 0),\\n    Nil\\n  )\\n\\n  val p1 = if(pa.label == \\\"Prog 1\\\") pa else pb\\n\\n  p1.sentCount\\n}\\n// runConcurrent: (program: Vector[Instruction])Int\\n```\\n\\nThis can be tested with a variant of the simple example given. This was changed because I wasn't setup to parse literals in the first value position, but achieving the same effect.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day18Part2Test extends FunSuite with Matchers {\\n  test(\\\"run concurrent\\\") {\\n    runConcurrent(Vector(\\n      Instruction(\\\"snd\\\", 'p', EmptyValue),\\n      Instruction(\\\"snd\\\", 'p', EmptyValue),\\n      Instruction(\\\"snd\\\", 'p', EmptyValue),\\n      Instruction(\\\"rcv\\\", 'a', EmptyValue),\\n      Instruction(\\\"rcv\\\", 'b', EmptyValue),\\n      Instruction(\\\"rcv\\\", 'c', EmptyValue),\\n      Instruction(\\\"rcv\\\", 'd', EmptyValue)\\n    )) shouldBe 3\\n  }\\n}\\n// defined class Day18Part2Test\\n\\n(new Day18Part2Test).execute()\\n// Day18Part2Test:\\n// - run concurrent\\n```\\n\\nThe program can then be run concurrently to find the second puzzle answer\\n\\n```scala\\nrunConcurrent(program)\\n// res3: Int = 7620\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/18\">Advent of Code 2017 - Day 18</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today is mostly parsing assembly-like instructions. I started with a way to represent an instruction, and also that the values can either be literal integers, or a reference to a labeled register.</p>\n<pre><code class=\"language-scala\">sealed trait Value {\n  def getValue(registers: Map[Char, Long]): Long\n}\n// defined trait Value\n\ncase class Ref(register: Char) extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = registers.getOrElse(register, 0)\n}\n// defined class Ref\n\ncase class Literal(value: Long) extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = value\n}\n// defined class Literal\n\ncase object EmptyValue extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = throw new RuntimeException(&quot;Trying to get empty value&quot;)\n}\n// defined object EmptyValue\n\ncase class Instruction(command: String, register: Char, value: Value)\n// defined class Instruction\n\nval LineMatcher = &quot;(snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\\\d+)))?&quot;.r\n// LineMatcher: scala.util.matching.Regex = (snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\d+)))?\n\ndef instFromLine(line: String): Instruction = line match {\n  case LineMatcher(c, r, ref, _) if ref != null =&gt;\n    Instruction(\n      c,\n      r.charAt(0),\n      Ref(ref.charAt(0))\n    )\n  case LineMatcher(c, r, _, lit) if lit != null =&gt; Instruction(c, r.charAt(0), Literal(lit.toLong))\n  case LineMatcher(c, r, _, _) =&gt; Instruction(c, r.charAt(0), EmptyValue)\n  // This was quite a late bugfix. I hadn't realised that a literal could also be\n  // in the first value position. I had intended to refactor the parsing to \n  // handle this better, but day 23 gave me the opportunity to re-do similar\n  // instruction parsing and so I left this as is.\n  case &quot;jgz 1 3&quot; =&gt; Instruction(&quot;jmp&quot;, 'z', Literal(3))\n}\n// instFromLine: (line: String)Instruction\n\ndef parseLines(lines: TraversableOnce[String]): Vector[Instruction] = lines.map(instFromLine).toVector\n// parseLines: (lines: TraversableOnce[String])Vector[Instruction]\n</code></pre>\n<p>Running the program until the first <code>rcv</code> was just a case of matching against the instructions, and updating the registers, position, and latest <code>snd</code> value as appropriate until a valid <code>rcv</code> was reached.</p>\n<pre><code class=\"language-scala\">def getRcv(program: Vector[Instruction]): Option[Long] = {\n  def iter(registers: Map[Char, Long],\n           position: Int,\n           sent: Option[Long]): Option[Long] = (\n    if (!program.isDefinedAt(position)) None\n    else program(position) match {\n      case Instruction(&quot;snd&quot;, r, _) =&gt; iter(registers, position + 1, Some(registers(r)))\n      case Instruction(&quot;set&quot;, r, v) =&gt; iter(registers.updated(r, v.getValue(registers)), position + 1, sent)\n      case Instruction(&quot;add&quot;, r, v) =&gt; iter(registers.updated(r, registers(r) + v.getValue(registers)), position + 1, sent)\n      case Instruction(&quot;mul&quot;, r, v) =&gt; iter(registers.updated(r, registers(r) * v.getValue(registers)), position + 1, sent)\n      case Instruction(&quot;mod&quot;, r, v) =&gt; iter(registers.updated(r, registers(r) % v.getValue(registers)), position + 1, sent)\n      case Instruction(&quot;jgz&quot;, r, v) if registers(r) &gt; 0 =&gt; iter(registers, position + v.getValue(registers).toInt, sent)\n      case Instruction(&quot;jgz&quot;, _, _) =&gt; iter(registers, position + 1, sent)\n      case Instruction(&quot;rcv&quot;, r, _) if registers(r) != 0 =&gt; sent\n      case Instruction(&quot;rcv&quot;, _, _) =&gt; iter(registers, position + 1, sent)\n    }\n  )\n  iter(Map.empty.withDefaultValue(0), 0, None)\n}\n// getRcv: (program: Vector[Instruction])Option[Long]\n</code></pre>\n<p>I can use the provided example to test my parsing and that the instructions are being run correctly.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day18Part1Test extends FunSuite with Matchers {\n\n  test(&quot;testInstFromLine&quot;) {\n    instFromLine(&quot;set a 1&quot;) shouldBe Instruction(&quot;set&quot;, 'a', Literal(1))\n    instFromLine(&quot;add a 2&quot;) shouldBe Instruction(&quot;add&quot;, 'a', Literal(2))\n    instFromLine(&quot;mul a a&quot;) shouldBe Instruction(&quot;mul&quot;, 'a', Ref('a'))\n    instFromLine(&quot;mod a 5&quot;) shouldBe Instruction(&quot;mod&quot;, 'a', Literal(5))\n    instFromLine(&quot;snd a&quot;) shouldBe Instruction(&quot;snd&quot;, 'a', EmptyValue)\n    instFromLine(&quot;set a 0&quot;) shouldBe Instruction(&quot;set&quot;, 'a', Literal(0))\n    instFromLine(&quot;rcv a&quot;) shouldBe Instruction(&quot;rcv&quot;, 'a', EmptyValue)\n    instFromLine(&quot;jgz a -1&quot;) shouldBe Instruction(&quot;jgz&quot;, 'a', Literal(-1))\n    instFromLine(&quot;set a 1&quot;) shouldBe Instruction(&quot;set&quot;, 'a', Literal(1))\n    instFromLine(&quot;jgz a -2&quot;) shouldBe Instruction(&quot;jgz&quot;, 'a', Literal(-2))\n  }\n\n  test(&quot;testParseLines&quot;) {\n    parseLines(\n      &quot;&quot;&quot;set a 1\n        |add a 2\n        |mul a a\n        |mod a 5\n        |snd a\n        |set a 0\n        |rcv a\n        |jgz a -1\n        |set a 1\n        |jgz a -2&quot;&quot;&quot;.stripMargin.lines\n    ) shouldBe Vector(\n      Instruction(&quot;set&quot;, 'a', Literal(1)),\n      Instruction(&quot;add&quot;, 'a', Literal(2)),\n      Instruction(&quot;mul&quot;, 'a', Ref('a')),\n      Instruction(&quot;mod&quot;, 'a', Literal(5)),\n      Instruction(&quot;snd&quot;, 'a', EmptyValue),\n      Instruction(&quot;set&quot;, 'a', Literal(0)),\n      Instruction(&quot;rcv&quot;, 'a', EmptyValue),\n      Instruction(&quot;jgz&quot;, 'a', Literal(-1)),\n      Instruction(&quot;set&quot;, 'a', Literal(1)),\n      Instruction(&quot;jgz&quot;, 'a', Literal(-2))\n    )\n  }\n\n  test(&quot;findRcv&quot;) {\n    getRcv(Vector(\n      Instruction(&quot;set&quot;, 'a', Literal(1)),\n      Instruction(&quot;add&quot;, 'a', Literal(2)),\n      Instruction(&quot;mul&quot;, 'a', Ref('a')),\n      Instruction(&quot;mod&quot;, 'a', Literal(5)),\n      Instruction(&quot;snd&quot;, 'a', EmptyValue),\n      Instruction(&quot;set&quot;, 'a', Literal(0)),\n      Instruction(&quot;rcv&quot;, 'a', EmptyValue),\n      Instruction(&quot;jgz&quot;, 'a', Literal(-1)),\n      Instruction(&quot;set&quot;, 'a', Literal(1)),\n      Instruction(&quot;jgz&quot;, 'a', Literal(-2))\n    )) shouldBe Some(4)\n  }\n}\n// defined class Day18Part1Test\n\n(new Day18Part1Test).execute()\n// Day18Part1Test:\n// - testInstFromLine\n// - testParseLines\n// - findRcv\n</code></pre>\n<p>That all seems to be working, I can now run the puzzle program and get the first <code>rcv</code>'d value.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval program = parseLines(Source.fromResource(&quot;day18input.txt&quot;).getLines())\n// program: Vector[Instruction] = Vector(Instruction(set,i,Literal(31)), Instruction(set,a,Literal(1)), Instruction(mul,p,Literal(17)), Instruction(jgz,p,Ref(p)), Instruction(mul,a,Literal(2)), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-2)), Instruction(add,a,Literal(-1)), Instruction(set,i,Literal(127)), Instruction(set,p,Literal(622)), Instruction(mul,p,Literal(8505)), Instruction(mod,p,Ref(a)), Instruction(mul,p,Literal(129749)), Instruction(add,p,Literal(12345)), Instruction(mod,p,Ref(a)), Instruction(set,b,Ref(p)), Instruction(mod,b,Literal(10000)), Instruction(snd,b,EmptyValue), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-9)), Instruction(jgz,a,Literal(3)), Instruction(rcv,b,EmptyValue), Instruction(jgz,b,Literal(-1)), Instruction(set,f,Literal(0)), Ins...\n\ngetRcv(program)\n// res1: Option[Long] = Some(9423)\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For part two I need to implement some form of concurrency. I eventually opted for running each process in turn until a <code>rcv</code> was encountered for which there was no input, storing a buffer of <code>snd</code> values as it ran. That buffer could then be sent the other process which would run until it had exhausted it and so on.</p>\n<p>If either terminated, the other was run until it was out of inputs. If a program sent nothing and the other was waiting for input, both were also considered terminated.</p>\n<p>When handing over control I was also needed to keep track of where the next value needed to be stored if it was sent.</p>\n<pre><code class=\"language-scala\">case class Prog(label: String,\n                registers: Map[Char, Long],\n                position: Int,\n                sentCount: Int = 0,\n                term: Boolean = false,\n                target: Option[Char] = None)\n// defined class Prog\n\ndef runConcurrent(program: Vector[Instruction]): Int  = {\n  def runUntilRecv(prog: Prog, incoming: Seq[Long], outgoing: Seq[Long]): (Prog, Seq[Long]) =\n    if (prog.term || !program.isDefinedAt(prog.position)) (prog.copy(term = true), outgoing)\n    else program(prog.position) match {\n      case Instruction(&quot;snd&quot;, r, _) =&gt;\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + 1,\n            sentCount = prog.sentCount + 1\n          ),\n          incoming,\n          outgoing :+ prog.registers(r)\n        )\n      case Instruction(&quot;set&quot;, r, v) =&gt;\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;add&quot;, r, v) =&gt;\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) + v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;mul&quot;, r, v) =&gt;\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) * v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;mod&quot;, r, v) =&gt;\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) % v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;jgz&quot;, r, v) if prog.registers(r) &gt; 0 =&gt;\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + v.getValue(prog.registers).toInt\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;jgz&quot;, _, _) =&gt;\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;jmp&quot;, _, i) =&gt;\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + i.getValue(prog.registers).toInt\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(&quot;rcv&quot;, r, _) =&gt;\n        incoming match {\n          case i +: is =&gt; runUntilRecv(\n            prog.copy(\n              registers = prog.registers.updated(r, i),\n              position = prog.position + 1\n            ),\n            is,\n            outgoing\n          )\n          case Nil =&gt; (prog.copy(target = Some(r), position = prog.position + 1), outgoing)\n        }\n    }\n\n  def iter(p0: Prog, p1: Prog, incoming: Seq[Long]): (Prog, Prog) = {\n    if (incoming == Nil &amp;&amp; p0.target.isDefined) (p0, p1)\n    else {\n      val (newP0, outgoing) = incoming match {\n        case i +: is if p0.target.isDefined =&gt; runUntilRecv(\n          p0.copy(\n            registers = p0.registers.updated(p0.target.get, i),\n            target = None\n          ),\n          is,\n          Nil\n        )\n        case is =&gt; runUntilRecv(p0, is, Nil)\n      }\n\n      iter(p1, newP0, outgoing)\n    }\n  }\n\n  val (pa, pb) = iter(\n    Prog(&quot;Prog 0&quot;, Map('p' -&gt; 0l).withDefaultValue(0), 0),\n    Prog(&quot;Prog 1&quot;, Map('p' -&gt; 1l).withDefaultValue(0), 0),\n    Nil\n  )\n\n  val p1 = if(pa.label == &quot;Prog 1&quot;) pa else pb\n\n  p1.sentCount\n}\n// runConcurrent: (program: Vector[Instruction])Int\n</code></pre>\n<p>This can be tested with a variant of the simple example given. This was changed because I wasn't setup to parse literals in the first value position, but achieving the same effect.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day18Part2Test extends FunSuite with Matchers {\n  test(&quot;run concurrent&quot;) {\n    runConcurrent(Vector(\n      Instruction(&quot;snd&quot;, 'p', EmptyValue),\n      Instruction(&quot;snd&quot;, 'p', EmptyValue),\n      Instruction(&quot;snd&quot;, 'p', EmptyValue),\n      Instruction(&quot;rcv&quot;, 'a', EmptyValue),\n      Instruction(&quot;rcv&quot;, 'b', EmptyValue),\n      Instruction(&quot;rcv&quot;, 'c', EmptyValue),\n      Instruction(&quot;rcv&quot;, 'd', EmptyValue)\n    )) shouldBe 3\n  }\n}\n// defined class Day18Part2Test\n\n(new Day18Part2Test).execute()\n// Day18Part2Test:\n// - run concurrent\n</code></pre>\n<p>The program can then be run concurrently to find the second puzzle answer</p>\n<pre><code class=\"language-scala\">runConcurrent(program)\n// res3: Int = 7620\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a404d849c9605113d0a49e9","plaintext":"A solution for Advent of Code 2017 - Day 18\n[http://adventofcode.com/2017/day/18]\n\nPart 1\nToday is mostly parsing assembly-like instructions. I started with a way to\nrepresent an instruction, and also that the values can either be literal\nintegers, or a reference to a labeled register.\n\nsealed trait Value {\n  def getValue(registers: Map[Char, Long]): Long\n}\n// defined trait Value\n\ncase class Ref(register: Char) extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = registers.getOrElse(register, 0)\n}\n// defined class Ref\n\ncase class Literal(value: Long) extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = value\n}\n// defined class Literal\n\ncase object EmptyValue extends Value {\n  override def getValue(registers: Map[Char, Long]): Long = throw new RuntimeException(\"Trying to get empty value\")\n}\n// defined object EmptyValue\n\ncase class Instruction(command: String, register: Char, value: Value)\n// defined class Instruction\n\nval LineMatcher = \"(snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\\\d+)))?\".r\n// LineMatcher: scala.util.matching.Regex = (snd|set|add|mul|mod|rcv|jgz) ([a-z])(?: (?:([a-z])|(-?\\d+)))?\n\ndef instFromLine(line: String): Instruction = line match {\n  case LineMatcher(c, r, ref, _) if ref != null =>\n    Instruction(\n      c,\n      r.charAt(0),\n      Ref(ref.charAt(0))\n    )\n  case LineMatcher(c, r, _, lit) if lit != null => Instruction(c, r.charAt(0), Literal(lit.toLong))\n  case LineMatcher(c, r, _, _) => Instruction(c, r.charAt(0), EmptyValue)\n  // This was quite a late bugfix. I hadn't realised that a literal could also be\n  // in the first value position. I had intended to refactor the parsing to \n  // handle this better, but day 23 gave me the opportunity to re-do similar\n  // instruction parsing and so I left this as is.\n  case \"jgz 1 3\" => Instruction(\"jmp\", 'z', Literal(3))\n}\n// instFromLine: (line: String)Instruction\n\ndef parseLines(lines: TraversableOnce[String]): Vector[Instruction] = lines.map(instFromLine).toVector\n// parseLines: (lines: TraversableOnce[String])Vector[Instruction]\n\n\nRunning the program until the first rcv was just a case of matching against the\ninstructions, and updating the registers, position, and latest snd value as\nappropriate until a valid rcv was reached.\n\ndef getRcv(program: Vector[Instruction]): Option[Long] = {\n  def iter(registers: Map[Char, Long],\n           position: Int,\n           sent: Option[Long]): Option[Long] = (\n    if (!program.isDefinedAt(position)) None\n    else program(position) match {\n      case Instruction(\"snd\", r, _) => iter(registers, position + 1, Some(registers(r)))\n      case Instruction(\"set\", r, v) => iter(registers.updated(r, v.getValue(registers)), position + 1, sent)\n      case Instruction(\"add\", r, v) => iter(registers.updated(r, registers(r) + v.getValue(registers)), position + 1, sent)\n      case Instruction(\"mul\", r, v) => iter(registers.updated(r, registers(r) * v.getValue(registers)), position + 1, sent)\n      case Instruction(\"mod\", r, v) => iter(registers.updated(r, registers(r) % v.getValue(registers)), position + 1, sent)\n      case Instruction(\"jgz\", r, v) if registers(r) > 0 => iter(registers, position + v.getValue(registers).toInt, sent)\n      case Instruction(\"jgz\", _, _) => iter(registers, position + 1, sent)\n      case Instruction(\"rcv\", r, _) if registers(r) != 0 => sent\n      case Instruction(\"rcv\", _, _) => iter(registers, position + 1, sent)\n    }\n  )\n  iter(Map.empty.withDefaultValue(0), 0, None)\n}\n// getRcv: (program: Vector[Instruction])Option[Long]\n\n\nI can use the provided example to test my parsing and that the instructions are\nbeing run correctly.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day18Part1Test extends FunSuite with Matchers {\n\n  test(\"testInstFromLine\") {\n    instFromLine(\"set a 1\") shouldBe Instruction(\"set\", 'a', Literal(1))\n    instFromLine(\"add a 2\") shouldBe Instruction(\"add\", 'a', Literal(2))\n    instFromLine(\"mul a a\") shouldBe Instruction(\"mul\", 'a', Ref('a'))\n    instFromLine(\"mod a 5\") shouldBe Instruction(\"mod\", 'a', Literal(5))\n    instFromLine(\"snd a\") shouldBe Instruction(\"snd\", 'a', EmptyValue)\n    instFromLine(\"set a 0\") shouldBe Instruction(\"set\", 'a', Literal(0))\n    instFromLine(\"rcv a\") shouldBe Instruction(\"rcv\", 'a', EmptyValue)\n    instFromLine(\"jgz a -1\") shouldBe Instruction(\"jgz\", 'a', Literal(-1))\n    instFromLine(\"set a 1\") shouldBe Instruction(\"set\", 'a', Literal(1))\n    instFromLine(\"jgz a -2\") shouldBe Instruction(\"jgz\", 'a', Literal(-2))\n  }\n\n  test(\"testParseLines\") {\n    parseLines(\n      \"\"\"set a 1\n        |add a 2\n        |mul a a\n        |mod a 5\n        |snd a\n        |set a 0\n        |rcv a\n        |jgz a -1\n        |set a 1\n        |jgz a -2\"\"\".stripMargin.lines\n    ) shouldBe Vector(\n      Instruction(\"set\", 'a', Literal(1)),\n      Instruction(\"add\", 'a', Literal(2)),\n      Instruction(\"mul\", 'a', Ref('a')),\n      Instruction(\"mod\", 'a', Literal(5)),\n      Instruction(\"snd\", 'a', EmptyValue),\n      Instruction(\"set\", 'a', Literal(0)),\n      Instruction(\"rcv\", 'a', EmptyValue),\n      Instruction(\"jgz\", 'a', Literal(-1)),\n      Instruction(\"set\", 'a', Literal(1)),\n      Instruction(\"jgz\", 'a', Literal(-2))\n    )\n  }\n\n  test(\"findRcv\") {\n    getRcv(Vector(\n      Instruction(\"set\", 'a', Literal(1)),\n      Instruction(\"add\", 'a', Literal(2)),\n      Instruction(\"mul\", 'a', Ref('a')),\n      Instruction(\"mod\", 'a', Literal(5)),\n      Instruction(\"snd\", 'a', EmptyValue),\n      Instruction(\"set\", 'a', Literal(0)),\n      Instruction(\"rcv\", 'a', EmptyValue),\n      Instruction(\"jgz\", 'a', Literal(-1)),\n      Instruction(\"set\", 'a', Literal(1)),\n      Instruction(\"jgz\", 'a', Literal(-2))\n    )) shouldBe Some(4)\n  }\n}\n// defined class Day18Part1Test\n\n(new Day18Part1Test).execute()\n// Day18Part1Test:\n// - testInstFromLine\n// - testParseLines\n// - findRcv\n\n\nThat all seems to be working, I can now run the puzzle program and get the first \nrcv'd value.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval program = parseLines(Source.fromResource(\"day18input.txt\").getLines())\n// program: Vector[Instruction] = Vector(Instruction(set,i,Literal(31)), Instruction(set,a,Literal(1)), Instruction(mul,p,Literal(17)), Instruction(jgz,p,Ref(p)), Instruction(mul,a,Literal(2)), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-2)), Instruction(add,a,Literal(-1)), Instruction(set,i,Literal(127)), Instruction(set,p,Literal(622)), Instruction(mul,p,Literal(8505)), Instruction(mod,p,Ref(a)), Instruction(mul,p,Literal(129749)), Instruction(add,p,Literal(12345)), Instruction(mod,p,Ref(a)), Instruction(set,b,Ref(p)), Instruction(mod,b,Literal(10000)), Instruction(snd,b,EmptyValue), Instruction(add,i,Literal(-1)), Instruction(jgz,i,Literal(-9)), Instruction(jgz,a,Literal(3)), Instruction(rcv,b,EmptyValue), Instruction(jgz,b,Literal(-1)), Instruction(set,f,Literal(0)), Ins...\n\ngetRcv(program)\n// res1: Option[Long] = Some(9423)\n\n\nPart 2\nFor part two I need to implement some form of concurrency. I eventually opted\nfor running each process in turn until a rcv was encountered for which there was\nno input, storing a buffer of snd values as it ran. That buffer could then be\nsent the other process which would run until it had exhausted it and so on.\n\nIf either terminated, the other was run until it was out of inputs. If a program\nsent nothing and the other was waiting for input, both were also considered\nterminated.\n\nWhen handing over control I was also needed to keep track of where the next\nvalue needed to be stored if it was sent.\n\ncase class Prog(label: String,\n                registers: Map[Char, Long],\n                position: Int,\n                sentCount: Int = 0,\n                term: Boolean = false,\n                target: Option[Char] = None)\n// defined class Prog\n\ndef runConcurrent(program: Vector[Instruction]): Int  = {\n  def runUntilRecv(prog: Prog, incoming: Seq[Long], outgoing: Seq[Long]): (Prog, Seq[Long]) =\n    if (prog.term || !program.isDefinedAt(prog.position)) (prog.copy(term = true), outgoing)\n    else program(prog.position) match {\n      case Instruction(\"snd\", r, _) =>\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + 1,\n            sentCount = prog.sentCount + 1\n          ),\n          incoming,\n          outgoing :+ prog.registers(r)\n        )\n      case Instruction(\"set\", r, v) =>\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"add\", r, v) =>\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) + v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"mul\", r, v) =>\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) * v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"mod\", r, v) =>\n        runUntilRecv(\n          prog.copy(\n            registers = prog.registers.updated(r, prog.registers(r) % v.getValue(prog.registers)),\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"jgz\", r, v) if prog.registers(r) > 0 =>\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + v.getValue(prog.registers).toInt\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"jgz\", _, _) =>\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + 1\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"jmp\", _, i) =>\n        runUntilRecv(\n          prog.copy(\n            position = prog.position + i.getValue(prog.registers).toInt\n          ),\n          incoming,\n          outgoing\n        )\n      case Instruction(\"rcv\", r, _) =>\n        incoming match {\n          case i +: is => runUntilRecv(\n            prog.copy(\n              registers = prog.registers.updated(r, i),\n              position = prog.position + 1\n            ),\n            is,\n            outgoing\n          )\n          case Nil => (prog.copy(target = Some(r), position = prog.position + 1), outgoing)\n        }\n    }\n\n  def iter(p0: Prog, p1: Prog, incoming: Seq[Long]): (Prog, Prog) = {\n    if (incoming == Nil && p0.target.isDefined) (p0, p1)\n    else {\n      val (newP0, outgoing) = incoming match {\n        case i +: is if p0.target.isDefined => runUntilRecv(\n          p0.copy(\n            registers = p0.registers.updated(p0.target.get, i),\n            target = None\n          ),\n          is,\n          Nil\n        )\n        case is => runUntilRecv(p0, is, Nil)\n      }\n\n      iter(p1, newP0, outgoing)\n    }\n  }\n\n  val (pa, pb) = iter(\n    Prog(\"Prog 0\", Map('p' -> 0l).withDefaultValue(0), 0),\n    Prog(\"Prog 1\", Map('p' -> 1l).withDefaultValue(0), 0),\n    Nil\n  )\n\n  val p1 = if(pa.label == \"Prog 1\") pa else pb\n\n  p1.sentCount\n}\n// runConcurrent: (program: Vector[Instruction])Int\n\n\nThis can be tested with a variant of the simple example given. This was changed\nbecause I wasn't setup to parse literals in the first value position, but\nachieving the same effect.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day18Part2Test extends FunSuite with Matchers {\n  test(\"run concurrent\") {\n    runConcurrent(Vector(\n      Instruction(\"snd\", 'p', EmptyValue),\n      Instruction(\"snd\", 'p', EmptyValue),\n      Instruction(\"snd\", 'p', EmptyValue),\n      Instruction(\"rcv\", 'a', EmptyValue),\n      Instruction(\"rcv\", 'b', EmptyValue),\n      Instruction(\"rcv\", 'c', EmptyValue),\n      Instruction(\"rcv\", 'd', EmptyValue)\n    )) shouldBe 3\n  }\n}\n// defined class Day18Part2Test\n\n(new Day18Part2Test).execute()\n// Day18Part2Test:\n// - run concurrent\n\n\nThe program can then be run concurrently to find the second puzzle answer\n\nrunConcurrent(program)\n// res3: Int = 7620","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-21.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-25T00:59:48.000Z","updated_at":"2017-12-25T05:00:00.000Z","published_at":"2017-12-25T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 18","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a418a419c9605113d0a49f0","uuid":"8691914c-c1ed-4feb-8eea-5ccbeb0275d2","title":"A Series of Tubes","slug":"aoc-2017-day-19-a-series-of-tubes","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 19](http://adventofcode.com/2017/day/19)\\n\\n## Part 1\\n\\nSince all I needed was a grid of characters that I could access by index, then just parsing the input into a `Vector[String]` is good enough.\\n\\nTo find the answer, I need to find where the path starts and then follow it until the next step is not valid. For `-` and `|` I can just step forward, and disregarding which one I have seen means that the points where a line crosses are handled correctly. Letters are pretty much the same, but need to be recorded, finally only `+` can change direction, so on finding one we need to check all three possible next steps for a valid character.\\n\\n\\n```scala\\ndef findStart(grid: Vector[String]): Int = {\\n  grid(0).indexOf('|')\\n}\\n// findStart: (grid: Vector[String])Int\\n\\ndef findPath(grid: Vector[String]): (String, Int) = {\\n  def canTravel(x: Int, y: Int): Boolean =\\n    grid.isDefinedAt(y) &&\\n      grid(y).isDefinedAt(x) &&\\n      grid(y)(x) != ' '\\n\\n  def init(x: Int, y: Int, path: String, dx: Int, dy: Int, count: Int): (String, Int) =\\n    if (!canTravel(x, y))\\n      (path, count)\\n    else grid(y)(x) match {\\n      case '|' | '-' => init(x + dx, y + dy, path, dx, dy, count + 1)\\n      case '+' =>\\n        if (canTravel(x + dx, y + dy)) init(x + dx, y + dy, path, dx, dy, count + 1)\\n        else if (canTravel(x + dy, y + dx)) init(x + dy, y + dx, path, dy, dx, count + 1)\\n        else if (canTravel(x - dy, y - dx)) init(x - dy, y - dx, path, -dy, -dx, count + 1)\\n        else (path, count)\\n      case c => init(x + dx, y + dy, path + c, dx, dy, count + 1)\\n    }\\n\\n  init(findStart(grid), 0, \\\"\\\", 0, 1, 0)\\n}\\n// findPath: (grid: Vector[String])(String, Int)\\n```\\n\\nThere is a sample mini-grid provided which can be used to make test cases.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day19Part1Test extends FunSuite with Matchers {\\n\\n  private val testGrid =\\n    \\\"\\\"\\\"#     |\\n       #     |  +--+\\n       #     A  |  C\\n       # F---|----E|--+\\n       #     |  |  |  D\\n       #     +B-+  +--+\\\"\\\"\\\".stripMargin('#').lines.toVector\\n\\n  test(\\\"testFindStart\\\") {\\n    findStart(testGrid) shouldBe 5\\n  }\\n\\n  test(\\\"testFindPath\\\") {\\n    findPath(testGrid) shouldBe (\\\"ABCDEF\\\", 38)\\n  }\\n\\n}\\n// defined class Day19Part1Test\\n\\n(new Day19Part1Test).execute()\\n// Day19Part1Test:\\n// - testFindStart\\n// - testFindPath\\n```\\n\\nThis can then be run to get the answer.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval grid = Source.fromResource(\\\"day19input.txt\\\").getLines().toVector\\n// grid: Vector[String] = Vector(\\\"                                                                             |                                                                                                                           \\\", \\\"             +-------+       +-------+   +-+                                 | +-------------------------------------------+                   +---------------+     +-+ +---------------------------+   \\\", \\\"             |       |       |       |   | |                                 | |                                           |                   |               |     | | |                           |   \\\", \\\" +---------------------------+       |   | +---------------------------------|-|---------+   +---------------------------------------------------------...\\n\\nfindPath(grid)\\n// res1: (String, Int) = (XYFDJNRCQA,17450)\\n```\\n\\n## Part 2\\n\\nMy code for part one also outputs the path length, which answers this part. I wasn't quite so prescient to output that for part 1 just because, but it was such a simple change that I just updated my part one solution to output the value, and the test case to check it. \\n\\nPuzzle completed.\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/19\">Advent of Code 2017 - Day 19</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Since all I needed was a grid of characters that I could access by index, then just parsing the input into a <code>Vector[String]</code> is good enough.</p>\n<p>To find the answer, I need to find where the path starts and then follow it until the next step is not valid. For <code>-</code> and <code>|</code> I can just step forward, and disregarding which one I have seen means that the points where a line crosses are handled correctly. Letters are pretty much the same, but need to be recorded, finally only <code>+</code> can change direction, so on finding one we need to check all three possible next steps for a valid character.</p>\n<pre><code class=\"language-scala\">def findStart(grid: Vector[String]): Int = {\n  grid(0).indexOf('|')\n}\n// findStart: (grid: Vector[String])Int\n\ndef findPath(grid: Vector[String]): (String, Int) = {\n  def canTravel(x: Int, y: Int): Boolean =\n    grid.isDefinedAt(y) &amp;&amp;\n      grid(y).isDefinedAt(x) &amp;&amp;\n      grid(y)(x) != ' '\n\n  def init(x: Int, y: Int, path: String, dx: Int, dy: Int, count: Int): (String, Int) =\n    if (!canTravel(x, y))\n      (path, count)\n    else grid(y)(x) match {\n      case '|' | '-' =&gt; init(x + dx, y + dy, path, dx, dy, count + 1)\n      case '+' =&gt;\n        if (canTravel(x + dx, y + dy)) init(x + dx, y + dy, path, dx, dy, count + 1)\n        else if (canTravel(x + dy, y + dx)) init(x + dy, y + dx, path, dy, dx, count + 1)\n        else if (canTravel(x - dy, y - dx)) init(x - dy, y - dx, path, -dy, -dx, count + 1)\n        else (path, count)\n      case c =&gt; init(x + dx, y + dy, path + c, dx, dy, count + 1)\n    }\n\n  init(findStart(grid), 0, &quot;&quot;, 0, 1, 0)\n}\n// findPath: (grid: Vector[String])(String, Int)\n</code></pre>\n<p>There is a sample mini-grid provided which can be used to make test cases.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day19Part1Test extends FunSuite with Matchers {\n\n  private val testGrid =\n    &quot;&quot;&quot;#     |\n       #     |  +--+\n       #     A  |  C\n       # F---|----E|--+\n       #     |  |  |  D\n       #     +B-+  +--+&quot;&quot;&quot;.stripMargin('#').lines.toVector\n\n  test(&quot;testFindStart&quot;) {\n    findStart(testGrid) shouldBe 5\n  }\n\n  test(&quot;testFindPath&quot;) {\n    findPath(testGrid) shouldBe (&quot;ABCDEF&quot;, 38)\n  }\n\n}\n// defined class Day19Part1Test\n\n(new Day19Part1Test).execute()\n// Day19Part1Test:\n// - testFindStart\n// - testFindPath\n</code></pre>\n<p>This can then be run to get the answer.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval grid = Source.fromResource(&quot;day19input.txt&quot;).getLines().toVector\n// grid: Vector[String] = Vector(&quot;                                                                             |                                                                                                                           &quot;, &quot;             +-------+       +-------+   +-+                                 | +-------------------------------------------+                   +---------------+     +-+ +---------------------------+   &quot;, &quot;             |       |       |       |   | |                                 | |                                           |                   |               |     | | |                           |   &quot;, &quot; +---------------------------+       |   | +---------------------------------|-|---------+   +---------------------------------------------------------...\n\nfindPath(grid)\n// res1: (String, Int) = (XYFDJNRCQA,17450)\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>My code for part one also outputs the path length, which answers this part. I wasn't quite so prescient to output that for part 1 just because, but it was such a simple change that I just updated my part one solution to output the value, and the test case to check it.</p>\n<p>Puzzle completed.</p>\n<!--kg-card-end: markdown-->","comment_id":"5a418a419c9605113d0a49f0","plaintext":"A solution for Advent of Code 2017 - Day 19\n[http://adventofcode.com/2017/day/19]\n\nPart 1\nSince all I needed was a grid of characters that I could access by index, then\njust parsing the input into a Vector[String] is good enough.\n\nTo find the answer, I need to find where the path starts and then follow it\nuntil the next step is not valid. For - and | I can just step forward, and\ndisregarding which one I have seen means that the points where a line crosses\nare handled correctly. Letters are pretty much the same, but need to be\nrecorded, finally only + can change direction, so on finding one we need to\ncheck all three possible next steps for a valid character.\n\ndef findStart(grid: Vector[String]): Int = {\n  grid(0).indexOf('|')\n}\n// findStart: (grid: Vector[String])Int\n\ndef findPath(grid: Vector[String]): (String, Int) = {\n  def canTravel(x: Int, y: Int): Boolean =\n    grid.isDefinedAt(y) &&\n      grid(y).isDefinedAt(x) &&\n      grid(y)(x) != ' '\n\n  def init(x: Int, y: Int, path: String, dx: Int, dy: Int, count: Int): (String, Int) =\n    if (!canTravel(x, y))\n      (path, count)\n    else grid(y)(x) match {\n      case '|' | '-' => init(x + dx, y + dy, path, dx, dy, count + 1)\n      case '+' =>\n        if (canTravel(x + dx, y + dy)) init(x + dx, y + dy, path, dx, dy, count + 1)\n        else if (canTravel(x + dy, y + dx)) init(x + dy, y + dx, path, dy, dx, count + 1)\n        else if (canTravel(x - dy, y - dx)) init(x - dy, y - dx, path, -dy, -dx, count + 1)\n        else (path, count)\n      case c => init(x + dx, y + dy, path + c, dx, dy, count + 1)\n    }\n\n  init(findStart(grid), 0, \"\", 0, 1, 0)\n}\n// findPath: (grid: Vector[String])(String, Int)\n\n\nThere is a sample mini-grid provided which can be used to make test cases.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day19Part1Test extends FunSuite with Matchers {\n\n  private val testGrid =\n    \"\"\"#     |\n       #     |  +--+\n       #     A  |  C\n       # F---|----E|--+\n       #     |  |  |  D\n       #     +B-+  +--+\"\"\".stripMargin('#').lines.toVector\n\n  test(\"testFindStart\") {\n    findStart(testGrid) shouldBe 5\n  }\n\n  test(\"testFindPath\") {\n    findPath(testGrid) shouldBe (\"ABCDEF\", 38)\n  }\n\n}\n// defined class Day19Part1Test\n\n(new Day19Part1Test).execute()\n// Day19Part1Test:\n// - testFindStart\n// - testFindPath\n\n\nThis can then be run to get the answer.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval grid = Source.fromResource(\"day19input.txt\").getLines().toVector\n// grid: Vector[String] = Vector(\"                                                                             |                                                                                                                           \", \"             +-------+       +-------+   +-+                                 | +-------------------------------------------+                   +---------------+     +-+ +---------------------------+   \", \"             |       |       |       |   | |                                 | |                                           |                   |               |     | | |                           |   \", \" +---------------------------+       |   | +---------------------------------|-|---------+   +---------------------------------------------------------...\n\nfindPath(grid)\n// res1: (String, Int) = (XYFDJNRCQA,17450)\n\n\nPart 2\nMy code for part one also outputs the path length, which answers this part. I\nwasn't quite so prescient to output that for part 1 just because, but it was\nsuch a simple change that I just updated my part one solution to output the\nvalue, and the test case to check it.\n\nPuzzle completed.","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-22.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-25T23:31:13.000Z","updated_at":"2018-04-04T22:22:23.000Z","published_at":"2017-12-26T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 19","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a46ddb19c9605113d0a49f9","uuid":"2e4d3577-9809-4eec-9f84-323ec197c2f0","title":"Particle Swarm","slug":"aoc-2017-day-20-particle-swarm","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 20](http://adventofcode.com/2017/day/20)\\n\\n## Part 1\\n\\nFor starters with today's input I'm going to need to turn my puzzle input into something useful.\\n\\n```scala\\ncase class Coordinate(x: Long, y: Long, z: Long) {\\n  def +(that: Coordinate): Coordinate = copy(x = x + that.x, y = y + that.y, z = z + that.z)\\n  lazy val mag: Long = Math.abs(x) + Math.abs(y) + Math.abs(z)\\n}\\n// defined class Coordinate\\n\\ncase class Particle(index: Long, pos: Coordinate, vel: Coordinate, acc: Coordinate) {\\n  def next: Particle = copy(pos = pos + vel + acc, vel = vel + acc)\\n}\\n// defined class Particle\\n\\nval LineMatcher = \\\"p=<(-?\\\\\\\\d+),(-?\\\\\\\\d+),(-?\\\\\\\\d+)>, v=<(-?\\\\\\\\d+),(-?\\\\\\\\d+),(-?\\\\\\\\d+)>, a=<(-?\\\\\\\\d+),(-?\\\\\\\\d+),(-?\\\\\\\\d+)>\\\".r\\n// LineMatcher: scala.util.matching.Regex = p=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>, v=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>, a=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>\\n\\ndef parseLines(lines: TraversableOnce[String]): Seq[Particle] =\\n  lines.toSeq.zipWithIndex.collect {\\n    case (LineMatcher(px, py, pz, vx, vy, vz, ax, ay, az), i) => Particle(\\n      i,\\n      Coordinate(px.toLong, py.toLong, pz.toLong),\\n      Coordinate(vx.toLong, vy.toLong, vz.toLong),\\n      Coordinate(ax.toLong, ay.toLong, az.toLong)\\n    )\\n  }\\n// parseLines: (lines: TraversableOnce[String])Seq[Particle]\\n```\\n\\nGiven that in the limit, the closest particle is going to be among those with the least acceleration, my first idea is to sort the particles by that and see what the slowest look like.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = parseLines(Source.fromResource(\\\"day20input.txt\\\").getLines())\\n// input: Seq[Particle] = Stream(Particle(0,Coordinate(-11104,1791,5208),Coordinate(-6,36,-84),Coordinate(19,-5,-4)), ?)\\n\\nimplicit val coordinateOrder: Ordering[Coordinate] = Ordering.by(_.mag)\\n// coordinateOrder: Ordering[Coordinate] = scala.math.Ordering$$anon$10@1008febf\\n\\ninput.sortBy(_.acc).take(3).foreach(println)\\n// Particle(300,Coordinate(1585,1025,-980),Coordinate(-56,-35,35),Coordinate(0,0,0))\\n// Particle(74,Coordinate(863,3436,-1734),Coordinate(-28,-110,72),Coordinate(0,0,-1))\\n// Particle(172,Coordinate(-197,-954,-115),Coordinate(20,85,11),Coordinate(0,-1,0))\\n```\\n\\nWhich makes things easy as I can now just submit particle 300 as the answer.\\n\\nFirst I'll check my working:\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day20Part1Test extends FunSuite with Matchers {\\n  test(\\\"can parse lines\\\") {\\n    parseLines(\\n      \\\"\\\"\\\"p=<3,0,0>, v=<2,0,0>, a=<-1,0,0>\\n        |p=<4,0,0>, v=<0,0,0>, a=<-2,0,0>\\\"\\\"\\\".stripMargin.lines\\n    ) shouldBe Seq(\\n      Particle(\\n        0,\\n        Coordinate(3, 0, 0),\\n        Coordinate(2, 0, 0),\\n        Coordinate(-1, 0, 0)\\n      ),\\n      Particle(\\n        1,\\n        Coordinate(4, 0, 0),\\n        Coordinate(0, 0, 0),\\n        Coordinate(-2, 0, 0)\\n      )\\n    )\\n  }\\n\\n  test(\\\"coordinates can be ordered\\\") {\\n    Seq(\\n      Coordinate(0, -1, 0),\\n      Coordinate(0, -1, 3),\\n      Coordinate(2, 0, 0),\\n      Coordinate(0, 0, 0),\\n      Coordinate(1, -1, 1)\\n    ).sorted shouldBe Seq(\\n      Coordinate(0, 0, 0),\\n      Coordinate(0, -1, 0),\\n      Coordinate(2, 0, 0),\\n      Coordinate(1, -1, 1),\\n      Coordinate(0, -1, 3)\\n    )\\n  }\\n}\\n// defined class Day20Part1Test\\n\\n(new Day20Part1Test).execute()\\n// Day20Part1Test:\\n// - can parse lines\\n// - coordinates can be ordered\\n```\\n\\n## Part 2\\n\\nFor part two I think the best first step is just to run the simulation until the particle count is roughly stable. Technically I'll need to run it until all the particles are moving away from each other, but working that out will not be easy and probably unnecessary.\\n\\nDetermining the collisions is just a case of finding particles that share the same position as another, and filtering them out. I picked 1000 iterations of the particle count staying the same as a reasonable approximation of determining when the collisions were complete.\\n\\n```scala\\ndef countSurvivingParticles(particles: Seq[Particle], count: Long = 0, prevLength: Int = 0): Int = {\\n  val newParticles: Seq[Particle] =\\n    particles\\n      .groupBy(_.pos)\\n      .filter {case (_, ps) => ps.lengthCompare(1) == 0}\\n      .flatMap(_._2)\\n      .map(_.next)\\n      .toSeq\\n      \\n  if(count % 1000 == 0) {\\n    if(newParticles.lengthCompare(prevLength) == 0)\\n      newParticles.length\\n    else\\n      countSurvivingParticles(newParticles, count + 1, newParticles.length)\\n  }\\n  else countSurvivingParticles(newParticles, count + 1, prevLength)\\n} \\n// countSurvivingParticles: (particles: Seq[Particle], count: Long, prevLength: Int)Int\\n```\\n \\nI can use the example from the puzzle to provide a test case. I also still need\\nto write tests for advancing particles to the next state.\\n \\n```scala\\nclass Day20Part2Test extends FunSuite with Matchers {\\n  test(\\\"can step particles\\\") {\\n    Particle(\\n      0,\\n      Coordinate(3, 0, 0),\\n      Coordinate(2, 0, 0),\\n      Coordinate(-1, 0, 0)\\n    ).next shouldBe\\n      Particle(\\n        0,\\n        Coordinate(4, 0, 0),\\n        Coordinate(1, 0, 0),\\n        Coordinate(-1, 0, 0)\\n      )\\n  \\n    Particle(\\n      0,\\n      Coordinate(3, 0, 0),\\n      Coordinate(2, 0, 0),\\n      Coordinate(-1, 0, 0)\\n    ).next.next shouldBe\\n      Particle(\\n        0,\\n        Coordinate(4, 0, 0),\\n        Coordinate(0, 0, 0),\\n        Coordinate(-1, 0, 0)\\n      )\\n  \\n  \\n    Particle(\\n      1,\\n      Coordinate(4, 0, 0),\\n      Coordinate(0, 0, 0),\\n      Coordinate(-2, 0, 0)\\n    ).next shouldBe\\n      Particle(\\n        1,\\n        Coordinate(2, 0, 0),\\n        Coordinate(-2, 0, 0),\\n        Coordinate(-2, 0, 0)\\n      )\\n  }\\n  \\n  test(\\\"can collide particles\\\") {\\n    countSurvivingParticles(\\n      parseLines(\\n        \\\"\\\"\\\"p=<-6,0,0>, v=<3,0,0>, a=<0,0,0>\\n          |p=<-4,0,0>, v=<2,0,0>, a=<0,0,0>\\n          |p=<-2,0,0>, v=<1,0,0>, a=<0,0,0>\\n          |p=<3,0,0>, v=<-1,0,0>, a=<0,0,0>\\\"\\\"\\\".stripMargin.lines\\n      )\\n    ) shouldBe 1\\n  }\\n}\\n// defined class Day20Part2Test\\n\\n(new Day20Part2Test).execute()\\n// Day20Part2Test:\\n// - can step particles\\n// - can collide particles\\n```\\n\\nI can now run the simulation and try the answer. \\n\\n```scala\\ncountSurvivingParticles(input)\\n// res3: Int = 502\\n```\\n\\nSince that was counted as correct, I'll leave today there.\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/20\">Advent of Code 2017 - Day 20</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>For starters with today's input I'm going to need to turn my puzzle input into something useful.</p>\n<pre><code class=\"language-scala\">case class Coordinate(x: Long, y: Long, z: Long) {\n  def +(that: Coordinate): Coordinate = copy(x = x + that.x, y = y + that.y, z = z + that.z)\n  lazy val mag: Long = Math.abs(x) + Math.abs(y) + Math.abs(z)\n}\n// defined class Coordinate\n\ncase class Particle(index: Long, pos: Coordinate, vel: Coordinate, acc: Coordinate) {\n  def next: Particle = copy(pos = pos + vel + acc, vel = vel + acc)\n}\n// defined class Particle\n\nval LineMatcher = &quot;p=&lt;(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)&gt;, v=&lt;(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)&gt;, a=&lt;(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)&gt;&quot;.r\n// LineMatcher: scala.util.matching.Regex = p=&lt;(-?\\d+),(-?\\d+),(-?\\d+)&gt;, v=&lt;(-?\\d+),(-?\\d+),(-?\\d+)&gt;, a=&lt;(-?\\d+),(-?\\d+),(-?\\d+)&gt;\n\ndef parseLines(lines: TraversableOnce[String]): Seq[Particle] =\n  lines.toSeq.zipWithIndex.collect {\n    case (LineMatcher(px, py, pz, vx, vy, vz, ax, ay, az), i) =&gt; Particle(\n      i,\n      Coordinate(px.toLong, py.toLong, pz.toLong),\n      Coordinate(vx.toLong, vy.toLong, vz.toLong),\n      Coordinate(ax.toLong, ay.toLong, az.toLong)\n    )\n  }\n// parseLines: (lines: TraversableOnce[String])Seq[Particle]\n</code></pre>\n<p>Given that in the limit, the closest particle is going to be among those with the least acceleration, my first idea is to sort the particles by that and see what the slowest look like.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = parseLines(Source.fromResource(&quot;day20input.txt&quot;).getLines())\n// input: Seq[Particle] = Stream(Particle(0,Coordinate(-11104,1791,5208),Coordinate(-6,36,-84),Coordinate(19,-5,-4)), ?)\n\nimplicit val coordinateOrder: Ordering[Coordinate] = Ordering.by(_.mag)\n// coordinateOrder: Ordering[Coordinate] = scala.math.Ordering$$anon$10@1008febf\n\ninput.sortBy(_.acc).take(3).foreach(println)\n// Particle(300,Coordinate(1585,1025,-980),Coordinate(-56,-35,35),Coordinate(0,0,0))\n// Particle(74,Coordinate(863,3436,-1734),Coordinate(-28,-110,72),Coordinate(0,0,-1))\n// Particle(172,Coordinate(-197,-954,-115),Coordinate(20,85,11),Coordinate(0,-1,0))\n</code></pre>\n<p>Which makes things easy as I can now just submit particle 300 as the answer.</p>\n<p>First I'll check my working:</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day20Part1Test extends FunSuite with Matchers {\n  test(&quot;can parse lines&quot;) {\n    parseLines(\n      &quot;&quot;&quot;p=&lt;3,0,0&gt;, v=&lt;2,0,0&gt;, a=&lt;-1,0,0&gt;\n        |p=&lt;4,0,0&gt;, v=&lt;0,0,0&gt;, a=&lt;-2,0,0&gt;&quot;&quot;&quot;.stripMargin.lines\n    ) shouldBe Seq(\n      Particle(\n        0,\n        Coordinate(3, 0, 0),\n        Coordinate(2, 0, 0),\n        Coordinate(-1, 0, 0)\n      ),\n      Particle(\n        1,\n        Coordinate(4, 0, 0),\n        Coordinate(0, 0, 0),\n        Coordinate(-2, 0, 0)\n      )\n    )\n  }\n\n  test(&quot;coordinates can be ordered&quot;) {\n    Seq(\n      Coordinate(0, -1, 0),\n      Coordinate(0, -1, 3),\n      Coordinate(2, 0, 0),\n      Coordinate(0, 0, 0),\n      Coordinate(1, -1, 1)\n    ).sorted shouldBe Seq(\n      Coordinate(0, 0, 0),\n      Coordinate(0, -1, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(1, -1, 1),\n      Coordinate(0, -1, 3)\n    )\n  }\n}\n// defined class Day20Part1Test\n\n(new Day20Part1Test).execute()\n// Day20Part1Test:\n// - can parse lines\n// - coordinates can be ordered\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For part two I think the best first step is just to run the simulation until the particle count is roughly stable. Technically I'll need to run it until all the particles are moving away from each other, but working that out will not be easy and probably unnecessary.</p>\n<p>Determining the collisions is just a case of finding particles that share the same position as another, and filtering them out. I picked 1000 iterations of the particle count staying the same as a reasonable approximation of determining when the collisions were complete.</p>\n<pre><code class=\"language-scala\">def countSurvivingParticles(particles: Seq[Particle], count: Long = 0, prevLength: Int = 0): Int = {\n  val newParticles: Seq[Particle] =\n    particles\n      .groupBy(_.pos)\n      .filter {case (_, ps) =&gt; ps.lengthCompare(1) == 0}\n      .flatMap(_._2)\n      .map(_.next)\n      .toSeq\n      \n  if(count % 1000 == 0) {\n    if(newParticles.lengthCompare(prevLength) == 0)\n      newParticles.length\n    else\n      countSurvivingParticles(newParticles, count + 1, newParticles.length)\n  }\n  else countSurvivingParticles(newParticles, count + 1, prevLength)\n} \n// countSurvivingParticles: (particles: Seq[Particle], count: Long, prevLength: Int)Int\n</code></pre>\n<p>I can use the example from the puzzle to provide a test case. I also still need<br>\nto write tests for advancing particles to the next state.</p>\n<pre><code class=\"language-scala\">class Day20Part2Test extends FunSuite with Matchers {\n  test(&quot;can step particles&quot;) {\n    Particle(\n      0,\n      Coordinate(3, 0, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(-1, 0, 0)\n    ).next shouldBe\n      Particle(\n        0,\n        Coordinate(4, 0, 0),\n        Coordinate(1, 0, 0),\n        Coordinate(-1, 0, 0)\n      )\n  \n    Particle(\n      0,\n      Coordinate(3, 0, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(-1, 0, 0)\n    ).next.next shouldBe\n      Particle(\n        0,\n        Coordinate(4, 0, 0),\n        Coordinate(0, 0, 0),\n        Coordinate(-1, 0, 0)\n      )\n  \n  \n    Particle(\n      1,\n      Coordinate(4, 0, 0),\n      Coordinate(0, 0, 0),\n      Coordinate(-2, 0, 0)\n    ).next shouldBe\n      Particle(\n        1,\n        Coordinate(2, 0, 0),\n        Coordinate(-2, 0, 0),\n        Coordinate(-2, 0, 0)\n      )\n  }\n  \n  test(&quot;can collide particles&quot;) {\n    countSurvivingParticles(\n      parseLines(\n        &quot;&quot;&quot;p=&lt;-6,0,0&gt;, v=&lt;3,0,0&gt;, a=&lt;0,0,0&gt;\n          |p=&lt;-4,0,0&gt;, v=&lt;2,0,0&gt;, a=&lt;0,0,0&gt;\n          |p=&lt;-2,0,0&gt;, v=&lt;1,0,0&gt;, a=&lt;0,0,0&gt;\n          |p=&lt;3,0,0&gt;, v=&lt;-1,0,0&gt;, a=&lt;0,0,0&gt;&quot;&quot;&quot;.stripMargin.lines\n      )\n    ) shouldBe 1\n  }\n}\n// defined class Day20Part2Test\n\n(new Day20Part2Test).execute()\n// Day20Part2Test:\n// - can step particles\n// - can collide particles\n</code></pre>\n<p>I can now run the simulation and try the answer.</p>\n<pre><code class=\"language-scala\">countSurvivingParticles(input)\n// res3: Int = 502\n</code></pre>\n<p>Since that was counted as correct, I'll leave today there.</p>\n<!--kg-card-end: markdown-->","comment_id":"5a46ddb19c9605113d0a49f9","plaintext":"A solution for Advent of Code 2017 - Day 20\n[http://adventofcode.com/2017/day/20]\n\nPart 1\nFor starters with today's input I'm going to need to turn my puzzle input into\nsomething useful.\n\ncase class Coordinate(x: Long, y: Long, z: Long) {\n  def +(that: Coordinate): Coordinate = copy(x = x + that.x, y = y + that.y, z = z + that.z)\n  lazy val mag: Long = Math.abs(x) + Math.abs(y) + Math.abs(z)\n}\n// defined class Coordinate\n\ncase class Particle(index: Long, pos: Coordinate, vel: Coordinate, acc: Coordinate) {\n  def next: Particle = copy(pos = pos + vel + acc, vel = vel + acc)\n}\n// defined class Particle\n\nval LineMatcher = \"p=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>, v=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>, a=<(-?\\\\d+),(-?\\\\d+),(-?\\\\d+)>\".r\n// LineMatcher: scala.util.matching.Regex = p=<(-?\\d+),(-?\\d+),(-?\\d+)>, v=<(-?\\d+),(-?\\d+),(-?\\d+)>, a=<(-?\\d+),(-?\\d+),(-?\\d+)>\n\ndef parseLines(lines: TraversableOnce[String]): Seq[Particle] =\n  lines.toSeq.zipWithIndex.collect {\n    case (LineMatcher(px, py, pz, vx, vy, vz, ax, ay, az), i) => Particle(\n      i,\n      Coordinate(px.toLong, py.toLong, pz.toLong),\n      Coordinate(vx.toLong, vy.toLong, vz.toLong),\n      Coordinate(ax.toLong, ay.toLong, az.toLong)\n    )\n  }\n// parseLines: (lines: TraversableOnce[String])Seq[Particle]\n\n\nGiven that in the limit, the closest particle is going to be among those with\nthe least acceleration, my first idea is to sort the particles by that and see\nwhat the slowest look like.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = parseLines(Source.fromResource(\"day20input.txt\").getLines())\n// input: Seq[Particle] = Stream(Particle(0,Coordinate(-11104,1791,5208),Coordinate(-6,36,-84),Coordinate(19,-5,-4)), ?)\n\nimplicit val coordinateOrder: Ordering[Coordinate] = Ordering.by(_.mag)\n// coordinateOrder: Ordering[Coordinate] = scala.math.Ordering$$anon$10@1008febf\n\ninput.sortBy(_.acc).take(3).foreach(println)\n// Particle(300,Coordinate(1585,1025,-980),Coordinate(-56,-35,35),Coordinate(0,0,0))\n// Particle(74,Coordinate(863,3436,-1734),Coordinate(-28,-110,72),Coordinate(0,0,-1))\n// Particle(172,Coordinate(-197,-954,-115),Coordinate(20,85,11),Coordinate(0,-1,0))\n\n\nWhich makes things easy as I can now just submit particle 300 as the answer.\n\nFirst I'll check my working:\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day20Part1Test extends FunSuite with Matchers {\n  test(\"can parse lines\") {\n    parseLines(\n      \"\"\"p=<3,0,0>, v=<2,0,0>, a=<-1,0,0>\n        |p=<4,0,0>, v=<0,0,0>, a=<-2,0,0>\"\"\".stripMargin.lines\n    ) shouldBe Seq(\n      Particle(\n        0,\n        Coordinate(3, 0, 0),\n        Coordinate(2, 0, 0),\n        Coordinate(-1, 0, 0)\n      ),\n      Particle(\n        1,\n        Coordinate(4, 0, 0),\n        Coordinate(0, 0, 0),\n        Coordinate(-2, 0, 0)\n      )\n    )\n  }\n\n  test(\"coordinates can be ordered\") {\n    Seq(\n      Coordinate(0, -1, 0),\n      Coordinate(0, -1, 3),\n      Coordinate(2, 0, 0),\n      Coordinate(0, 0, 0),\n      Coordinate(1, -1, 1)\n    ).sorted shouldBe Seq(\n      Coordinate(0, 0, 0),\n      Coordinate(0, -1, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(1, -1, 1),\n      Coordinate(0, -1, 3)\n    )\n  }\n}\n// defined class Day20Part1Test\n\n(new Day20Part1Test).execute()\n// Day20Part1Test:\n// - can parse lines\n// - coordinates can be ordered\n\n\nPart 2\nFor part two I think the best first step is just to run the simulation until the\nparticle count is roughly stable. Technically I'll need to run it until all the\nparticles are moving away from each other, but working that out will not be easy\nand probably unnecessary.\n\nDetermining the collisions is just a case of finding particles that share the\nsame position as another, and filtering them out. I picked 1000 iterations of\nthe particle count staying the same as a reasonable approximation of determining\nwhen the collisions were complete.\n\ndef countSurvivingParticles(particles: Seq[Particle], count: Long = 0, prevLength: Int = 0): Int = {\n  val newParticles: Seq[Particle] =\n    particles\n      .groupBy(_.pos)\n      .filter {case (_, ps) => ps.lengthCompare(1) == 0}\n      .flatMap(_._2)\n      .map(_.next)\n      .toSeq\n      \n  if(count % 1000 == 0) {\n    if(newParticles.lengthCompare(prevLength) == 0)\n      newParticles.length\n    else\n      countSurvivingParticles(newParticles, count + 1, newParticles.length)\n  }\n  else countSurvivingParticles(newParticles, count + 1, prevLength)\n} \n// countSurvivingParticles: (particles: Seq[Particle], count: Long, prevLength: Int)Int\n\n\nI can use the example from the puzzle to provide a test case. I also still need\nto write tests for advancing particles to the next state.\n\nclass Day20Part2Test extends FunSuite with Matchers {\n  test(\"can step particles\") {\n    Particle(\n      0,\n      Coordinate(3, 0, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(-1, 0, 0)\n    ).next shouldBe\n      Particle(\n        0,\n        Coordinate(4, 0, 0),\n        Coordinate(1, 0, 0),\n        Coordinate(-1, 0, 0)\n      )\n  \n    Particle(\n      0,\n      Coordinate(3, 0, 0),\n      Coordinate(2, 0, 0),\n      Coordinate(-1, 0, 0)\n    ).next.next shouldBe\n      Particle(\n        0,\n        Coordinate(4, 0, 0),\n        Coordinate(0, 0, 0),\n        Coordinate(-1, 0, 0)\n      )\n  \n  \n    Particle(\n      1,\n      Coordinate(4, 0, 0),\n      Coordinate(0, 0, 0),\n      Coordinate(-2, 0, 0)\n    ).next shouldBe\n      Particle(\n        1,\n        Coordinate(2, 0, 0),\n        Coordinate(-2, 0, 0),\n        Coordinate(-2, 0, 0)\n      )\n  }\n  \n  test(\"can collide particles\") {\n    countSurvivingParticles(\n      parseLines(\n        \"\"\"p=<-6,0,0>, v=<3,0,0>, a=<0,0,0>\n          |p=<-4,0,0>, v=<2,0,0>, a=<0,0,0>\n          |p=<-2,0,0>, v=<1,0,0>, a=<0,0,0>\n          |p=<3,0,0>, v=<-1,0,0>, a=<0,0,0>\"\"\".stripMargin.lines\n      )\n    ) shouldBe 1\n  }\n}\n// defined class Day20Part2Test\n\n(new Day20Part2Test).execute()\n// Day20Part2Test:\n// - can step particles\n// - can collide particles\n\n\nI can now run the simulation and try the answer.\n\ncountSurvivingParticles(input)\n// res3: Int = 502\n\n\nSince that was counted as correct, I'll leave today there.","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-23.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-30T00:28:33.000Z","updated_at":"2017-12-30T00:30:40.000Z","published_at":"2017-12-27T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 20","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a48c8229c9605113d0a4a03","uuid":"6e491b52-0ca7-4415-941c-43f223181b7c","title":"Fractal Art","slug":"aoc-2017-day-21-fractal-art","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 21](http://adventofcode.com/2017/day/21)\\n\\n## Part 1\\n\\nFirstly I need to be able to parse the input into something useful, and it would be useful to do the rotation/flipping of the input here so that finding the correct successor image for any pattern is a simple map lookup. Helpfully the Scala collections library provides a transpose for me, and with some implicit magic I can make it fairly clear what is happening.\\n\\n```scala\\nimplicit class MatrixOps[T](m: Vector[Vector[T]]) {\\n  def flip: Vector[Vector[T]] = m.map(_.reverse)\\n  def rot: Vector[Vector[T]] = m.transpose.flip\\n}\\n// defined class MatrixOps\\n\\ndef explode(base: Vector[Vector[Char]]): Seq[Vector[Vector[Char]]] = {\\n  Seq(\\n    base,\\n    base.flip,\\n    base.rot,\\n    base.rot.flip,\\n    base.rot.rot,\\n    base.rot.rot.flip,\\n    base.rot.rot.rot,\\n    base.rot.rot.rot.flip\\n  )\\n}\\n// explode: (base: Vector[Vector[Char]])Seq[Vector[Vector[Char]]]\\n\\ndef parseInput(lines: TraversableOnce[String]): Map[Vector[Vector[Char]], Vector[Vector[Char]]] = {\\n  lines.flatMap(\\n    l => {\\n      val (base +: result +: _) =\\n        l.split(\\\" => \\\")\\n          .map(r => r.split(\\\"/\\\").toVector.map(_.toVector))\\n          .toSeq\\n\\n      explode(base).map(_ -> result)\\n    }\\n  ).toMap\\n}\\n// parseInput: (lines: TraversableOnce[String])Map[Vector[Vector[Char]],Vector[Vector[Char]]]\\n```\\n\\nWith that in place, I can now perform the enhancement rounds. I can use for-comprehensions to make the looping through the sub-images, doing the pattern lookup. I also then split the output pattern into single characters, allowing me to build the new image one bit at a time.\\n\\n```scala\\ndef expand(grid: Vector[Vector[Char]],\\n           book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\\n           rounds: Int): Vector[Vector[Char]] = {\\n\\n  def _doExpand(i: Int): Vector[Vector[Char]] = {\\n    val newWidth = (grid(0).length / i) * (i + 1)\\n    (for {\\n      x <- 0 until grid(0).length / i\\n      y <- 0 until grid(0).length / i\\n      (img, a) <- book(\\n        (0 until i).map(j =>\\n          grid((i * x) + j).slice(i * y, (i * y) + i)\\n        ).toVector\\n      ).zipWithIndex\\n      (ch, b) <- img.zipWithIndex\\n    } yield (x, y, ch, a, b)).foldLeft(Vector.fill(newWidth, newWidth)(' ')) {\\n      case (acc, (x, y, ch, a, b)) =>\\n        acc.updated(\\n          x * (i + 1) + a,\\n          acc((x * (i + 1)) + a).updated(\\n            y * (i + 1) + b,\\n            ch\\n          )\\n        )\\n    }\\n  }\\n\\n\\n  if (rounds == 0) grid\\n  else {\\n    if (grid(0).length % 2 == 0)\\n      expand(_doExpand(2), book, rounds - 1)\\n    else\\n      expand(_doExpand(3), book, rounds - 1)\\n  }\\n}\\n// expand: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Vector[Vector[Char]]\\n```\\n\\nFinally I need to count the pixels in the expanded image to be able to answer the puzzle.\\n\\n```scala\\ndef countPixels(grid: Vector[Vector[Char]],\\n                book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\\n                rounds: Int): Int = {\\n  expand(grid, book, rounds).map(_.count(_ == '#')).sum\\n}\\n// countPixels: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Int\\n```\\n\\nThere are quite a few steps to this, so also a fairly large set of tests. Mostly these are derived from the example given.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day21Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"can malipulate vectors\\\")\\n  {\\n    Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector).flip shouldBe Vector(\\\".#\\\".toVector, \\\"##\\\".toVector)\\n    Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector).rot shouldBe Vector(\\\"##\\\".toVector, \\\"#.\\\".toVector)\\n    Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector).rot.rot shouldBe Vector(\\\"##\\\".toVector, \\\".#\\\".toVector)\\n    Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector).rot.rot.rot shouldBe Vector(\\\".#\\\".toVector, \\\"##\\\".toVector)\\n    Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector).rot.rot.rot.rot shouldBe Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector)\\n  }\\n\\n  test(\\\"can parse input\\\") {\\n    parseInput(Seq(\\n      \\\"##/#. => .../.##/##.\\\",\\n      \\\"##/## => ###/#../#..\\\"\\n    )) shouldBe Map(\\n      Vector(\\\"##\\\".toVector, \\\"#.\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\".#\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"##\\\".toVector, \\\".#\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"##\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"###\\\".toVector, \\\"#..\\\".toVector, \\\"#..\\\".toVector)\\n    )\\n    parseInput(Seq(\\n      \\\".../.../... => .#../.#../#..#/##..\\\",\\n      \\\"#../.../... => ####/####/.###/####\\\"\\n    )) shouldBe Map(\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\".#..\\\".toVector, \\\".#..\\\".toVector, \\\"#..#\\\".toVector, \\\"##..\\\".toVector),\\n      Vector(\\\"#..\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"..#\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"#..\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"..#\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector)\\n    )\\n    parseInput(Seq(\\n      \\\".../.../... => .#../.#../#..#/##..\\\",\\n      \\\"##./.../... => ####/####/.###/####\\\"\\n    )) shouldBe Map(\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\".#..\\\".toVector, \\\".#..\\\".toVector, \\\"#..#\\\".toVector, \\\"##..\\\".toVector),\\n      Vector(\\\"##.\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\".##\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"##.\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\".##\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"..#\\\".toVector, \\\"..#\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"#..\\\".toVector, \\\"#..\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"#..\\\".toVector, \\\"#..\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"..#\\\".toVector, \\\"..#\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector)\\n    )\\n\\n    parseInput(Seq(\\n      \\\"##/#. => .../.##/##.\\\",\\n      \\\"##/## => ###/#../#..\\\",\\n      \\\".../.../... => .#../.#../#..#/##..\\\",\\n      \\\"#../.../... => ####/####/.###/####\\\"\\n    )) shouldBe Map(\\n      Vector(\\\"##\\\".toVector, \\\"#.\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\".#\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"#.\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"##\\\".toVector, \\\".#\\\".toVector) -> Vector(\\\"...\\\".toVector, \\\".##\\\".toVector, \\\"##.\\\".toVector),\\n      Vector(\\\"##\\\".toVector, \\\"##\\\".toVector) -> Vector(\\\"###\\\".toVector, \\\"#..\\\".toVector, \\\"#..\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\".#..\\\".toVector, \\\".#..\\\".toVector, \\\"#..#\\\".toVector, \\\"##..\\\".toVector),\\n      Vector(\\\"#..\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"..#\\\".toVector, \\\"...\\\".toVector, \\\"...\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"#..\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector),\\n      Vector(\\\"...\\\".toVector, \\\"...\\\".toVector, \\\"..#\\\".toVector) -> Vector(\\\"####\\\".toVector, \\\"####\\\".toVector, \\\".###\\\".toVector, \\\"####\\\".toVector)\\n    )\\n  }\\n\\n  private val book = parseInput(Seq(\\n    \\\"../.# => ##./#../...\\\",\\n    \\\".#./..#/### => #..#/..../..../#..#\\\"\\n  ))\\n\\n  private val base = Vector(\\n    \\\".#.\\\",\\n    \\\"..#\\\",\\n    \\\"###\\\"\\n  ).map(_.toVector)\\n\\n  test(\\\"can expand image\\\") {\\n    expand(base, book, 1) shouldBe Vector(\\n      \\\"#..#\\\",\\n      \\\"....\\\",\\n      \\\"....\\\",\\n      \\\"#..#\\\"\\n    ).map(_.toVector)\\n\\n    expand(base, book, 2) shouldBe Vector(\\n      \\\"##.##.\\\",\\n      \\\"#..#..\\\",\\n      \\\"......\\\",\\n      \\\"##.##.\\\",\\n      \\\"#..#..\\\",\\n      \\\"......\\\"\\n    ).map(_.toVector)\\n  }\\n\\n\\n  test(\\\"can count pixels image\\\") {\\n    countPixels(base, book, 2) shouldBe 12\\n  }\\n}\\n// defined class Day21Part1Test\\n\\n(new Day21Part1Test).execute()\\n// Day21Part1Test:\\n// - can malipulate vectors\\n// - can parse input\\n// - can expand image\\n// - can count pixels image\\n```\\n\\nI can then plug in my puzzle input to get the 'book' of enhancements to apply,\\nand run the process.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = parseInput(Source.fromResource(\\\"day21input.txt\\\").getLines())\\n// input: Map[Vector[Vector[Char]],Vector[Vector[Char]]] = Map(Vector(Vector(#, .), Vector(., #)) -> Vector(Vector(., ., #), Vector(., #, .), Vector(., ., #)), Vector(Vector(., ., #), Vector(., #, .), Vector(., #, .)) -> Vector(Vector(., ., #, .), Vector(#, ., ., .), Vector(#, #, ., .), Vector(#, #, #, .)), Vector(Vector(., #, .), Vector(., ., .), Vector(#, ., #)) -> Vector(Vector(#, ., #, .), Vector(#, ., ., #), Vector(#, #, #, .), Vector(., #, #, .)), Vector(Vector(#, #, #), Vector(., #, #), Vector(., ., #)) -> Vector(Vector(., #, #, #), Vector(., #, #, .), Vector(#, ., #, #), Vector(., ., #, #)), Vector(Vector(., ., #), Vector(., #, #), Vector(#, ., .)) -> Vector(Vector(#, ., #, .), Vector(., #, #, .), Vector(., #, #, #), Vector(#, ., #, .)), Vector(Vector(., #, #), Vector(., ., #), Vec...\\n\\nval base = Vector(\\n  \\\".#.\\\",\\n  \\\"..#\\\",\\n  \\\"###\\\"\\n).map(_.toVector)\\n// base: scala.collection.immutable.Vector[Vector[Char]] = Vector(Vector(., #, .), Vector(., ., #), Vector(#, #, #))\\n\\ncountPixels(base, input, 5)\\n// res1: Int = 139\\n```\\n\\n## Part 2\\n\\nPart 2 was just part 1 again on a larger scale. I suspect there is some trick to notice that sections of the image are repeated and that could reduce the problem to a smaller size. However, pluging the extra enhancement rounds into my solution above still produced the answer in seconds, so I left it at that.\\n\\n```scala\\ncountPixels(base, input, 18)\\n// res2: Int = 1857134\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/21\">Advent of Code 2017 - Day 21</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Firstly I need to be able to parse the input into something useful, and it would be useful to do the rotation/flipping of the input here so that finding the correct successor image for any pattern is a simple map lookup. Helpfully the Scala collections library provides a transpose for me, and with some implicit magic I can make it fairly clear what is happening.</p>\n<pre><code class=\"language-scala\">implicit class MatrixOps[T](m: Vector[Vector[T]]) {\n  def flip: Vector[Vector[T]] = m.map(_.reverse)\n  def rot: Vector[Vector[T]] = m.transpose.flip\n}\n// defined class MatrixOps\n\ndef explode(base: Vector[Vector[Char]]): Seq[Vector[Vector[Char]]] = {\n  Seq(\n    base,\n    base.flip,\n    base.rot,\n    base.rot.flip,\n    base.rot.rot,\n    base.rot.rot.flip,\n    base.rot.rot.rot,\n    base.rot.rot.rot.flip\n  )\n}\n// explode: (base: Vector[Vector[Char]])Seq[Vector[Vector[Char]]]\n\ndef parseInput(lines: TraversableOnce[String]): Map[Vector[Vector[Char]], Vector[Vector[Char]]] = {\n  lines.flatMap(\n    l =&gt; {\n      val (base +: result +: _) =\n        l.split(&quot; =&gt; &quot;)\n          .map(r =&gt; r.split(&quot;/&quot;).toVector.map(_.toVector))\n          .toSeq\n\n      explode(base).map(_ -&gt; result)\n    }\n  ).toMap\n}\n// parseInput: (lines: TraversableOnce[String])Map[Vector[Vector[Char]],Vector[Vector[Char]]]\n</code></pre>\n<p>With that in place, I can now perform the enhancement rounds. I can use for-comprehensions to make the looping through the sub-images, doing the pattern lookup. I also then split the output pattern into single characters, allowing me to build the new image one bit at a time.</p>\n<pre><code class=\"language-scala\">def expand(grid: Vector[Vector[Char]],\n           book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\n           rounds: Int): Vector[Vector[Char]] = {\n\n  def _doExpand(i: Int): Vector[Vector[Char]] = {\n    val newWidth = (grid(0).length / i) * (i + 1)\n    (for {\n      x &lt;- 0 until grid(0).length / i\n      y &lt;- 0 until grid(0).length / i\n      (img, a) &lt;- book(\n        (0 until i).map(j =&gt;\n          grid((i * x) + j).slice(i * y, (i * y) + i)\n        ).toVector\n      ).zipWithIndex\n      (ch, b) &lt;- img.zipWithIndex\n    } yield (x, y, ch, a, b)).foldLeft(Vector.fill(newWidth, newWidth)(' ')) {\n      case (acc, (x, y, ch, a, b)) =&gt;\n        acc.updated(\n          x * (i + 1) + a,\n          acc((x * (i + 1)) + a).updated(\n            y * (i + 1) + b,\n            ch\n          )\n        )\n    }\n  }\n\n\n  if (rounds == 0) grid\n  else {\n    if (grid(0).length % 2 == 0)\n      expand(_doExpand(2), book, rounds - 1)\n    else\n      expand(_doExpand(3), book, rounds - 1)\n  }\n}\n// expand: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Vector[Vector[Char]]\n</code></pre>\n<p>Finally I need to count the pixels in the expanded image to be able to answer the puzzle.</p>\n<pre><code class=\"language-scala\">def countPixels(grid: Vector[Vector[Char]],\n                book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\n                rounds: Int): Int = {\n  expand(grid, book, rounds).map(_.count(_ == '#')).sum\n}\n// countPixels: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Int\n</code></pre>\n<p>There are quite a few steps to this, so also a fairly large set of tests. Mostly these are derived from the example given.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day21Part1Test extends FunSuite with Matchers {\n\n  test(&quot;can malipulate vectors&quot;)\n  {\n    Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector).flip shouldBe Vector(&quot;.#&quot;.toVector, &quot;##&quot;.toVector)\n    Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector).rot shouldBe Vector(&quot;##&quot;.toVector, &quot;#.&quot;.toVector)\n    Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector).rot.rot shouldBe Vector(&quot;##&quot;.toVector, &quot;.#&quot;.toVector)\n    Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector).rot.rot.rot shouldBe Vector(&quot;.#&quot;.toVector, &quot;##&quot;.toVector)\n    Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector).rot.rot.rot.rot shouldBe Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector)\n  }\n\n  test(&quot;can parse input&quot;) {\n    parseInput(Seq(\n      &quot;##/#. =&gt; .../.##/##.&quot;,\n      &quot;##/## =&gt; ###/#../#..&quot;\n    )) shouldBe Map(\n      Vector(&quot;##&quot;.toVector, &quot;#.&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;.#&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;##&quot;.toVector, &quot;.#&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;##&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;###&quot;.toVector, &quot;#..&quot;.toVector, &quot;#..&quot;.toVector)\n    )\n    parseInput(Seq(\n      &quot;.../.../... =&gt; .#../.#../#..#/##..&quot;,\n      &quot;#../.../... =&gt; ####/####/.###/####&quot;\n    )) shouldBe Map(\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;.#..&quot;.toVector, &quot;.#..&quot;.toVector, &quot;#..#&quot;.toVector, &quot;##..&quot;.toVector),\n      Vector(&quot;#..&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;..#&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;#..&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;..#&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector)\n    )\n    parseInput(Seq(\n      &quot;.../.../... =&gt; .#../.#../#..#/##..&quot;,\n      &quot;##./.../... =&gt; ####/####/.###/####&quot;\n    )) shouldBe Map(\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;.#..&quot;.toVector, &quot;.#..&quot;.toVector, &quot;#..#&quot;.toVector, &quot;##..&quot;.toVector),\n      Vector(&quot;##.&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;.##&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;##.&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;.##&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;..#&quot;.toVector, &quot;..#&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;#..&quot;.toVector, &quot;#..&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;#..&quot;.toVector, &quot;#..&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;..#&quot;.toVector, &quot;..#&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector)\n    )\n\n    parseInput(Seq(\n      &quot;##/#. =&gt; .../.##/##.&quot;,\n      &quot;##/## =&gt; ###/#../#..&quot;,\n      &quot;.../.../... =&gt; .#../.#../#..#/##..&quot;,\n      &quot;#../.../... =&gt; ####/####/.###/####&quot;\n    )) shouldBe Map(\n      Vector(&quot;##&quot;.toVector, &quot;#.&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;.#&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;#.&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;##&quot;.toVector, &quot;.#&quot;.toVector) -&gt; Vector(&quot;...&quot;.toVector, &quot;.##&quot;.toVector, &quot;##.&quot;.toVector),\n      Vector(&quot;##&quot;.toVector, &quot;##&quot;.toVector) -&gt; Vector(&quot;###&quot;.toVector, &quot;#..&quot;.toVector, &quot;#..&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;.#..&quot;.toVector, &quot;.#..&quot;.toVector, &quot;#..#&quot;.toVector, &quot;##..&quot;.toVector),\n      Vector(&quot;#..&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;..#&quot;.toVector, &quot;...&quot;.toVector, &quot;...&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;#..&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector),\n      Vector(&quot;...&quot;.toVector, &quot;...&quot;.toVector, &quot;..#&quot;.toVector) -&gt; Vector(&quot;####&quot;.toVector, &quot;####&quot;.toVector, &quot;.###&quot;.toVector, &quot;####&quot;.toVector)\n    )\n  }\n\n  private val book = parseInput(Seq(\n    &quot;../.# =&gt; ##./#../...&quot;,\n    &quot;.#./..#/### =&gt; #..#/..../..../#..#&quot;\n  ))\n\n  private val base = Vector(\n    &quot;.#.&quot;,\n    &quot;..#&quot;,\n    &quot;###&quot;\n  ).map(_.toVector)\n\n  test(&quot;can expand image&quot;) {\n    expand(base, book, 1) shouldBe Vector(\n      &quot;#..#&quot;,\n      &quot;....&quot;,\n      &quot;....&quot;,\n      &quot;#..#&quot;\n    ).map(_.toVector)\n\n    expand(base, book, 2) shouldBe Vector(\n      &quot;##.##.&quot;,\n      &quot;#..#..&quot;,\n      &quot;......&quot;,\n      &quot;##.##.&quot;,\n      &quot;#..#..&quot;,\n      &quot;......&quot;\n    ).map(_.toVector)\n  }\n\n\n  test(&quot;can count pixels image&quot;) {\n    countPixels(base, book, 2) shouldBe 12\n  }\n}\n// defined class Day21Part1Test\n\n(new Day21Part1Test).execute()\n// Day21Part1Test:\n// - can malipulate vectors\n// - can parse input\n// - can expand image\n// - can count pixels image\n</code></pre>\n<p>I can then plug in my puzzle input to get the 'book' of enhancements to apply,<br>\nand run the process.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(&quot;day21input.txt&quot;).getLines())\n// input: Map[Vector[Vector[Char]],Vector[Vector[Char]]] = Map(Vector(Vector(#, .), Vector(., #)) -&gt; Vector(Vector(., ., #), Vector(., #, .), Vector(., ., #)), Vector(Vector(., ., #), Vector(., #, .), Vector(., #, .)) -&gt; Vector(Vector(., ., #, .), Vector(#, ., ., .), Vector(#, #, ., .), Vector(#, #, #, .)), Vector(Vector(., #, .), Vector(., ., .), Vector(#, ., #)) -&gt; Vector(Vector(#, ., #, .), Vector(#, ., ., #), Vector(#, #, #, .), Vector(., #, #, .)), Vector(Vector(#, #, #), Vector(., #, #), Vector(., ., #)) -&gt; Vector(Vector(., #, #, #), Vector(., #, #, .), Vector(#, ., #, #), Vector(., ., #, #)), Vector(Vector(., ., #), Vector(., #, #), Vector(#, ., .)) -&gt; Vector(Vector(#, ., #, .), Vector(., #, #, .), Vector(., #, #, #), Vector(#, ., #, .)), Vector(Vector(., #, #), Vector(., ., #), Vec...\n\nval base = Vector(\n  &quot;.#.&quot;,\n  &quot;..#&quot;,\n  &quot;###&quot;\n).map(_.toVector)\n// base: scala.collection.immutable.Vector[Vector[Char]] = Vector(Vector(., #, .), Vector(., ., #), Vector(#, #, #))\n\ncountPixels(base, input, 5)\n// res1: Int = 139\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Part 2 was just part 1 again on a larger scale. I suspect there is some trick to notice that sections of the image are repeated and that could reduce the problem to a smaller size. However, pluging the extra enhancement rounds into my solution above still produced the answer in seconds, so I left it at that.</p>\n<pre><code class=\"language-scala\">countPixels(base, input, 18)\n// res2: Int = 1857134\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a48c8229c9605113d0a4a03","plaintext":"A solution for Advent of Code 2017 - Day 21\n[http://adventofcode.com/2017/day/21]\n\nPart 1\nFirstly I need to be able to parse the input into something useful, and it would\nbe useful to do the rotation/flipping of the input here so that finding the\ncorrect successor image for any pattern is a simple map lookup. Helpfully the\nScala collections library provides a transpose for me, and with some implicit\nmagic I can make it fairly clear what is happening.\n\nimplicit class MatrixOps[T](m: Vector[Vector[T]]) {\n  def flip: Vector[Vector[T]] = m.map(_.reverse)\n  def rot: Vector[Vector[T]] = m.transpose.flip\n}\n// defined class MatrixOps\n\ndef explode(base: Vector[Vector[Char]]): Seq[Vector[Vector[Char]]] = {\n  Seq(\n    base,\n    base.flip,\n    base.rot,\n    base.rot.flip,\n    base.rot.rot,\n    base.rot.rot.flip,\n    base.rot.rot.rot,\n    base.rot.rot.rot.flip\n  )\n}\n// explode: (base: Vector[Vector[Char]])Seq[Vector[Vector[Char]]]\n\ndef parseInput(lines: TraversableOnce[String]): Map[Vector[Vector[Char]], Vector[Vector[Char]]] = {\n  lines.flatMap(\n    l => {\n      val (base +: result +: _) =\n        l.split(\" => \")\n          .map(r => r.split(\"/\").toVector.map(_.toVector))\n          .toSeq\n\n      explode(base).map(_ -> result)\n    }\n  ).toMap\n}\n// parseInput: (lines: TraversableOnce[String])Map[Vector[Vector[Char]],Vector[Vector[Char]]]\n\n\nWith that in place, I can now perform the enhancement rounds. I can use\nfor-comprehensions to make the looping through the sub-images, doing the pattern\nlookup. I also then split the output pattern into single characters, allowing me\nto build the new image one bit at a time.\n\ndef expand(grid: Vector[Vector[Char]],\n           book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\n           rounds: Int): Vector[Vector[Char]] = {\n\n  def _doExpand(i: Int): Vector[Vector[Char]] = {\n    val newWidth = (grid(0).length / i) * (i + 1)\n    (for {\n      x <- 0 until grid(0).length / i\n      y <- 0 until grid(0).length / i\n      (img, a) <- book(\n        (0 until i).map(j =>\n          grid((i * x) + j).slice(i * y, (i * y) + i)\n        ).toVector\n      ).zipWithIndex\n      (ch, b) <- img.zipWithIndex\n    } yield (x, y, ch, a, b)).foldLeft(Vector.fill(newWidth, newWidth)(' ')) {\n      case (acc, (x, y, ch, a, b)) =>\n        acc.updated(\n          x * (i + 1) + a,\n          acc((x * (i + 1)) + a).updated(\n            y * (i + 1) + b,\n            ch\n          )\n        )\n    }\n  }\n\n\n  if (rounds == 0) grid\n  else {\n    if (grid(0).length % 2 == 0)\n      expand(_doExpand(2), book, rounds - 1)\n    else\n      expand(_doExpand(3), book, rounds - 1)\n  }\n}\n// expand: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Vector[Vector[Char]]\n\n\nFinally I need to count the pixels in the expanded image to be able to answer\nthe puzzle.\n\ndef countPixels(grid: Vector[Vector[Char]],\n                book: Map[Vector[Vector[Char]], Vector[Vector[Char]]],\n                rounds: Int): Int = {\n  expand(grid, book, rounds).map(_.count(_ == '#')).sum\n}\n// countPixels: (grid: Vector[Vector[Char]], book: Map[Vector[Vector[Char]],Vector[Vector[Char]]], rounds: Int)Int\n\n\nThere are quite a few steps to this, so also a fairly large set of tests. Mostly\nthese are derived from the example given.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day21Part1Test extends FunSuite with Matchers {\n\n  test(\"can malipulate vectors\")\n  {\n    Vector(\"#.\".toVector, \"##\".toVector).flip shouldBe Vector(\".#\".toVector, \"##\".toVector)\n    Vector(\"#.\".toVector, \"##\".toVector).rot shouldBe Vector(\"##\".toVector, \"#.\".toVector)\n    Vector(\"#.\".toVector, \"##\".toVector).rot.rot shouldBe Vector(\"##\".toVector, \".#\".toVector)\n    Vector(\"#.\".toVector, \"##\".toVector).rot.rot.rot shouldBe Vector(\".#\".toVector, \"##\".toVector)\n    Vector(\"#.\".toVector, \"##\".toVector).rot.rot.rot.rot shouldBe Vector(\"#.\".toVector, \"##\".toVector)\n  }\n\n  test(\"can parse input\") {\n    parseInput(Seq(\n      \"##/#. => .../.##/##.\",\n      \"##/## => ###/#../#..\"\n    )) shouldBe Map(\n      Vector(\"##\".toVector, \"#.\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\".#\".toVector, \"##\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"#.\".toVector, \"##\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"##\".toVector, \".#\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"##\".toVector, \"##\".toVector) -> Vector(\"###\".toVector, \"#..\".toVector, \"#..\".toVector)\n    )\n    parseInput(Seq(\n      \".../.../... => .#../.#../#..#/##..\",\n      \"#../.../... => ####/####/.###/####\"\n    )) shouldBe Map(\n      Vector(\"...\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\".#..\".toVector, \".#..\".toVector, \"#..#\".toVector, \"##..\".toVector),\n      Vector(\"#..\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"..#\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"#..\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"..#\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector)\n    )\n    parseInput(Seq(\n      \".../.../... => .#../.#../#..#/##..\",\n      \"##./.../... => ####/####/.###/####\"\n    )) shouldBe Map(\n      Vector(\"...\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\".#..\".toVector, \".#..\".toVector, \"#..#\".toVector, \"##..\".toVector),\n      Vector(\"##.\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\".##\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"##.\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \".##\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"..#\".toVector, \"..#\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"#..\".toVector, \"#..\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"#..\".toVector, \"#..\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"..#\".toVector, \"..#\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector)\n    )\n\n    parseInput(Seq(\n      \"##/#. => .../.##/##.\",\n      \"##/## => ###/#../#..\",\n      \".../.../... => .#../.#../#..#/##..\",\n      \"#../.../... => ####/####/.###/####\"\n    )) shouldBe Map(\n      Vector(\"##\".toVector, \"#.\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\".#\".toVector, \"##\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"#.\".toVector, \"##\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"##\".toVector, \".#\".toVector) -> Vector(\"...\".toVector, \".##\".toVector, \"##.\".toVector),\n      Vector(\"##\".toVector, \"##\".toVector) -> Vector(\"###\".toVector, \"#..\".toVector, \"#..\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\".#..\".toVector, \".#..\".toVector, \"#..#\".toVector, \"##..\".toVector),\n      Vector(\"#..\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"..#\".toVector, \"...\".toVector, \"...\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"#..\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector),\n      Vector(\"...\".toVector, \"...\".toVector, \"..#\".toVector) -> Vector(\"####\".toVector, \"####\".toVector, \".###\".toVector, \"####\".toVector)\n    )\n  }\n\n  private val book = parseInput(Seq(\n    \"../.# => ##./#../...\",\n    \".#./..#/### => #..#/..../..../#..#\"\n  ))\n\n  private val base = Vector(\n    \".#.\",\n    \"..#\",\n    \"###\"\n  ).map(_.toVector)\n\n  test(\"can expand image\") {\n    expand(base, book, 1) shouldBe Vector(\n      \"#..#\",\n      \"....\",\n      \"....\",\n      \"#..#\"\n    ).map(_.toVector)\n\n    expand(base, book, 2) shouldBe Vector(\n      \"##.##.\",\n      \"#..#..\",\n      \"......\",\n      \"##.##.\",\n      \"#..#..\",\n      \"......\"\n    ).map(_.toVector)\n  }\n\n\n  test(\"can count pixels image\") {\n    countPixels(base, book, 2) shouldBe 12\n  }\n}\n// defined class Day21Part1Test\n\n(new Day21Part1Test).execute()\n// Day21Part1Test:\n// - can malipulate vectors\n// - can parse input\n// - can expand image\n// - can count pixels image\n\n\nI can then plug in my puzzle input to get the 'book' of enhancements to apply,\nand run the process.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(\"day21input.txt\").getLines())\n// input: Map[Vector[Vector[Char]],Vector[Vector[Char]]] = Map(Vector(Vector(#, .), Vector(., #)) -> Vector(Vector(., ., #), Vector(., #, .), Vector(., ., #)), Vector(Vector(., ., #), Vector(., #, .), Vector(., #, .)) -> Vector(Vector(., ., #, .), Vector(#, ., ., .), Vector(#, #, ., .), Vector(#, #, #, .)), Vector(Vector(., #, .), Vector(., ., .), Vector(#, ., #)) -> Vector(Vector(#, ., #, .), Vector(#, ., ., #), Vector(#, #, #, .), Vector(., #, #, .)), Vector(Vector(#, #, #), Vector(., #, #), Vector(., ., #)) -> Vector(Vector(., #, #, #), Vector(., #, #, .), Vector(#, ., #, #), Vector(., ., #, #)), Vector(Vector(., ., #), Vector(., #, #), Vector(#, ., .)) -> Vector(Vector(#, ., #, .), Vector(., #, #, .), Vector(., #, #, #), Vector(#, ., #, .)), Vector(Vector(., #, #), Vector(., ., #), Vec...\n\nval base = Vector(\n  \".#.\",\n  \"..#\",\n  \"###\"\n).map(_.toVector)\n// base: scala.collection.immutable.Vector[Vector[Char]] = Vector(Vector(., #, .), Vector(., ., #), Vector(#, #, #))\n\ncountPixels(base, input, 5)\n// res1: Int = 139\n\n\nPart 2\nPart 2 was just part 1 again on a larger scale. I suspect there is some trick to\nnotice that sections of the image are repeated and that could reduce the problem\nto a smaller size. However, pluging the extra enhancement rounds into my\nsolution above still produced the answer in seconds, so I left it at that.\n\ncountPixels(base, input, 18)\n// res2: Int = 1857134","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-24.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2017-12-31T11:21:06.000Z","updated_at":"2018-01-03T23:17:14.000Z","published_at":"2017-12-28T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 21","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a4d38e29c9605113d0a4a0b","uuid":"3b37c0ca-7ab9-4927-8953-496663c04e47","title":"Sporifica Virus","slug":"aoc-2017-day-22-sporifica-virus","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 22](http://adventofcode.com/2017/day/22)\\n\\n## Part 1\\n\\nI put the grid into a map as I can just add extra values as the position expands\\noutside the current grid, and the Map implementation handles adding the \\nunderlying data for me.\\n\\n```scala\\ndef parseInput(lines: Seq[String]): Map[Int, Map[Int, Char]] = (\\n  lines.zipWithIndex\\n      .map {\\n        case (line, index) =>\\n          index - (lines.size / 2) ->\\n            line.zipWithIndex.map {\\n              case (c, i) => i - (line.length / 2) -> c\\n            }.toMap\\n      }.toMap\\n)\\n// parseInput: (lines: Seq[String])Map[Int,Map[Int,Char]]\\n```\\n\\nI started with an implementation that had the progress to next stage strategy \\nembedded within it, but factored this out into an argument to enable me to use \\nthe same code for part 2.\\n\\n```scala\\ndef countInfections(grid: Map[Int, Map[Int, Char]],\\n                    iterations: Int,\\n                    infectionStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)]): Int = {\\n  def iter(grid: Map[Int, Map[Int, Char]],\\n           x: Int, y: Int,\\n           dx:Int, dy: Int,\\n           count: Int, infectionCount: Int): Int = {\\n    if(count == iterations) return infectionCount\\n\\n    val status = grid.getOrElse(y, Map.empty).getOrElse(x, '.')\\n    val (ndx, ndy, nStatus) = infectionStrategy((dx, dy, status))\\n    val nICount = if(nStatus == '#') infectionCount + 1 else infectionCount\\n    iter(\\n      grid.updated(y, grid.getOrElse(y, Map.empty).updated(x, nStatus)),\\n      x + ndx, y + ndy,\\n      ndx, ndy,\\n      count + 1, nICount\\n    )\\n  }\\n\\n  iter(grid, 0, 0, 0, -1, 0, 0)\\n}\\n// countInfections: (grid: Map[Int,Map[Int,Char]], iterations: Int, infectionStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)])Int\\n\\nval basicStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\\n  case (dx, dy, '.') => (dy, -dx, '#')\\n  case (dx, dy, '#') => (-dy, dx, '.')\\n}\\n// basicStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = <function1>\\n```\\n\\nThese can now be tested.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day22Part1Test extends FunSuite with Matchers {\\n  test(\\\"can parse input\\\") {\\n    parseInput(\\n      \\\"\\\"\\\"..#\\n        |#..\\n        |...\\\"\\\"\\\".stripMargin.lines.toSeq\\n    ) shouldBe Map(\\n      -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n      0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n      1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n    )\\n  }\\n\\n  test(\\\"can count infections\\\") {\\n    countInfections(\\n      Map(\\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n      ),\\n      7,\\n      basicStrategy\\n    ) shouldBe 5\\n    countInfections(\\n      Map(\\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n      ),\\n      70,\\n      basicStrategy\\n    ) shouldBe 41\\n    countInfections(\\n      Map(\\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n      ),\\n      10000,\\n      basicStrategy\\n    ) shouldBe 5587\\n  }\\n}\\n// defined class Day22Part1Test\\n\\n(new Day22Part1Test).execute()\\n// Day22Part1Test:\\n// - can parse input\\n// - can count infections\\n```\\n\\nNow I can let the virus loose on the puzzle input\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval input = parseInput(Source.fromResource(\\\"day22input.txt\\\").getLines().toSeq)\\n// input: Map[Int,Map[Int,Char]] = Map(0 -> Map(0 -> #, 5 -> #, 10 -> ., -7 -> ., -8 -> #, -3 -> #, -12 -> ., 1 -> ., 6 -> #, -11 -> ., -4 -> ., 9 -> #, 2 -> ., -5 -> ., 12 -> ., -10 -> ., 7 -> ., 3 -> #, -1 -> ., 11 -> ., -9 -> ., 8 -> #, -6 -> ., 4 -> #, -2 -> .), 5 -> Map(0 -> ., 5 -> #, 10 -> ., -7 -> ., -8 -> ., -3 -> ., -12 -> ., 1 -> ., 6 -> #, -11 -> #, -4 -> #, 9 -> #, 2 -> ., -5 -> #, 12 -> #, -10 -> #, 7 -> #, 3 -> ., -1 -> ., 11 -> #, -9 -> ., 8 -> ., -6 -> ., 4 -> #, -2 -> .), 10 -> Map(0 -> #, 5 -> ., 10 -> ., -7 -> ., -8 -> ., -3 -> #, -12 -> ., 1 -> #, 6 -> ., -11 -> ., -4 -> #, 9 -> ., 2 -> #, -5 -> #, 12 -> #, -10 -> #, 7 -> ., 3 -> ., -1 -> #, 11 -> #, -9 -> ., 8 -> #, -6 -> #, 4 -> ., -2 -> #), -7 -> Map(0 -> #, 5 -> #, 10 -> ., -7 -> ., -8 -> ., -3 -> #, -12 -> #, 1 ->...\\n\\ncountInfections(input, 10000, basicStrategy)\\n// res1: Int = 5259\\n```\\n\\n## Part 2\\n\\nAs I briefly mentioned above, my code from part one was mostly reusable for part\\n2. I factored out the step that produced the character to write at the current\\nposition, and the new direction. Once this was done and working with the \\noriginal tests, I then wrote the updated function to handle the evolved virus,\\nand tested it against the puzzle example.\\n\\n```scala\\nval evolvedStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\\n  case (dx, dy, '.') => (dy, -dx, 'W')\\n  case (dx, dy, 'W') => (dx, dy, '#')\\n  case (dx, dy, '#') => (-dy, dx, 'F')\\n  case (dx, dy, 'F') => (-dx, -dy, '.')\\n}\\n// evolvedStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = <function1>\\n\\nclass Day22Part2Test extends FunSuite with Matchers {\\n  test(\\\"can evolve\\\"){\\n    countInfections(\\n      Map(\\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n      ),\\n      100,\\n      evolvedStrategy\\n    ) shouldBe 26\\n    countInfections(\\n      Map(\\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\\n      ),\\n      10000000,\\n      evolvedStrategy\\n    ) shouldBe 2511944\\n  }\\n}\\n// defined class Day22Part2Test\\n\\n(new Day22Part2Test).execute()\\n// Day22Part2Test:\\n// - can evolve\\n```\\n\\nMy solution handled the increased iteration count fine, running both parts in\\nabout 5 seconds.\\n\\n```scala\\ncountInfections(input, 10000000, evolvedStrategy)\\n// res3: Int = 2511722\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/22\">Advent of Code 2017 - Day 22</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>I put the grid into a map as I can just add extra values as the position expands<br>\noutside the current grid, and the Map implementation handles adding the<br>\nunderlying data for me.</p>\n<pre><code class=\"language-scala\">def parseInput(lines: Seq[String]): Map[Int, Map[Int, Char]] = (\n  lines.zipWithIndex\n      .map {\n        case (line, index) =&gt;\n          index - (lines.size / 2) -&gt;\n            line.zipWithIndex.map {\n              case (c, i) =&gt; i - (line.length / 2) -&gt; c\n            }.toMap\n      }.toMap\n)\n// parseInput: (lines: Seq[String])Map[Int,Map[Int,Char]]\n</code></pre>\n<p>I started with an implementation that had the progress to next stage strategy<br>\nembedded within it, but factored this out into an argument to enable me to use<br>\nthe same code for part 2.</p>\n<pre><code class=\"language-scala\">def countInfections(grid: Map[Int, Map[Int, Char]],\n                    iterations: Int,\n                    infectionStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)]): Int = {\n  def iter(grid: Map[Int, Map[Int, Char]],\n           x: Int, y: Int,\n           dx:Int, dy: Int,\n           count: Int, infectionCount: Int): Int = {\n    if(count == iterations) return infectionCount\n\n    val status = grid.getOrElse(y, Map.empty).getOrElse(x, '.')\n    val (ndx, ndy, nStatus) = infectionStrategy((dx, dy, status))\n    val nICount = if(nStatus == '#') infectionCount + 1 else infectionCount\n    iter(\n      grid.updated(y, grid.getOrElse(y, Map.empty).updated(x, nStatus)),\n      x + ndx, y + ndy,\n      ndx, ndy,\n      count + 1, nICount\n    )\n  }\n\n  iter(grid, 0, 0, 0, -1, 0, 0)\n}\n// countInfections: (grid: Map[Int,Map[Int,Char]], iterations: Int, infectionStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)])Int\n\nval basicStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\n  case (dx, dy, '.') =&gt; (dy, -dx, '#')\n  case (dx, dy, '#') =&gt; (-dy, dx, '.')\n}\n// basicStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = &lt;function1&gt;\n</code></pre>\n<p>These can now be tested.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day22Part1Test extends FunSuite with Matchers {\n  test(&quot;can parse input&quot;) {\n    parseInput(\n      &quot;&quot;&quot;..#\n        |#..\n        |...&quot;&quot;&quot;.stripMargin.lines.toSeq\n    ) shouldBe Map(\n      -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n      0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n      1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n    )\n  }\n\n  test(&quot;can count infections&quot;) {\n    countInfections(\n      Map(\n        -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n        0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n        1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n      ),\n      7,\n      basicStrategy\n    ) shouldBe 5\n    countInfections(\n      Map(\n        -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n        0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n        1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n      ),\n      70,\n      basicStrategy\n    ) shouldBe 41\n    countInfections(\n      Map(\n        -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n        0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n        1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n      ),\n      10000,\n      basicStrategy\n    ) shouldBe 5587\n  }\n}\n// defined class Day22Part1Test\n\n(new Day22Part1Test).execute()\n// Day22Part1Test:\n// - can parse input\n// - can count infections\n</code></pre>\n<p>Now I can let the virus loose on the puzzle input</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(&quot;day22input.txt&quot;).getLines().toSeq)\n// input: Map[Int,Map[Int,Char]] = Map(0 -&gt; Map(0 -&gt; #, 5 -&gt; #, 10 -&gt; ., -7 -&gt; ., -8 -&gt; #, -3 -&gt; #, -12 -&gt; ., 1 -&gt; ., 6 -&gt; #, -11 -&gt; ., -4 -&gt; ., 9 -&gt; #, 2 -&gt; ., -5 -&gt; ., 12 -&gt; ., -10 -&gt; ., 7 -&gt; ., 3 -&gt; #, -1 -&gt; ., 11 -&gt; ., -9 -&gt; ., 8 -&gt; #, -6 -&gt; ., 4 -&gt; #, -2 -&gt; .), 5 -&gt; Map(0 -&gt; ., 5 -&gt; #, 10 -&gt; ., -7 -&gt; ., -8 -&gt; ., -3 -&gt; ., -12 -&gt; ., 1 -&gt; ., 6 -&gt; #, -11 -&gt; #, -4 -&gt; #, 9 -&gt; #, 2 -&gt; ., -5 -&gt; #, 12 -&gt; #, -10 -&gt; #, 7 -&gt; #, 3 -&gt; ., -1 -&gt; ., 11 -&gt; #, -9 -&gt; ., 8 -&gt; ., -6 -&gt; ., 4 -&gt; #, -2 -&gt; .), 10 -&gt; Map(0 -&gt; #, 5 -&gt; ., 10 -&gt; ., -7 -&gt; ., -8 -&gt; ., -3 -&gt; #, -12 -&gt; ., 1 -&gt; #, 6 -&gt; ., -11 -&gt; ., -4 -&gt; #, 9 -&gt; ., 2 -&gt; #, -5 -&gt; #, 12 -&gt; #, -10 -&gt; #, 7 -&gt; ., 3 -&gt; ., -1 -&gt; #, 11 -&gt; #, -9 -&gt; ., 8 -&gt; #, -6 -&gt; #, 4 -&gt; ., -2 -&gt; #), -7 -&gt; Map(0 -&gt; #, 5 -&gt; #, 10 -&gt; ., -7 -&gt; ., -8 -&gt; ., -3 -&gt; #, -12 -&gt; #, 1 -&gt;...\n\ncountInfections(input, 10000, basicStrategy)\n// res1: Int = 5259\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>As I briefly mentioned above, my code from part one was mostly reusable for part<br>\n2. I factored out the step that produced the character to write at the current<br>\nposition, and the new direction. Once this was done and working with the<br>\noriginal tests, I then wrote the updated function to handle the evolved virus,<br>\nand tested it against the puzzle example.</p>\n<pre><code class=\"language-scala\">val evolvedStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\n  case (dx, dy, '.') =&gt; (dy, -dx, 'W')\n  case (dx, dy, 'W') =&gt; (dx, dy, '#')\n  case (dx, dy, '#') =&gt; (-dy, dx, 'F')\n  case (dx, dy, 'F') =&gt; (-dx, -dy, '.')\n}\n// evolvedStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = &lt;function1&gt;\n\nclass Day22Part2Test extends FunSuite with Matchers {\n  test(&quot;can evolve&quot;){\n    countInfections(\n      Map(\n        -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n        0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n        1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n      ),\n      100,\n      evolvedStrategy\n    ) shouldBe 26\n    countInfections(\n      Map(\n        -1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '#'),\n        0 -&gt; Map(-1 -&gt; '#', 0 -&gt; '.', 1 -&gt; '.'),\n        1 -&gt; Map(-1 -&gt; '.', 0 -&gt; '.', 1 -&gt; '.')\n      ),\n      10000000,\n      evolvedStrategy\n    ) shouldBe 2511944\n  }\n}\n// defined class Day22Part2Test\n\n(new Day22Part2Test).execute()\n// Day22Part2Test:\n// - can evolve\n</code></pre>\n<p>My solution handled the increased iteration count fine, running both parts in<br>\nabout 5 seconds.</p>\n<pre><code class=\"language-scala\">countInfections(input, 10000000, evolvedStrategy)\n// res3: Int = 2511722\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5a4d38e29c9605113d0a4a0b","plaintext":"A solution for Advent of Code 2017 - Day 22\n[http://adventofcode.com/2017/day/22]\n\nPart 1\nI put the grid into a map as I can just add extra values as the position expands\noutside the current grid, and the Map implementation handles adding the\nunderlying data for me.\n\ndef parseInput(lines: Seq[String]): Map[Int, Map[Int, Char]] = (\n  lines.zipWithIndex\n      .map {\n        case (line, index) =>\n          index - (lines.size / 2) ->\n            line.zipWithIndex.map {\n              case (c, i) => i - (line.length / 2) -> c\n            }.toMap\n      }.toMap\n)\n// parseInput: (lines: Seq[String])Map[Int,Map[Int,Char]]\n\n\nI started with an implementation that had the progress to next stage strategy\nembedded within it, but factored this out into an argument to enable me to use\nthe same code for part 2.\n\ndef countInfections(grid: Map[Int, Map[Int, Char]],\n                    iterations: Int,\n                    infectionStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)]): Int = {\n  def iter(grid: Map[Int, Map[Int, Char]],\n           x: Int, y: Int,\n           dx:Int, dy: Int,\n           count: Int, infectionCount: Int): Int = {\n    if(count == iterations) return infectionCount\n\n    val status = grid.getOrElse(y, Map.empty).getOrElse(x, '.')\n    val (ndx, ndy, nStatus) = infectionStrategy((dx, dy, status))\n    val nICount = if(nStatus == '#') infectionCount + 1 else infectionCount\n    iter(\n      grid.updated(y, grid.getOrElse(y, Map.empty).updated(x, nStatus)),\n      x + ndx, y + ndy,\n      ndx, ndy,\n      count + 1, nICount\n    )\n  }\n\n  iter(grid, 0, 0, 0, -1, 0, 0)\n}\n// countInfections: (grid: Map[Int,Map[Int,Char]], iterations: Int, infectionStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)])Int\n\nval basicStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\n  case (dx, dy, '.') => (dy, -dx, '#')\n  case (dx, dy, '#') => (-dy, dx, '.')\n}\n// basicStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = <function1>\n\n\nThese can now be tested.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day22Part1Test extends FunSuite with Matchers {\n  test(\"can parse input\") {\n    parseInput(\n      \"\"\"..#\n        |#..\n        |...\"\"\".stripMargin.lines.toSeq\n    ) shouldBe Map(\n      -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n      0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n      1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n    )\n  }\n\n  test(\"can count infections\") {\n    countInfections(\n      Map(\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n      ),\n      7,\n      basicStrategy\n    ) shouldBe 5\n    countInfections(\n      Map(\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n      ),\n      70,\n      basicStrategy\n    ) shouldBe 41\n    countInfections(\n      Map(\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n      ),\n      10000,\n      basicStrategy\n    ) shouldBe 5587\n  }\n}\n// defined class Day22Part1Test\n\n(new Day22Part1Test).execute()\n// Day22Part1Test:\n// - can parse input\n// - can count infections\n\n\nNow I can let the virus loose on the puzzle input\n\nimport scala.io.Source\n// import scala.io.Source\n\nval input = parseInput(Source.fromResource(\"day22input.txt\").getLines().toSeq)\n// input: Map[Int,Map[Int,Char]] = Map(0 -> Map(0 -> #, 5 -> #, 10 -> ., -7 -> ., -8 -> #, -3 -> #, -12 -> ., 1 -> ., 6 -> #, -11 -> ., -4 -> ., 9 -> #, 2 -> ., -5 -> ., 12 -> ., -10 -> ., 7 -> ., 3 -> #, -1 -> ., 11 -> ., -9 -> ., 8 -> #, -6 -> ., 4 -> #, -2 -> .), 5 -> Map(0 -> ., 5 -> #, 10 -> ., -7 -> ., -8 -> ., -3 -> ., -12 -> ., 1 -> ., 6 -> #, -11 -> #, -4 -> #, 9 -> #, 2 -> ., -5 -> #, 12 -> #, -10 -> #, 7 -> #, 3 -> ., -1 -> ., 11 -> #, -9 -> ., 8 -> ., -6 -> ., 4 -> #, -2 -> .), 10 -> Map(0 -> #, 5 -> ., 10 -> ., -7 -> ., -8 -> ., -3 -> #, -12 -> ., 1 -> #, 6 -> ., -11 -> ., -4 -> #, 9 -> ., 2 -> #, -5 -> #, 12 -> #, -10 -> #, 7 -> ., 3 -> ., -1 -> #, 11 -> #, -9 -> ., 8 -> #, -6 -> #, 4 -> ., -2 -> #), -7 -> Map(0 -> #, 5 -> #, 10 -> ., -7 -> ., -8 -> ., -3 -> #, -12 -> #, 1 ->...\n\ncountInfections(input, 10000, basicStrategy)\n// res1: Int = 5259\n\n\nPart 2\nAs I briefly mentioned above, my code from part one was mostly reusable for part\n2. I factored out the step that produced the character to write at the current\nposition, and the new direction. Once this was done and working with the\noriginal tests, I then wrote the updated function to handle the evolved virus,\nand tested it against the puzzle example.\n\nval evolvedStrategy: PartialFunction[(Int, Int, Char), (Int, Int, Char)] = {\n  case (dx, dy, '.') => (dy, -dx, 'W')\n  case (dx, dy, 'W') => (dx, dy, '#')\n  case (dx, dy, '#') => (-dy, dx, 'F')\n  case (dx, dy, 'F') => (-dx, -dy, '.')\n}\n// evolvedStrategy: PartialFunction[(Int, Int, Char),(Int, Int, Char)] = <function1>\n\nclass Day22Part2Test extends FunSuite with Matchers {\n  test(\"can evolve\"){\n    countInfections(\n      Map(\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n      ),\n      100,\n      evolvedStrategy\n    ) shouldBe 26\n    countInfections(\n      Map(\n        -1 -> Map(-1 -> '.', 0 -> '.', 1 -> '#'),\n        0 -> Map(-1 -> '#', 0 -> '.', 1 -> '.'),\n        1 -> Map(-1 -> '.', 0 -> '.', 1 -> '.')\n      ),\n      10000000,\n      evolvedStrategy\n    ) shouldBe 2511944\n  }\n}\n// defined class Day22Part2Test\n\n(new Day22Part2Test).execute()\n// Day22Part2Test:\n// - can evolve\n\n\nMy solution handled the increased iteration count fine, running both parts in\nabout 5 seconds.\n\ncountInfections(input, 10000000, evolvedStrategy)\n// res3: Int = 2511722","feature_image":"__GHOST_URL__/content/images/2018/01/AoC-banner.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2018-01-03T20:11:14.000Z","updated_at":"2018-01-03T20:13:33.000Z","published_at":"2017-12-29T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 22","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5a4d5fde9c9605113d0a4a12","uuid":"46b82b4e-6d20-40bf-9880-aa073e9aa4d7","title":"Coprocessor Conflagration","slug":"aoc-2017-day-23-coprocessor-conflagration","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 23](http://adventofcode.com/2017/day/23)\\n\\n## Part 1\\n\\nThe first part of today's task is a reworking of [day 18 part 1](/aoc-2017-day-18-duet). As I mentioned in my write up of that, there were some lessons I learnt from solving part 2 that I wanted to work back into my parser. \\n\\nFirstly there was a bug where by I had been treating the first column of values as always being references, and this didn't hold. Splitting out the value type in the regex as before was very hard to read, so I factored that out into a function that was called for each match that could be either type. Secondly passing in the current registers when trying to extract a value from an instruction caused a lot of noise and it was hard to read, so I used implicits to hide the boiler-plate.\\n\\n```scala\\nsealed trait Value {\\n  def read(implicit registers: Map[Char, Long]): Long\\n}\\n// defined trait Value\\n\\ncase class Ref(register: Char) extends Value {\\n  override def read(implicit registers: Map[Char, Long]): Long =\\n    registers.getOrElse(register, 0)\\n}\\n// defined class Ref\\n\\ncase class Literal(value: Long) extends Value {\\n  override def read(implicit registers: Map[Char, Long]): Long = value\\n}\\n// defined class Literal\\n\\ncase class Instruction(command: String, value1: Value, value2: Value)\\n// defined class Instruction\\n\\nimplicit def valueFromString(str: String): Value = (\\n  if (str.matches(\\\"[a-z]\\\")) Ref(str.charAt(0))\\n  else Literal(str.toLong)\\n)\\n// warning: there was one feature warning; for details, enable `:setting -feature' or `:replay -feature'\\n// valueFromString: (str: String)Value\\n\\nval LineMatcher = \\\"(set|sub|mul|jnz) ([a-z]|-?\\\\\\\\d+) ([a-z]|-?\\\\\\\\d+)\\\".r\\n// LineMatcher: scala.util.matching.Regex = (set|sub|mul|jnz) ([a-z]|-?\\\\d+) ([a-z]|-?\\\\d+)\\n\\ndef instFromLine(line: String): Instruction = line match {\\n  case LineMatcher(c, v1, v2) => Instruction(c, v1, v2)\\n}\\n// instFromLine: (line: String)Instruction\\n\\ndef countMults(program: Vector[Instruction], regs: Map[Char, Long] = Map.empty): Int = {\\n  def iter(registers: Map[Char, Long], position: Int, mulCount: Int): Int = {\\n    if (!program.isDefinedAt(position)) mulCount\\n    else {\\n      implicit val _ = registers\\n      program(position) match {\\n        case Instruction(\\\"set\\\", Ref(r), v2) =>\\n          iter(registers.updated(r, v2.read), position + 1, mulCount)\\n        case Instruction(\\\"sub\\\", Ref(r), v2) =>\\n          iter(registers.updated(r, registers(r) - v2.read), position + 1, mulCount)\\n        case Instruction(\\\"mul\\\", Ref(r), v2) =>\\n          iter(registers.updated(r, registers(r) * v2.read), position + 1, mulCount + 1)\\n        case Instruction(\\\"jnz\\\", v1, v2) =>\\n          iter(registers, if (v1.read != 0) position + v2.read.toInt else position + 1, mulCount)\\n      }\\n    }\\n  }\\n\\n  iter(regs.withDefaultValue(0), 0, 0)\\n}\\n// <console>:22: warning: match may not be exhaustive.\\n// It would fail on the following inputs: Instruction(\\\"mul\\\", Literal(_), _), Instruction(\\\"set\\\", Literal(_), _), Instruction(\\\"sub\\\", Literal(_), _), Instruction((x: String forSome x not in (\\\"jnz\\\", \\\"mul\\\", \\\"set\\\", \\\"sub\\\")), Literal(_), _), Instruction((x: String forSome x not in (\\\"jnz\\\", \\\"mul\\\", \\\"set\\\", \\\"sub\\\")), Ref(_), _), Instruction(String(), Literal(_), _)\\n//              program(position) match {\\n//                     ^\\n// countMults: (program: Vector[Instruction], regs: Map[Char,Long])Int\\n```\\n\\nI created an example instruction for each of the possible instruction types and made sure to include the static jnz test that was missing last time and caught me out. I also built a small test program to check that the interpreter was correct.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day23Part1Test extends FunSuite with Matchers {\\n\\n  test(\\\"testInstFromLine\\\") {\\n    instFromLine(\\\"sub a 23\\\") shouldBe Instruction(\\\"sub\\\", Ref('a'), Literal(23))\\n    instFromLine(\\\"mul b -2\\\") shouldBe Instruction(\\\"mul\\\", Ref('b'), Literal(-2))\\n    instFromLine(\\\"set b 4\\\") shouldBe Instruction(\\\"set\\\", Ref('b'), Literal(4))\\n    instFromLine(\\\"jnz c d\\\") shouldBe Instruction(\\\"jnz\\\", Ref('c'), Ref('d'))\\n    instFromLine(\\\"jnz 1 2\\\") shouldBe Instruction(\\\"jnz\\\", Literal(1), Literal(2))\\n  }\\n\\n  test(\\\"testCountMults\\\") {\\n    countMults(\\n      \\\"\\\"\\\"set a 4\\n        |set b 1\\n        |mul b a\\n        |jnz a 2\\n        |jnz 1 3\\n        |sub a 1\\n        |jnz 1 -4\\\"\\\"\\\".stripMargin.lines.map(instFromLine).toVector\\n    ) shouldBe 5\\n\\n    countMults(\\n      \\\"\\\"\\\"set a 8\\n        |set b 1\\n        |mul b a\\n        |jnz a 2\\n        |jnz 1 3\\n        |sub a 1\\n        |jnz 1 -4\\\"\\\"\\\".stripMargin.lines.map(instFromLine).toVector\\n    ) shouldBe 9\\n  }\\n\\n}\\n// defined class Day23Part1Test\\n\\n(new Day23Part1Test).execute()\\n// Day23Part1Test:\\n// - testInstFromLine\\n// - testCountMults\\n``` \\n\\nWith this in place I can get the `mul` instruction count when running the code.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval program = (\\n  Source.fromResource(\\\"day23input.txt\\\")\\n    .getLines()\\n    .map(instFromLine)\\n    .toVector\\n)\\n// program: Vector[Instruction] = Vector(Instruction(set,Ref(b),Literal(79)), Instruction(set,Ref(c),Ref(b)), Instruction(jnz,Ref(a),Literal(2)), Instruction(jnz,Literal(1),Literal(5)), Instruction(mul,Ref(b),Literal(100)), Instruction(sub,Ref(b),Literal(-100000)), Instruction(set,Ref(c),Ref(b)), Instruction(sub,Ref(c),Literal(-17000)), Instruction(set,Ref(f),Literal(1)), Instruction(set,Ref(d),Literal(2)), Instruction(set,Ref(e),Literal(2)), Instruction(set,Ref(g),Ref(d)), Instruction(mul,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(2)), Instruction(set,Ref(f),Literal(0)), Instruction(sub,Ref(e),Literal(-1)), Instruction(set,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(-8)), Instruction(sub,Ref(d),Literal(-1)), Instructio...\\n\\ncountMults(program)\\n// res1: Int = 5929\\n```\\n\\n## Part 2\\n\\nFor part two I initially tried running the code with the debug flag `a` set: `countMults(program, Map('a' -> 1))`, but this was obviously not going to complete anytime soon. I put in a few debug `println`s to try and get a handle on what was going on and ended up annotating and optimising the program in place.\\n\\nThe first section is just initialisation, and is how the value of `a` actually influences the execution. \\n```\\n  set b 79       | Intiialise b and c, this is where diferent  \\n  set c b        | coders' inputs were differentiated. In my \\n  jnz a 2        | case, 79.\\n  jnz 1 5        | Then if a != 0 multiply by 100, add 100,000,\\n  mul b 100      | and add 17000 to c. Which is how the scale\\n  sub b -100000  | problems I encountered were introduced:\\n  set c b        | - a=0: Two nested loops go from 2 to 79\\n  sub c -17000   | - a=1: 1,000 x above, loops are 2 to 107,900+ \\n```\\n\\nFrom there there are a number of loops. I've labeled the jnz targets below on the left. Then it is noticeable that g is often used in a pattern:\\n\\n* Set g = var1\\n* Subtract var2 from g\\n* If g != 0 skip the next line or restart the current loop\\n\\nWhich is equivalent to if(var1 == var2) set a thing or break out of the current loop. I've broken the program down to the loop structure, and factored out the lines using g into the equivalent if statements.  \\n```\\nG: set f 1       | :outer loop {\\n   set d 2       |   set f = 1, d = 2\\nC: set e 2       |   :middle loop {\\n                 |      set e = 2\\nB: set g d       |      :inner loop {\\n   mul g e       |        \\n   sub g b       |        \\n>A jnz g 2       |        if (d * e == b) set f = 0\\n   set f 0       |        \\nA: sub e -1      |        \\n   set g e       |        \\n   sub g b       |        if(e++ == b) break\\n>B jnz g -8      |      }\\n   sub d -1      |      \\n   set g d       |      \\n   sub g b       |      if(d++ == b) break\\n>C jnz g -13     |   } \\n>D jnz f 2       |   \\n   sub h -1      |   if (f == 0) h++\\nD: set g b       |   \\n   sub g c       |   \\n>E jnz g 2       |   if(b == c) exit  \\n>? jnz 1 3       |   \\nE: sub b -17     |   b += 17\\n>G jnz 1 -23     | }\\n```\\n\\nThe inner loop and middle loops are essentially looping `d` and `e` through all the integers between 2 and the current `b` setting a flag if `d * e == b`, but still completing both loops. The inner loop can be refactored into `if (b % d == 0) f = true`. If this is ever true it is more optimal to break out of both loops immediately. It can also be optimised break out of the middle loop once the counter exceeds `b`. This means I can write the middle loop in Scala as:\\n\\n```scala\\ndef hasFactor(b: Int): Boolean = {\\n  val rootB = Math.sqrt(b).toInt\\n\\n  def iter(d: Int): Boolean = {\\n    if(d > rootB) return false\\n    if(b % d == 0) return true\\n    iter(d + 1)\\n  }\\n\\n  iter(2)\\n}\\n// hasFactor: (b: Int)Boolean\\n```\\n\\nThe outer loop is then incrementing b by 17 each time and incrementing a counter if b has a factor. Incorporating the initialisation from the initial value of `b` which then makes this a general implementation for any of the individual puzzle inputs as far as I can tell:\\n\\n```scala\\ndef decomposed(seed: Int): Int =\\n{\\n  val start = seed * 100 + 100000\\n  val end = start + 17000\\n\\n  def iter(b: Int, h: Int = 0): Int = {\\n    if(b > end) return h\\n    iter(b + 17, if(hasFactor(b)) h + 1 else h)\\n  }\\n\\n  iter(start)\\n}\\n// decomposed: (seed: Int)Int\\n\\ndecomposed(79)\\n// res2: Int = 907\\n```\\n\\nIt is worth noting that whilst there is nothing obvious to be done about the inefficient modulus with the instruction set available, the early break can be implemented. Given that 907 of the 1000 outer loops would then break after less than 124,900 iterations of the middle loop. This probably isn't enough to make it viable, but still a major improvement. The change would be fairly simple: add `jnz 1 9` after `set f = 0`, and increment the `jnz` instructions for the loops outside that by 1 to account for the extra instruction.\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/23\">Advent of Code 2017 - Day 23</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>The first part of today's task is a reworking of <a href=\"/aoc-2017-day-18-duet\">day 18 part 1</a>. As I mentioned in my write up of that, there were some lessons I learnt from solving part 2 that I wanted to work back into my parser.</p>\n<p>Firstly there was a bug where by I had been treating the first column of values as always being references, and this didn't hold. Splitting out the value type in the regex as before was very hard to read, so I factored that out into a function that was called for each match that could be either type. Secondly passing in the current registers when trying to extract a value from an instruction caused a lot of noise and it was hard to read, so I used implicits to hide the boiler-plate.</p>\n<pre><code class=\"language-scala\">sealed trait Value {\n  def read(implicit registers: Map[Char, Long]): Long\n}\n// defined trait Value\n\ncase class Ref(register: Char) extends Value {\n  override def read(implicit registers: Map[Char, Long]): Long =\n    registers.getOrElse(register, 0)\n}\n// defined class Ref\n\ncase class Literal(value: Long) extends Value {\n  override def read(implicit registers: Map[Char, Long]): Long = value\n}\n// defined class Literal\n\ncase class Instruction(command: String, value1: Value, value2: Value)\n// defined class Instruction\n\nimplicit def valueFromString(str: String): Value = (\n  if (str.matches(&quot;[a-z]&quot;)) Ref(str.charAt(0))\n  else Literal(str.toLong)\n)\n// warning: there was one feature warning; for details, enable `:setting -feature' or `:replay -feature'\n// valueFromString: (str: String)Value\n\nval LineMatcher = &quot;(set|sub|mul|jnz) ([a-z]|-?\\\\d+) ([a-z]|-?\\\\d+)&quot;.r\n// LineMatcher: scala.util.matching.Regex = (set|sub|mul|jnz) ([a-z]|-?\\d+) ([a-z]|-?\\d+)\n\ndef instFromLine(line: String): Instruction = line match {\n  case LineMatcher(c, v1, v2) =&gt; Instruction(c, v1, v2)\n}\n// instFromLine: (line: String)Instruction\n\ndef countMults(program: Vector[Instruction], regs: Map[Char, Long] = Map.empty): Int = {\n  def iter(registers: Map[Char, Long], position: Int, mulCount: Int): Int = {\n    if (!program.isDefinedAt(position)) mulCount\n    else {\n      implicit val _ = registers\n      program(position) match {\n        case Instruction(&quot;set&quot;, Ref(r), v2) =&gt;\n          iter(registers.updated(r, v2.read), position + 1, mulCount)\n        case Instruction(&quot;sub&quot;, Ref(r), v2) =&gt;\n          iter(registers.updated(r, registers(r) - v2.read), position + 1, mulCount)\n        case Instruction(&quot;mul&quot;, Ref(r), v2) =&gt;\n          iter(registers.updated(r, registers(r) * v2.read), position + 1, mulCount + 1)\n        case Instruction(&quot;jnz&quot;, v1, v2) =&gt;\n          iter(registers, if (v1.read != 0) position + v2.read.toInt else position + 1, mulCount)\n      }\n    }\n  }\n\n  iter(regs.withDefaultValue(0), 0, 0)\n}\n// &lt;console&gt;:22: warning: match may not be exhaustive.\n// It would fail on the following inputs: Instruction(&quot;mul&quot;, Literal(_), _), Instruction(&quot;set&quot;, Literal(_), _), Instruction(&quot;sub&quot;, Literal(_), _), Instruction((x: String forSome x not in (&quot;jnz&quot;, &quot;mul&quot;, &quot;set&quot;, &quot;sub&quot;)), Literal(_), _), Instruction((x: String forSome x not in (&quot;jnz&quot;, &quot;mul&quot;, &quot;set&quot;, &quot;sub&quot;)), Ref(_), _), Instruction(String(), Literal(_), _)\n//              program(position) match {\n//                     ^\n// countMults: (program: Vector[Instruction], regs: Map[Char,Long])Int\n</code></pre>\n<p>I created an example instruction for each of the possible instruction types and made sure to include the static jnz test that was missing last time and caught me out. I also built a small test program to check that the interpreter was correct.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day23Part1Test extends FunSuite with Matchers {\n\n  test(&quot;testInstFromLine&quot;) {\n    instFromLine(&quot;sub a 23&quot;) shouldBe Instruction(&quot;sub&quot;, Ref('a'), Literal(23))\n    instFromLine(&quot;mul b -2&quot;) shouldBe Instruction(&quot;mul&quot;, Ref('b'), Literal(-2))\n    instFromLine(&quot;set b 4&quot;) shouldBe Instruction(&quot;set&quot;, Ref('b'), Literal(4))\n    instFromLine(&quot;jnz c d&quot;) shouldBe Instruction(&quot;jnz&quot;, Ref('c'), Ref('d'))\n    instFromLine(&quot;jnz 1 2&quot;) shouldBe Instruction(&quot;jnz&quot;, Literal(1), Literal(2))\n  }\n\n  test(&quot;testCountMults&quot;) {\n    countMults(\n      &quot;&quot;&quot;set a 4\n        |set b 1\n        |mul b a\n        |jnz a 2\n        |jnz 1 3\n        |sub a 1\n        |jnz 1 -4&quot;&quot;&quot;.stripMargin.lines.map(instFromLine).toVector\n    ) shouldBe 5\n\n    countMults(\n      &quot;&quot;&quot;set a 8\n        |set b 1\n        |mul b a\n        |jnz a 2\n        |jnz 1 3\n        |sub a 1\n        |jnz 1 -4&quot;&quot;&quot;.stripMargin.lines.map(instFromLine).toVector\n    ) shouldBe 9\n  }\n\n}\n// defined class Day23Part1Test\n\n(new Day23Part1Test).execute()\n// Day23Part1Test:\n// - testInstFromLine\n// - testCountMults\n</code></pre>\n<p>With this in place I can get the <code>mul</code> instruction count when running the code.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval program = (\n  Source.fromResource(&quot;day23input.txt&quot;)\n    .getLines()\n    .map(instFromLine)\n    .toVector\n)\n// program: Vector[Instruction] = Vector(Instruction(set,Ref(b),Literal(79)), Instruction(set,Ref(c),Ref(b)), Instruction(jnz,Ref(a),Literal(2)), Instruction(jnz,Literal(1),Literal(5)), Instruction(mul,Ref(b),Literal(100)), Instruction(sub,Ref(b),Literal(-100000)), Instruction(set,Ref(c),Ref(b)), Instruction(sub,Ref(c),Literal(-17000)), Instruction(set,Ref(f),Literal(1)), Instruction(set,Ref(d),Literal(2)), Instruction(set,Ref(e),Literal(2)), Instruction(set,Ref(g),Ref(d)), Instruction(mul,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(2)), Instruction(set,Ref(f),Literal(0)), Instruction(sub,Ref(e),Literal(-1)), Instruction(set,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(-8)), Instruction(sub,Ref(d),Literal(-1)), Instructio...\n\ncountMults(program)\n// res1: Int = 5929\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>For part two I initially tried running the code with the debug flag <code>a</code> set: <code>countMults(program, Map('a' -&gt; 1))</code>, but this was obviously not going to complete anytime soon. I put in a few debug <code>println</code>s to try and get a handle on what was going on and ended up annotating and optimising the program in place.</p>\n<p>The first section is just initialisation, and is how the value of <code>a</code> actually influences the execution.</p>\n<pre><code>  set b 79       | Intiialise b and c, this is where diferent  \n  set c b        | coders' inputs were differentiated. In my \n  jnz a 2        | case, 79.\n  jnz 1 5        | Then if a != 0 multiply by 100, add 100,000,\n  mul b 100      | and add 17000 to c. Which is how the scale\n  sub b -100000  | problems I encountered were introduced:\n  set c b        | - a=0: Two nested loops go from 2 to 79\n  sub c -17000   | - a=1: 1,000 x above, loops are 2 to 107,900+ \n</code></pre>\n<p>From there there are a number of loops. I've labeled the jnz targets below on the left. Then it is noticeable that g is often used in a pattern:</p>\n<ul>\n<li>Set g = var1</li>\n<li>Subtract var2 from g</li>\n<li>If g != 0 skip the next line or restart the current loop</li>\n</ul>\n<p>Which is equivalent to if(var1 == var2) set a thing or break out of the current loop. I've broken the program down to the loop structure, and factored out the lines using g into the equivalent if statements.</p>\n<pre><code>G: set f 1       | :outer loop {\n   set d 2       |   set f = 1, d = 2\nC: set e 2       |   :middle loop {\n                 |      set e = 2\nB: set g d       |      :inner loop {\n   mul g e       |        \n   sub g b       |        \n&gt;A jnz g 2       |        if (d * e == b) set f = 0\n   set f 0       |        \nA: sub e -1      |        \n   set g e       |        \n   sub g b       |        if(e++ == b) break\n&gt;B jnz g -8      |      }\n   sub d -1      |      \n   set g d       |      \n   sub g b       |      if(d++ == b) break\n&gt;C jnz g -13     |   } \n&gt;D jnz f 2       |   \n   sub h -1      |   if (f == 0) h++\nD: set g b       |   \n   sub g c       |   \n&gt;E jnz g 2       |   if(b == c) exit  \n&gt;? jnz 1 3       |   \nE: sub b -17     |   b += 17\n&gt;G jnz 1 -23     | }\n</code></pre>\n<p>The inner loop and middle loops are essentially looping <code>d</code> and <code>e</code> through all the integers between 2 and the current <code>b</code> setting a flag if <code>d * e == b</code>, but still completing both loops. The inner loop can be refactored into <code>if (b % d == 0) f = true</code>. If this is ever true it is more optimal to break out of both loops immediately. It can also be optimised break out of the middle loop once the counter exceeds <code>b</code>. This means I can write the middle loop in Scala as:</p>\n<pre><code class=\"language-scala\">def hasFactor(b: Int): Boolean = {\n  val rootB = Math.sqrt(b).toInt\n\n  def iter(d: Int): Boolean = {\n    if(d &gt; rootB) return false\n    if(b % d == 0) return true\n    iter(d + 1)\n  }\n\n  iter(2)\n}\n// hasFactor: (b: Int)Boolean\n</code></pre>\n<p>The outer loop is then incrementing b by 17 each time and incrementing a counter if b has a factor. Incorporating the initialisation from the initial value of <code>b</code> which then makes this a general implementation for any of the individual puzzle inputs as far as I can tell:</p>\n<pre><code class=\"language-scala\">def decomposed(seed: Int): Int =\n{\n  val start = seed * 100 + 100000\n  val end = start + 17000\n\n  def iter(b: Int, h: Int = 0): Int = {\n    if(b &gt; end) return h\n    iter(b + 17, if(hasFactor(b)) h + 1 else h)\n  }\n\n  iter(start)\n}\n// decomposed: (seed: Int)Int\n\ndecomposed(79)\n// res2: Int = 907\n</code></pre>\n<p>It is worth noting that whilst there is nothing obvious to be done about the inefficient modulus with the instruction set available, the early break can be implemented. Given that 907 of the 1000 outer loops would then break after less than 124,900 iterations of the middle loop. This probably isn't enough to make it viable, but still a major improvement. The change would be fairly simple: add <code>jnz 1 9</code> after <code>set f = 0</code>, and increment the <code>jnz</code> instructions for the loops outside that by 1 to account for the extra instruction.</p>\n<!--kg-card-end: markdown-->","comment_id":"5a4d5fde9c9605113d0a4a12","plaintext":"A solution for Advent of Code 2017 - Day 23\n[http://adventofcode.com/2017/day/23]\n\nPart 1\nThe first part of today's task is a reworking of day 18 part 1\n[/aoc-2017-day-18-duet]. As I mentioned in my write up of that, there were some\nlessons I learnt from solving part 2 that I wanted to work back into my parser.\n\nFirstly there was a bug where by I had been treating the first column of values\nas always being references, and this didn't hold. Splitting out the value type\nin the regex as before was very hard to read, so I factored that out into a\nfunction that was called for each match that could be either type. Secondly\npassing in the current registers when trying to extract a value from an\ninstruction caused a lot of noise and it was hard to read, so I used implicits\nto hide the boiler-plate.\n\nsealed trait Value {\n  def read(implicit registers: Map[Char, Long]): Long\n}\n// defined trait Value\n\ncase class Ref(register: Char) extends Value {\n  override def read(implicit registers: Map[Char, Long]): Long =\n    registers.getOrElse(register, 0)\n}\n// defined class Ref\n\ncase class Literal(value: Long) extends Value {\n  override def read(implicit registers: Map[Char, Long]): Long = value\n}\n// defined class Literal\n\ncase class Instruction(command: String, value1: Value, value2: Value)\n// defined class Instruction\n\nimplicit def valueFromString(str: String): Value = (\n  if (str.matches(\"[a-z]\")) Ref(str.charAt(0))\n  else Literal(str.toLong)\n)\n// warning: there was one feature warning; for details, enable `:setting -feature' or `:replay -feature'\n// valueFromString: (str: String)Value\n\nval LineMatcher = \"(set|sub|mul|jnz) ([a-z]|-?\\\\d+) ([a-z]|-?\\\\d+)\".r\n// LineMatcher: scala.util.matching.Regex = (set|sub|mul|jnz) ([a-z]|-?\\d+) ([a-z]|-?\\d+)\n\ndef instFromLine(line: String): Instruction = line match {\n  case LineMatcher(c, v1, v2) => Instruction(c, v1, v2)\n}\n// instFromLine: (line: String)Instruction\n\ndef countMults(program: Vector[Instruction], regs: Map[Char, Long] = Map.empty): Int = {\n  def iter(registers: Map[Char, Long], position: Int, mulCount: Int): Int = {\n    if (!program.isDefinedAt(position)) mulCount\n    else {\n      implicit val _ = registers\n      program(position) match {\n        case Instruction(\"set\", Ref(r), v2) =>\n          iter(registers.updated(r, v2.read), position + 1, mulCount)\n        case Instruction(\"sub\", Ref(r), v2) =>\n          iter(registers.updated(r, registers(r) - v2.read), position + 1, mulCount)\n        case Instruction(\"mul\", Ref(r), v2) =>\n          iter(registers.updated(r, registers(r) * v2.read), position + 1, mulCount + 1)\n        case Instruction(\"jnz\", v1, v2) =>\n          iter(registers, if (v1.read != 0) position + v2.read.toInt else position + 1, mulCount)\n      }\n    }\n  }\n\n  iter(regs.withDefaultValue(0), 0, 0)\n}\n// <console>:22: warning: match may not be exhaustive.\n// It would fail on the following inputs: Instruction(\"mul\", Literal(_), _), Instruction(\"set\", Literal(_), _), Instruction(\"sub\", Literal(_), _), Instruction((x: String forSome x not in (\"jnz\", \"mul\", \"set\", \"sub\")), Literal(_), _), Instruction((x: String forSome x not in (\"jnz\", \"mul\", \"set\", \"sub\")), Ref(_), _), Instruction(String(), Literal(_), _)\n//              program(position) match {\n//                     ^\n// countMults: (program: Vector[Instruction], regs: Map[Char,Long])Int\n\n\nI created an example instruction for each of the possible instruction types and\nmade sure to include the static jnz test that was missing last time and caught\nme out. I also built a small test program to check that the interpreter was\ncorrect.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day23Part1Test extends FunSuite with Matchers {\n\n  test(\"testInstFromLine\") {\n    instFromLine(\"sub a 23\") shouldBe Instruction(\"sub\", Ref('a'), Literal(23))\n    instFromLine(\"mul b -2\") shouldBe Instruction(\"mul\", Ref('b'), Literal(-2))\n    instFromLine(\"set b 4\") shouldBe Instruction(\"set\", Ref('b'), Literal(4))\n    instFromLine(\"jnz c d\") shouldBe Instruction(\"jnz\", Ref('c'), Ref('d'))\n    instFromLine(\"jnz 1 2\") shouldBe Instruction(\"jnz\", Literal(1), Literal(2))\n  }\n\n  test(\"testCountMults\") {\n    countMults(\n      \"\"\"set a 4\n        |set b 1\n        |mul b a\n        |jnz a 2\n        |jnz 1 3\n        |sub a 1\n        |jnz 1 -4\"\"\".stripMargin.lines.map(instFromLine).toVector\n    ) shouldBe 5\n\n    countMults(\n      \"\"\"set a 8\n        |set b 1\n        |mul b a\n        |jnz a 2\n        |jnz 1 3\n        |sub a 1\n        |jnz 1 -4\"\"\".stripMargin.lines.map(instFromLine).toVector\n    ) shouldBe 9\n  }\n\n}\n// defined class Day23Part1Test\n\n(new Day23Part1Test).execute()\n// Day23Part1Test:\n// - testInstFromLine\n// - testCountMults\n\n\nWith this in place I can get the mul instruction count when running the code.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval program = (\n  Source.fromResource(\"day23input.txt\")\n    .getLines()\n    .map(instFromLine)\n    .toVector\n)\n// program: Vector[Instruction] = Vector(Instruction(set,Ref(b),Literal(79)), Instruction(set,Ref(c),Ref(b)), Instruction(jnz,Ref(a),Literal(2)), Instruction(jnz,Literal(1),Literal(5)), Instruction(mul,Ref(b),Literal(100)), Instruction(sub,Ref(b),Literal(-100000)), Instruction(set,Ref(c),Ref(b)), Instruction(sub,Ref(c),Literal(-17000)), Instruction(set,Ref(f),Literal(1)), Instruction(set,Ref(d),Literal(2)), Instruction(set,Ref(e),Literal(2)), Instruction(set,Ref(g),Ref(d)), Instruction(mul,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(2)), Instruction(set,Ref(f),Literal(0)), Instruction(sub,Ref(e),Literal(-1)), Instruction(set,Ref(g),Ref(e)), Instruction(sub,Ref(g),Ref(b)), Instruction(jnz,Ref(g),Literal(-8)), Instruction(sub,Ref(d),Literal(-1)), Instructio...\n\ncountMults(program)\n// res1: Int = 5929\n\n\nPart 2\nFor part two I initially tried running the code with the debug flag a set: \ncountMults(program, Map('a' -> 1)), but this was obviously not going to complete\nanytime soon. I put in a few debug printlns to try and get a handle on what was\ngoing on and ended up annotating and optimising the program in place.\n\nThe first section is just initialisation, and is how the value of a actually\ninfluences the execution.\n\n  set b 79       | Intiialise b and c, this is where diferent  \n  set c b        | coders' inputs were differentiated. In my \n  jnz a 2        | case, 79.\n  jnz 1 5        | Then if a != 0 multiply by 100, add 100,000,\n  mul b 100      | and add 17000 to c. Which is how the scale\n  sub b -100000  | problems I encountered were introduced:\n  set c b        | - a=0: Two nested loops go from 2 to 79\n  sub c -17000   | - a=1: 1,000 x above, loops are 2 to 107,900+ \n\n\nFrom there there are a number of loops. I've labeled the jnz targets below on\nthe left. Then it is noticeable that g is often used in a pattern:\n\n * Set g = var1\n * Subtract var2 from g\n * If g != 0 skip the next line or restart the current loop\n\nWhich is equivalent to if(var1 == var2) set a thing or break out of the current\nloop. I've broken the program down to the loop structure, and factored out the\nlines using g into the equivalent if statements.\n\nG: set f 1       | :outer loop {\n   set d 2       |   set f = 1, d = 2\nC: set e 2       |   :middle loop {\n                 |      set e = 2\nB: set g d       |      :inner loop {\n   mul g e       |        \n   sub g b       |        \n>A jnz g 2       |        if (d * e == b) set f = 0\n   set f 0       |        \nA: sub e -1      |        \n   set g e       |        \n   sub g b       |        if(e++ == b) break\n>B jnz g -8      |      }\n   sub d -1      |      \n   set g d       |      \n   sub g b       |      if(d++ == b) break\n>C jnz g -13     |   } \n>D jnz f 2       |   \n   sub h -1      |   if (f == 0) h++\nD: set g b       |   \n   sub g c       |   \n>E jnz g 2       |   if(b == c) exit  \n>? jnz 1 3       |   \nE: sub b -17     |   b += 17\n>G jnz 1 -23     | }\n\n\nThe inner loop and middle loops are essentially looping d and e through all the\nintegers between 2 and the current b setting a flag if d * e == b, but still\ncompleting both loops. The inner loop can be refactored into if (b % d == 0) f =\ntrue. If this is ever true it is more optimal to break out of both loops\nimmediately. It can also be optimised break out of the middle loop once the\ncounter exceeds b. This means I can write the middle loop in Scala as:\n\ndef hasFactor(b: Int): Boolean = {\n  val rootB = Math.sqrt(b).toInt\n\n  def iter(d: Int): Boolean = {\n    if(d > rootB) return false\n    if(b % d == 0) return true\n    iter(d + 1)\n  }\n\n  iter(2)\n}\n// hasFactor: (b: Int)Boolean\n\n\nThe outer loop is then incrementing b by 17 each time and incrementing a counter\nif b has a factor. Incorporating the initialisation from the initial value of b \nwhich then makes this a general implementation for any of the individual puzzle\ninputs as far as I can tell:\n\ndef decomposed(seed: Int): Int =\n{\n  val start = seed * 100 + 100000\n  val end = start + 17000\n\n  def iter(b: Int, h: Int = 0): Int = {\n    if(b > end) return h\n    iter(b + 17, if(hasFactor(b)) h + 1 else h)\n  }\n\n  iter(start)\n}\n// decomposed: (seed: Int)Int\n\ndecomposed(79)\n// res2: Int = 907\n\n\nIt is worth noting that whilst there is nothing obvious to be done about the\ninefficient modulus with the instruction set available, the early break can be\nimplemented. Given that 907 of the 1000 outer loops would then break after less\nthan 124,900 iterations of the middle loop. This probably isn't enough to make\nit viable, but still a major improvement. The change would be fairly simple: add \njnz 1 9 after set f = 0, and increment the jnz instructions for the loops\noutside that by 1 to account for the extra instruction.","feature_image":"__GHOST_URL__/content/images/2018/01/AoC-banner-1.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2018-01-03T22:57:34.000Z","updated_at":"2018-05-26T12:03:26.000Z","published_at":"2017-12-30T05:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 23","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5b094d19234d9f6a63ff360c","uuid":"f8c53220-65e1-406e-a0b9-36101c0acf1c","title":"Electromagnetic Moat","slug":"electromagnetic-moat","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 24](http://adventofcode.com/2017/day/24)\\n\\n## Part 1\\n\\nFor this task I have to build a bridge by combining pairs of integers like dominoes. Firstly I need the data in a useful representation. The components I represent as a case class, and include a unique id so that if there are any duplicated components, they still count as different when checking if they have been used before. I then build a map that can look up the components by either connector.\\n\\n```scala\\ncase class Component(id: Int, a: Int, b: Int)\\n// defined class Component\\n\\ndef parseInput(lines: Seq[String]): Map[Int, Set[Component]] = {\\n  lines\\n  .map(_.split(\\\"/\\\").toSeq)\\n  .zipWithIndex.collect {\\n    case ((a +: b +: _), id) => Component(id, a.toInt, b.toInt)\\n  }\\n  .foldLeft(Map.empty[Int, Set[Component]]) {\\n    case (acc, comp) =>\\n      acc\\n      .updated(comp.a, acc.getOrElse(comp.a, Set.empty) + comp)\\n      .updated(comp.b, acc.getOrElse(comp.b, Set.empty) + comp)\\n  }\\n}\\n// parseInput: (lines: Seq[String])Map[Int,Set[Component]]\\n```\\n\\nTo get the strongest bridge I'm just going to create all the possible bridges and find the maximum strength. This is wildly inefficient, but I can optimise it later if it turns out not to run quickly enough. \\n\\nBuilding the bridges can be done recursively. I only need to know what is in the bridge so far and how many connectors the current end piece has. From that, my pool of components is already indexed by connector count, so I can grab the viable pieces and iterate for each of the new, longer bridges.\\n\\n```scala\\ndef buildBridges(components: Map[Int, Set[Component]]): Seq[Seq[Component]] = {\\n  def iter(bridge: Seq[Component], openPort: Int): Seq[Seq[Component]] = {\\n    bridge +:\\n      components.getOrElse(openPort, Seq.empty)\\n      .filter(!bridge.contains(_))\\n      .flatMap(c => iter(c +: bridge, if (c.a == openPort) c.b else c.a)).toSeq\\n  }\\n\\n  iter(Seq.empty, 0)\\n}\\n// buildBridges: (components: Map[Int,Set[Component]])Seq[Seq[Component]]\\n\\ndef scoreBridge(bridge: Seq[Component]): Int =\\n  bridge.map(b => b.a + b.b).sum\\n// scoreBridge: (bridge: Seq[Component])Int\\n\\ndef strongestBridge(components: Map[Int, Set[Component]]): Int = {\\n  buildBridges(components)\\n  .map(scoreBridge)\\n  .max\\n  }\\n// strongestBridge: (components: Map[Int,Set[Component]])Int\\n```\\n\\nI can now parse the sample data, check that it is represented correctly, and that the output of the various stages matches the examples from the puzzle.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day24Part1Test extends FunSuite with Matchers {\\n  test(\\\"can parse input\\\") {\\n    parseInput(\\n      \\\"\\\"\\\"0/2\\n        |2/2\\n        |2/3\\n        |3/4\\n        |3/5\\n        |0/1\\n        |10/1\\n        |9/10\\\"\\\"\\\".stripMargin.lines.toSeq\\n    ) shouldBe Map(\\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\\n      4 -> Set(Component(3,3,4)),\\n      5 -> Set(Component(4,3,5)),\\n      9 -> Set(Component(7, 9,10)),\\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\\n    )\\n  }\\n  \\n  test(\\\"can build bridges\\\") {\\n    val bridges = buildBridges(Map(\\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\\n      4 -> Set(Component(3,3,4)),\\n      5 -> Set(Component(4,3,5)),\\n      9 -> Set(Component(7, 9,10)),\\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\\n    ))\\n\\n    bridges should contain(Seq(Component(5,0,1)))\\n    bridges should contain(Seq(Component(6, 10, 1), Component(5,0,1)))\\n    bridges should contain(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1)))\\n    bridges should contain(Seq(Component(0, 0, 2)))\\n    bridges should contain(Seq(Component(2, 2, 3), Component(0, 0, 2)))\\n\\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse)\\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse)\\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\\n  }\\n\\n  test(\\\"can score bridges\\\") {\\n    scoreBridge(Seq(Component(5,0,1))) shouldBe 1\\n    scoreBridge(Seq(Component(6, 10, 1), Component(5,0,1))) shouldBe 12\\n    scoreBridge(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1))) shouldBe 31\\n    scoreBridge(Seq(Component(0, 0, 2))) shouldBe 2\\n    scoreBridge(Seq(Component(2, 2, 3), Component(0, 0, 2))) shouldBe 7\\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 14\\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 15\\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse) shouldBe 6\\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse) shouldBe 11\\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 18\\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 19\\n  }\\n\\n  test(\\\"can find strongest bridge\\\") {\\n    strongestBridge(Map(\\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\\n      4 -> Set(Component(3,3,4)),\\n      5 -> Set(Component(4,3,5)),\\n      9 -> Set(Component(7, 9,10)),\\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\\n    )) shouldBe 31\\n  }\\n}\\n// defined class Day24Part1Test\\n\\n(new Day24Part1Test).execute()\\n// Day24Part1Test:\\n// - can parse input\\n// - can build bridges\\n// - can score bridges\\n// - can find strongest bridge\\n```\\n\\nI can then parse the test input and compute a result.\\n\\n```scala\\nimport scala.io.Source\\n// import scala.io.Source\\n\\nval components = parseInput(Source.fromResource(\\\"day24input.txt\\\").getLines().toSeq)\\n// components: Map[Int,Set[Component]] = Map(0 -> Set(Component(12,0,45), Component(20,0,39), Component(32,0,43)), 5 -> Set(Component(7,5,5), Component(25,5,31), Component(31,44,5), Component(36,5,37)), 42 -> Set(Component(42,42,7)), 24 -> Set(Component(0,24,14), Component(1,30,24), Component(27,20,24), Component(37,40,24)), 37 -> Set(Component(3,47,37), Component(5,20,37), Component(36,5,37)), 14 -> Set(Component(0,24,14), Component(4,6,14), Component(6,14,45)), 20 -> Set(Component(5,20,37), Component(27,20,24), Component(33,38,20), Component(34,20,16)), 46 -> Set(Component(18,46,50), Component(54,46,17)), 29 -> Set(Component(2,29,44), Component(48,29,12), Component(55,29,29)), 6 -> Set(Component(4,6,14), Component(45,6,28)), 28 -> Set(Component(45,6,28)), 38 -> Set(Component(28,38,23), C...\\n\\nstrongestBridge(components)\\n// res1: Int = 2006\\n```\\n\\n## Part 2\\n\\nSince I'm already building all the bridges, I can re-run part one, but with a different comparator. As ties are broken by strongest I can take advantage of scala already having and ordering defined for tuples of order by the first element, then second, etc.\\n\\n```scala\\ndef longestBridge(components: Map[Int, Set[Component]]): Int = {\\n  buildBridges(components)\\n  .map(b => (b.length, scoreBridge(b)))\\n  .max\\n  ._2\\n}\\n// longestBridge: (components: Map[Int,Set[Component]])Int\\n\\nclass Day24Part2Test extends FunSuite with Matchers {\\n  test(\\\"can find longest bridge\\\") {\\n    longestBridge(Map(\\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\\n      4 -> Set(Component(3,3,4)),\\n      5 -> Set(Component(4,3,5)),\\n      9 -> Set(Component(7, 9,10)),\\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\\n    )) shouldBe 19\\n  }\\n}\\n// defined class Day24Part2Test\\n\\n(new Day24Part2Test).execute()\\n// Day24Part2Test:\\n// - can find longest bridge\\n\\nlongestBridge(components)\\n// res3: Int = 1994\\n```\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/24\">Advent of Code 2017 - Day 24</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>For this task I have to build a bridge by combining pairs of integers like dominoes. Firstly I need the data in a useful representation. The components I represent as a case class, and include a unique id so that if there are any duplicated components, they still count as different when checking if they have been used before. I then build a map that can look up the components by either connector.</p>\n<pre><code class=\"language-scala\">case class Component(id: Int, a: Int, b: Int)\n// defined class Component\n\ndef parseInput(lines: Seq[String]): Map[Int, Set[Component]] = {\n  lines\n  .map(_.split(&quot;/&quot;).toSeq)\n  .zipWithIndex.collect {\n    case ((a +: b +: _), id) =&gt; Component(id, a.toInt, b.toInt)\n  }\n  .foldLeft(Map.empty[Int, Set[Component]]) {\n    case (acc, comp) =&gt;\n      acc\n      .updated(comp.a, acc.getOrElse(comp.a, Set.empty) + comp)\n      .updated(comp.b, acc.getOrElse(comp.b, Set.empty) + comp)\n  }\n}\n// parseInput: (lines: Seq[String])Map[Int,Set[Component]]\n</code></pre>\n<p>To get the strongest bridge I'm just going to create all the possible bridges and find the maximum strength. This is wildly inefficient, but I can optimise it later if it turns out not to run quickly enough.</p>\n<p>Building the bridges can be done recursively. I only need to know what is in the bridge so far and how many connectors the current end piece has. From that, my pool of components is already indexed by connector count, so I can grab the viable pieces and iterate for each of the new, longer bridges.</p>\n<pre><code class=\"language-scala\">def buildBridges(components: Map[Int, Set[Component]]): Seq[Seq[Component]] = {\n  def iter(bridge: Seq[Component], openPort: Int): Seq[Seq[Component]] = {\n    bridge +:\n      components.getOrElse(openPort, Seq.empty)\n      .filter(!bridge.contains(_))\n      .flatMap(c =&gt; iter(c +: bridge, if (c.a == openPort) c.b else c.a)).toSeq\n  }\n\n  iter(Seq.empty, 0)\n}\n// buildBridges: (components: Map[Int,Set[Component]])Seq[Seq[Component]]\n\ndef scoreBridge(bridge: Seq[Component]): Int =\n  bridge.map(b =&gt; b.a + b.b).sum\n// scoreBridge: (bridge: Seq[Component])Int\n\ndef strongestBridge(components: Map[Int, Set[Component]]): Int = {\n  buildBridges(components)\n  .map(scoreBridge)\n  .max\n  }\n// strongestBridge: (components: Map[Int,Set[Component]])Int\n</code></pre>\n<p>I can now parse the sample data, check that it is represented correctly, and that the output of the various stages matches the examples from the puzzle.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day24Part1Test extends FunSuite with Matchers {\n  test(&quot;can parse input&quot;) {\n    parseInput(\n      &quot;&quot;&quot;0/2\n        |2/2\n        |2/3\n        |3/4\n        |3/5\n        |0/1\n        |10/1\n        |9/10&quot;&quot;&quot;.stripMargin.lines.toSeq\n    ) shouldBe Map(\n      0 -&gt; Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -&gt; Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -&gt; Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -&gt; Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -&gt; Set(Component(3,3,4)),\n      5 -&gt; Set(Component(4,3,5)),\n      9 -&gt; Set(Component(7, 9,10)),\n      10 -&gt; Set(Component(7, 9,10), Component(6, 10, 1))\n    )\n  }\n  \n  test(&quot;can build bridges&quot;) {\n    val bridges = buildBridges(Map(\n      0 -&gt; Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -&gt; Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -&gt; Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -&gt; Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -&gt; Set(Component(3,3,4)),\n      5 -&gt; Set(Component(4,3,5)),\n      9 -&gt; Set(Component(7, 9,10)),\n      10 -&gt; Set(Component(7, 9,10), Component(6, 10, 1))\n    ))\n\n    bridges should contain(Seq(Component(5,0,1)))\n    bridges should contain(Seq(Component(6, 10, 1), Component(5,0,1)))\n    bridges should contain(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1)))\n    bridges should contain(Seq(Component(0, 0, 2)))\n    bridges should contain(Seq(Component(2, 2, 3), Component(0, 0, 2)))\n\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\n  }\n\n  test(&quot;can score bridges&quot;) {\n    scoreBridge(Seq(Component(5,0,1))) shouldBe 1\n    scoreBridge(Seq(Component(6, 10, 1), Component(5,0,1))) shouldBe 12\n    scoreBridge(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1))) shouldBe 31\n    scoreBridge(Seq(Component(0, 0, 2))) shouldBe 2\n    scoreBridge(Seq(Component(2, 2, 3), Component(0, 0, 2))) shouldBe 7\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 14\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 15\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse) shouldBe 6\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse) shouldBe 11\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 18\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 19\n  }\n\n  test(&quot;can find strongest bridge&quot;) {\n    strongestBridge(Map(\n      0 -&gt; Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -&gt; Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -&gt; Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -&gt; Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -&gt; Set(Component(3,3,4)),\n      5 -&gt; Set(Component(4,3,5)),\n      9 -&gt; Set(Component(7, 9,10)),\n      10 -&gt; Set(Component(7, 9,10), Component(6, 10, 1))\n    )) shouldBe 31\n  }\n}\n// defined class Day24Part1Test\n\n(new Day24Part1Test).execute()\n// Day24Part1Test:\n// - can parse input\n// - can build bridges\n// - can score bridges\n// - can find strongest bridge\n</code></pre>\n<p>I can then parse the test input and compute a result.</p>\n<pre><code class=\"language-scala\">import scala.io.Source\n// import scala.io.Source\n\nval components = parseInput(Source.fromResource(&quot;day24input.txt&quot;).getLines().toSeq)\n// components: Map[Int,Set[Component]] = Map(0 -&gt; Set(Component(12,0,45), Component(20,0,39), Component(32,0,43)), 5 -&gt; Set(Component(7,5,5), Component(25,5,31), Component(31,44,5), Component(36,5,37)), 42 -&gt; Set(Component(42,42,7)), 24 -&gt; Set(Component(0,24,14), Component(1,30,24), Component(27,20,24), Component(37,40,24)), 37 -&gt; Set(Component(3,47,37), Component(5,20,37), Component(36,5,37)), 14 -&gt; Set(Component(0,24,14), Component(4,6,14), Component(6,14,45)), 20 -&gt; Set(Component(5,20,37), Component(27,20,24), Component(33,38,20), Component(34,20,16)), 46 -&gt; Set(Component(18,46,50), Component(54,46,17)), 29 -&gt; Set(Component(2,29,44), Component(48,29,12), Component(55,29,29)), 6 -&gt; Set(Component(4,6,14), Component(45,6,28)), 28 -&gt; Set(Component(45,6,28)), 38 -&gt; Set(Component(28,38,23), C...\n\nstrongestBridge(components)\n// res1: Int = 2006\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Since I'm already building all the bridges, I can re-run part one, but with a different comparator. As ties are broken by strongest I can take advantage of scala already having and ordering defined for tuples of order by the first element, then second, etc.</p>\n<pre><code class=\"language-scala\">def longestBridge(components: Map[Int, Set[Component]]): Int = {\n  buildBridges(components)\n  .map(b =&gt; (b.length, scoreBridge(b)))\n  .max\n  ._2\n}\n// longestBridge: (components: Map[Int,Set[Component]])Int\n\nclass Day24Part2Test extends FunSuite with Matchers {\n  test(&quot;can find longest bridge&quot;) {\n    longestBridge(Map(\n      0 -&gt; Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -&gt; Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -&gt; Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -&gt; Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -&gt; Set(Component(3,3,4)),\n      5 -&gt; Set(Component(4,3,5)),\n      9 -&gt; Set(Component(7, 9,10)),\n      10 -&gt; Set(Component(7, 9,10), Component(6, 10, 1))\n    )) shouldBe 19\n  }\n}\n// defined class Day24Part2Test\n\n(new Day24Part2Test).execute()\n// Day24Part2Test:\n// - can find longest bridge\n\nlongestBridge(components)\n// res3: Int = 1994\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5b094d19234d9f6a63ff360c","plaintext":"A solution for Advent of Code 2017 - Day 24\n[http://adventofcode.com/2017/day/24]\n\nPart 1\nFor this task I have to build a bridge by combining pairs of integers like\ndominoes. Firstly I need the data in a useful representation. The components I\nrepresent as a case class, and include a unique id so that if there are any\nduplicated components, they still count as different when checking if they have\nbeen used before. I then build a map that can look up the components by either\nconnector.\n\ncase class Component(id: Int, a: Int, b: Int)\n// defined class Component\n\ndef parseInput(lines: Seq[String]): Map[Int, Set[Component]] = {\n  lines\n  .map(_.split(\"/\").toSeq)\n  .zipWithIndex.collect {\n    case ((a +: b +: _), id) => Component(id, a.toInt, b.toInt)\n  }\n  .foldLeft(Map.empty[Int, Set[Component]]) {\n    case (acc, comp) =>\n      acc\n      .updated(comp.a, acc.getOrElse(comp.a, Set.empty) + comp)\n      .updated(comp.b, acc.getOrElse(comp.b, Set.empty) + comp)\n  }\n}\n// parseInput: (lines: Seq[String])Map[Int,Set[Component]]\n\n\nTo get the strongest bridge I'm just going to create all the possible bridges\nand find the maximum strength. This is wildly inefficient, but I can optimise it\nlater if it turns out not to run quickly enough.\n\nBuilding the bridges can be done recursively. I only need to know what is in the\nbridge so far and how many connectors the current end piece has. From that, my\npool of components is already indexed by connector count, so I can grab the\nviable pieces and iterate for each of the new, longer bridges.\n\ndef buildBridges(components: Map[Int, Set[Component]]): Seq[Seq[Component]] = {\n  def iter(bridge: Seq[Component], openPort: Int): Seq[Seq[Component]] = {\n    bridge +:\n      components.getOrElse(openPort, Seq.empty)\n      .filter(!bridge.contains(_))\n      .flatMap(c => iter(c +: bridge, if (c.a == openPort) c.b else c.a)).toSeq\n  }\n\n  iter(Seq.empty, 0)\n}\n// buildBridges: (components: Map[Int,Set[Component]])Seq[Seq[Component]]\n\ndef scoreBridge(bridge: Seq[Component]): Int =\n  bridge.map(b => b.a + b.b).sum\n// scoreBridge: (bridge: Seq[Component])Int\n\ndef strongestBridge(components: Map[Int, Set[Component]]): Int = {\n  buildBridges(components)\n  .map(scoreBridge)\n  .max\n  }\n// strongestBridge: (components: Map[Int,Set[Component]])Int\n\n\nI can now parse the sample data, check that it is represented correctly, and\nthat the output of the various stages matches the examples from the puzzle.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day24Part1Test extends FunSuite with Matchers {\n  test(\"can parse input\") {\n    parseInput(\n      \"\"\"0/2\n        |2/2\n        |2/3\n        |3/4\n        |3/5\n        |0/1\n        |10/1\n        |9/10\"\"\".stripMargin.lines.toSeq\n    ) shouldBe Map(\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -> Set(Component(3,3,4)),\n      5 -> Set(Component(4,3,5)),\n      9 -> Set(Component(7, 9,10)),\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\n    )\n  }\n  \n  test(\"can build bridges\") {\n    val bridges = buildBridges(Map(\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -> Set(Component(3,3,4)),\n      5 -> Set(Component(4,3,5)),\n      9 -> Set(Component(7, 9,10)),\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\n    ))\n\n    bridges should contain(Seq(Component(5,0,1)))\n    bridges should contain(Seq(Component(6, 10, 1), Component(5,0,1)))\n    bridges should contain(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1)))\n    bridges should contain(Seq(Component(0, 0, 2)))\n    bridges should contain(Seq(Component(2, 2, 3), Component(0, 0, 2)))\n\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse)\n    bridges should contain(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse)\n  }\n\n  test(\"can score bridges\") {\n    scoreBridge(Seq(Component(5,0,1))) shouldBe 1\n    scoreBridge(Seq(Component(6, 10, 1), Component(5,0,1))) shouldBe 12\n    scoreBridge(Seq(Component(7, 9, 10), Component(6, 10, 1), Component(5, 0, 1))) shouldBe 31\n    scoreBridge(Seq(Component(0, 0, 2))) shouldBe 2\n    scoreBridge(Seq(Component(2, 2, 3), Component(0, 0, 2))) shouldBe 7\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 14\n    scoreBridge(Seq(Component(0, 0, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 15\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2)).reverse) shouldBe 6\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3)).reverse) shouldBe 11\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(3, 3, 4)).reverse) shouldBe 18\n    scoreBridge(Seq(Component(0, 0, 2), Component(1, 2, 2), Component(2, 2, 3), Component(4, 3, 5)).reverse) shouldBe 19\n  }\n\n  test(\"can find strongest bridge\") {\n    strongestBridge(Map(\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -> Set(Component(3,3,4)),\n      5 -> Set(Component(4,3,5)),\n      9 -> Set(Component(7, 9,10)),\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\n    )) shouldBe 31\n  }\n}\n// defined class Day24Part1Test\n\n(new Day24Part1Test).execute()\n// Day24Part1Test:\n// - can parse input\n// - can build bridges\n// - can score bridges\n// - can find strongest bridge\n\n\nI can then parse the test input and compute a result.\n\nimport scala.io.Source\n// import scala.io.Source\n\nval components = parseInput(Source.fromResource(\"day24input.txt\").getLines().toSeq)\n// components: Map[Int,Set[Component]] = Map(0 -> Set(Component(12,0,45), Component(20,0,39), Component(32,0,43)), 5 -> Set(Component(7,5,5), Component(25,5,31), Component(31,44,5), Component(36,5,37)), 42 -> Set(Component(42,42,7)), 24 -> Set(Component(0,24,14), Component(1,30,24), Component(27,20,24), Component(37,40,24)), 37 -> Set(Component(3,47,37), Component(5,20,37), Component(36,5,37)), 14 -> Set(Component(0,24,14), Component(4,6,14), Component(6,14,45)), 20 -> Set(Component(5,20,37), Component(27,20,24), Component(33,38,20), Component(34,20,16)), 46 -> Set(Component(18,46,50), Component(54,46,17)), 29 -> Set(Component(2,29,44), Component(48,29,12), Component(55,29,29)), 6 -> Set(Component(4,6,14), Component(45,6,28)), 28 -> Set(Component(45,6,28)), 38 -> Set(Component(28,38,23), C...\n\nstrongestBridge(components)\n// res1: Int = 2006\n\n\nPart 2\nSince I'm already building all the bridges, I can re-run part one, but with a\ndifferent comparator. As ties are broken by strongest I can take advantage of\nscala already having and ordering defined for tuples of order by the first\nelement, then second, etc.\n\ndef longestBridge(components: Map[Int, Set[Component]]): Int = {\n  buildBridges(components)\n  .map(b => (b.length, scoreBridge(b)))\n  .max\n  ._2\n}\n// longestBridge: (components: Map[Int,Set[Component]])Int\n\nclass Day24Part2Test extends FunSuite with Matchers {\n  test(\"can find longest bridge\") {\n    longestBridge(Map(\n      0 -> Set(Component(0, 0, 2), Component(5, 0, 1)),\n      1 -> Set(Component(6, 10, 1), Component(5, 0, 1)),\n      2 -> Set(Component(0, 0, 2), Component(1, 2, 2), Component(2,2,3)),\n      3 -> Set(Component(2, 2, 3), Component(3,3,4),Component(4,3,5)),\n      4 -> Set(Component(3,3,4)),\n      5 -> Set(Component(4,3,5)),\n      9 -> Set(Component(7, 9,10)),\n      10 -> Set(Component(7, 9,10), Component(6, 10, 1))\n    )) shouldBe 19\n  }\n}\n// defined class Day24Part2Test\n\n(new Day24Part2Test).execute()\n// Day24Part2Test:\n// - can find longest bridge\n\nlongestBridge(components)\n// res3: Int = 1994","feature_image":"__GHOST_URL__/content/images/2018/05/AoC-banner.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2018-05-26T12:03:37.000Z","updated_at":"2018-05-26T12:08:23.000Z","published_at":"2017-12-31T00:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 24","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5b0a7d44234d9f6a63ff3616","uuid":"6ab68220-c0c6-4be7-99a8-30749386c3da","title":"The Halting Problem","slug":"halting-problem","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"A solution for [Advent of Code 2017 - Day 25](http://adventofcode.com/2017/day/25)\\n\\n## Part 1\\n\\nToday's task was to implement a Turing machine. First task was to turn the \\nrather verbose input into a usable structure. I used the following case classes \\nto represent the various parts.\\n\\n```scala\\ncase class Action(write: Boolean, move: Boolean, next: Char)\\n// defined class Action\\n\\ncase class State(on0: Action, on1: Action)\\n// defined class State\\n\\ncase class Program(state: Char, iterations: Int, states: Map[Char, State]) {\\n  lazy val startingState: State = states(state)\\n}\\n// defined class Program\\n```\\n\\nThe input itself only really has one useful piece of information on each line,\\nso I can build a bunch of regular expressions to match each one. They are also\\nregular enough that I can capture a whole state with a single large pattern\\nmatch.\\n\\n```scala\\ndef parseInput(lines: Seq[String]): Program = {\\n  val StateLine = \\\"Begin in state ([A-Z]).\\\".r\\n  val state: Char = lines.head match {\\n    case StateLine(s) => s.charAt(0)\\n  }\\n  \\n  val IterationsLine = \\\"Perform a diagnostic checksum after (\\\\\\\\d+) steps.\\\".r\\n  val iterations: Int = lines.drop(1).head match {\\n    case IterationsLine(i) => i.toInt\\n  }\\n  \\n  val StateHeader   = \\\"In state ([A-Z]):\\\".r\\n  val ActionHeader  = \\\"  If the current value is (0|1):\\\".r\\n  val WriteLine     = \\\"    - Write the value (0|1).\\\".r\\n  val MoveLine      = \\\"    - Move one slot to the (right|left).\\\".r\\n  val NextStateLine = \\\"    - Continue with state ([A-Z]).\\\".r\\n  \\n  def parseState(s: Seq[String]): (Char, State) = s match {\\n    case\\n      StateHeader(l) +:\\n        ActionHeader(\\\"0\\\") +:\\n        WriteLine(w0) +:\\n        MoveLine(m0) +:\\n        NextStateLine(ns0) +:\\n        ActionHeader(\\\"1\\\") +:\\n        WriteLine(w1) +:\\n        MoveLine(m1) +:\\n        NextStateLine(ns1) +: _ =>\\n      (l.charAt(0), State(\\n        Action(w0 == \\\"1\\\", m0 == \\\"right\\\", ns0.charAt(0)),\\n        Action(w1 == \\\"1\\\", m1 == \\\"right\\\", ns1.charAt(0))\\n      ))\\n  }\\n  \\n  def parseStates(states: Seq[Seq[String]],\\n                  map: Map[Char, State] = Map.empty): Map[Char, State] = {\\n    states match {\\n      case Nil => map\\n      case s +: ss => parseStates(ss, map + parseState(s))\\n    }\\n  }\\n  \\n  val states = parseStates(lines.drop(3).grouped(10).toSeq)\\n  \\n  Program(state, iterations, states)\\n}\\n// parseInput: (lines: Seq[String])Program\\n```\\n\\nFor the actual Turing machine I can just recursively apply each state, using a\\n`Set[Int]` to record the ribbon positions that are currently set to `1`. Once \\nthe required number of iterations are complete the size of the set is the number\\nof `1`s currently set.\\n\\n```scala\\ndef debugChecksum(program: Program): Int = {\\n  def iter(pos: Int, state: State, ribbon: Set[Int], iterations: Int): Int =\\n    if (iterations >= program.iterations)\\n      ribbon.size\\n    else {\\n      val action: Action = if (ribbon.contains(pos)) state.on1 else state.on0\\n      iter(\\n        pos + (if (action.move) 1 else -1),\\n        program.states(action.next),\\n        if (action.write) ribbon + pos else ribbon - pos,\\n        iterations + 1\\n      )\\n    }\\n\\n  iter(0, program.startingState, Set.empty, 0)\\n}\\n// debugChecksum: (program: Program)Int\\n```\\n\\nI can use the example from the puzzle to implement the tests.\\n\\n```scala\\nimport org.scalatest.{FunSuite, Matchers}\\n// import org.scalatest.{FunSuite, Matchers}\\n\\nclass Day25Test extends FunSuite with Matchers {\\n\\n  test(\\\"can parse input\\\") {\\n    parseInput(\\\"\\\"\\\"Begin in state A.\\n      |Perform a diagnostic checksum after 6 steps.\\n      |\\n      |In state A:\\n      |  If the current value is 0:\\n      |    - Write the value 1.\\n      |    - Move one slot to the right.\\n      |    - Continue with state B.\\n      |  If the current value is 1:\\n      |    - Write the value 0.\\n      |    - Move one slot to the left.\\n      |    - Continue with state B.\\n      |\\n      |In state B:\\n      |  If the current value is 0:\\n      |    - Write the value 1.\\n      |    - Move one slot to the left.\\n      |    - Continue with state A.\\n      |  If the current value is 1:\\n      |    - Write the value 1.\\n      |    - Move one slot to the right.\\n      |    - Continue with state A.\\\"\\\"\\\".stripMargin.lines.toSeq) should be\\n    Program(\\n      'A',\\n      6,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )\\n  }\\n\\n  test(\\\"can get diagnostic checksum\\\") {\\n    debugChecksum(Program(\\n      'A',\\n      6,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 3\\n\\n    debugChecksum(Program(\\n      'A',\\n      5,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 3\\n\\n    debugChecksum(Program(\\n      'A',\\n      4,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 2\\n\\n    debugChecksum(Program(\\n      'A',\\n      3,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 1\\n\\n    debugChecksum(Program(\\n      'A',\\n      2,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 2\\n\\n    debugChecksum(Program(\\n      'A',\\n      1,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 1\\n\\n    debugChecksum(Program(\\n      'A',\\n      0,\\n      Map(\\n        'A' -> State(\\n          Action(write = true, move = true, 'B'),\\n          Action(write = false, move = false, 'B')\\n        ),\\n        'B' -> State(\\n          Action(write = true, move = false, 'A'),\\n          Action(write = true, move = true, 'A')\\n        )\\n      )\\n    )) shouldBe 0\\n  }\\n\\n}\\n// defined class Day25Test\\n\\n(new Day25Test).execute()\\n// Day25Test:\\n// - can parse input\\n// - can get diagnostic checksum\\n```\\n\\n## Part 2\\n\\nPart two was just complete all of the previous tasks, so I had nothing more to\\ndo here. \\n\\n## Final Stats\\n\\n```\\n      --------Part 1--------   --------Part 2--------\\nDay       Time   Rank  Score       Time   Rank  Score\\n 25   14:37:45   2672      0   14:38:32   2272      0\\n 24   05:42:01   1326      0   05:44:54   1268      0\\n 23   05:44:25   1970      0   07:05:05   1270      0\\n 22   15:00:25   2927      0   15:15:15   2790      0\\n 21   17:47:42   2347      0   17:48:18   2274      0\\n 20   18:20:07   4254      0   18:58:23   3628      0\\n 19   04:00:04   1743      0   04:02:47   1692      0\\n 18   10:40:41   3431      0   20:39:06   3475      0\\n 17   04:08:57   2082      0   04:35:13   1788      0\\n 16   06:03:26   2613      0   14:47:35   3637      0\\n 15   03:57:25   2496      0   04:05:26   2298      0\\n 14   03:51:16   2150      0   04:51:51   1641      0\\n 13   03:52:54   2574      0   04:08:15   1864      0\\n 12   07:16:31   3979      0   07:36:47   3768      0\\n 11   04:00:34   2447      0   04:22:12   2361      0\\n 10   05:30:16   2690      0   06:18:58   2260      0\\n  9   09:15:14   4309      0   09:28:09   4221      0\\n  8   11:57:52   6636      0   12:06:02   6511      0\\n  7   08:48:52   6247      0   10:47:32   4143      0\\n  6   06:32:40   5558      0   06:40:59   5303      0\\n  5   10:28:00   8641      0   10:33:25   8231      0\\n  4   17:57:50  11957      0   18:15:00  10841      0\\n  3   04:03:30   2516      0   21:11:27   7616      0\\n  2   04:41:57   4515      0   16:10:50  10812      0\\n  1   04:38:15   3757      0   04:46:41   3061      0\\n```\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>A solution for <a href=\"http://adventofcode.com/2017/day/25\">Advent of Code 2017 - Day 25</a></p>\n<h2 id=\"part1\">Part 1</h2>\n<p>Today's task was to implement a Turing machine. First task was to turn the<br>\nrather verbose input into a usable structure. I used the following case classes<br>\nto represent the various parts.</p>\n<pre><code class=\"language-scala\">case class Action(write: Boolean, move: Boolean, next: Char)\n// defined class Action\n\ncase class State(on0: Action, on1: Action)\n// defined class State\n\ncase class Program(state: Char, iterations: Int, states: Map[Char, State]) {\n  lazy val startingState: State = states(state)\n}\n// defined class Program\n</code></pre>\n<p>The input itself only really has one useful piece of information on each line,<br>\nso I can build a bunch of regular expressions to match each one. They are also<br>\nregular enough that I can capture a whole state with a single large pattern<br>\nmatch.</p>\n<pre><code class=\"language-scala\">def parseInput(lines: Seq[String]): Program = {\n  val StateLine = &quot;Begin in state ([A-Z]).&quot;.r\n  val state: Char = lines.head match {\n    case StateLine(s) =&gt; s.charAt(0)\n  }\n  \n  val IterationsLine = &quot;Perform a diagnostic checksum after (\\\\d+) steps.&quot;.r\n  val iterations: Int = lines.drop(1).head match {\n    case IterationsLine(i) =&gt; i.toInt\n  }\n  \n  val StateHeader   = &quot;In state ([A-Z]):&quot;.r\n  val ActionHeader  = &quot;  If the current value is (0|1):&quot;.r\n  val WriteLine     = &quot;    - Write the value (0|1).&quot;.r\n  val MoveLine      = &quot;    - Move one slot to the (right|left).&quot;.r\n  val NextStateLine = &quot;    - Continue with state ([A-Z]).&quot;.r\n  \n  def parseState(s: Seq[String]): (Char, State) = s match {\n    case\n      StateHeader(l) +:\n        ActionHeader(&quot;0&quot;) +:\n        WriteLine(w0) +:\n        MoveLine(m0) +:\n        NextStateLine(ns0) +:\n        ActionHeader(&quot;1&quot;) +:\n        WriteLine(w1) +:\n        MoveLine(m1) +:\n        NextStateLine(ns1) +: _ =&gt;\n      (l.charAt(0), State(\n        Action(w0 == &quot;1&quot;, m0 == &quot;right&quot;, ns0.charAt(0)),\n        Action(w1 == &quot;1&quot;, m1 == &quot;right&quot;, ns1.charAt(0))\n      ))\n  }\n  \n  def parseStates(states: Seq[Seq[String]],\n                  map: Map[Char, State] = Map.empty): Map[Char, State] = {\n    states match {\n      case Nil =&gt; map\n      case s +: ss =&gt; parseStates(ss, map + parseState(s))\n    }\n  }\n  \n  val states = parseStates(lines.drop(3).grouped(10).toSeq)\n  \n  Program(state, iterations, states)\n}\n// parseInput: (lines: Seq[String])Program\n</code></pre>\n<p>For the actual Turing machine I can just recursively apply each state, using a<br>\n<code>Set[Int]</code> to record the ribbon positions that are currently set to <code>1</code>. Once<br>\nthe required number of iterations are complete the size of the set is the number<br>\nof <code>1</code>s currently set.</p>\n<pre><code class=\"language-scala\">def debugChecksum(program: Program): Int = {\n  def iter(pos: Int, state: State, ribbon: Set[Int], iterations: Int): Int =\n    if (iterations &gt;= program.iterations)\n      ribbon.size\n    else {\n      val action: Action = if (ribbon.contains(pos)) state.on1 else state.on0\n      iter(\n        pos + (if (action.move) 1 else -1),\n        program.states(action.next),\n        if (action.write) ribbon + pos else ribbon - pos,\n        iterations + 1\n      )\n    }\n\n  iter(0, program.startingState, Set.empty, 0)\n}\n// debugChecksum: (program: Program)Int\n</code></pre>\n<p>I can use the example from the puzzle to implement the tests.</p>\n<pre><code class=\"language-scala\">import org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day25Test extends FunSuite with Matchers {\n\n  test(&quot;can parse input&quot;) {\n    parseInput(&quot;&quot;&quot;Begin in state A.\n      |Perform a diagnostic checksum after 6 steps.\n      |\n      |In state A:\n      |  If the current value is 0:\n      |    - Write the value 1.\n      |    - Move one slot to the right.\n      |    - Continue with state B.\n      |  If the current value is 1:\n      |    - Write the value 0.\n      |    - Move one slot to the left.\n      |    - Continue with state B.\n      |\n      |In state B:\n      |  If the current value is 0:\n      |    - Write the value 1.\n      |    - Move one slot to the left.\n      |    - Continue with state A.\n      |  If the current value is 1:\n      |    - Write the value 1.\n      |    - Move one slot to the right.\n      |    - Continue with state A.&quot;&quot;&quot;.stripMargin.lines.toSeq) should be\n    Program(\n      'A',\n      6,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )\n  }\n\n  test(&quot;can get diagnostic checksum&quot;) {\n    debugChecksum(Program(\n      'A',\n      6,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 3\n\n    debugChecksum(Program(\n      'A',\n      5,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 3\n\n    debugChecksum(Program(\n      'A',\n      4,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 2\n\n    debugChecksum(Program(\n      'A',\n      3,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 1\n\n    debugChecksum(Program(\n      'A',\n      2,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 2\n\n    debugChecksum(Program(\n      'A',\n      1,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 1\n\n    debugChecksum(Program(\n      'A',\n      0,\n      Map(\n        'A' -&gt; State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -&gt; State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 0\n  }\n\n}\n// defined class Day25Test\n\n(new Day25Test).execute()\n// Day25Test:\n// - can parse input\n// - can get diagnostic checksum\n</code></pre>\n<h2 id=\"part2\">Part 2</h2>\n<p>Part two was just complete all of the previous tasks, so I had nothing more to<br>\ndo here.</p>\n<h2 id=\"finalstats\">Final Stats</h2>\n<pre><code>      --------Part 1--------   --------Part 2--------\nDay       Time   Rank  Score       Time   Rank  Score\n 25   14:37:45   2672      0   14:38:32   2272      0\n 24   05:42:01   1326      0   05:44:54   1268      0\n 23   05:44:25   1970      0   07:05:05   1270      0\n 22   15:00:25   2927      0   15:15:15   2790      0\n 21   17:47:42   2347      0   17:48:18   2274      0\n 20   18:20:07   4254      0   18:58:23   3628      0\n 19   04:00:04   1743      0   04:02:47   1692      0\n 18   10:40:41   3431      0   20:39:06   3475      0\n 17   04:08:57   2082      0   04:35:13   1788      0\n 16   06:03:26   2613      0   14:47:35   3637      0\n 15   03:57:25   2496      0   04:05:26   2298      0\n 14   03:51:16   2150      0   04:51:51   1641      0\n 13   03:52:54   2574      0   04:08:15   1864      0\n 12   07:16:31   3979      0   07:36:47   3768      0\n 11   04:00:34   2447      0   04:22:12   2361      0\n 10   05:30:16   2690      0   06:18:58   2260      0\n  9   09:15:14   4309      0   09:28:09   4221      0\n  8   11:57:52   6636      0   12:06:02   6511      0\n  7   08:48:52   6247      0   10:47:32   4143      0\n  6   06:32:40   5558      0   06:40:59   5303      0\n  5   10:28:00   8641      0   10:33:25   8231      0\n  4   17:57:50  11957      0   18:15:00  10841      0\n  3   04:03:30   2516      0   21:11:27   7616      0\n  2   04:41:57   4515      0   16:10:50  10812      0\n  1   04:38:15   3757      0   04:46:41   3061      0\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"5b0a7d44234d9f6a63ff3616","plaintext":"A solution for Advent of Code 2017 - Day 25\n[http://adventofcode.com/2017/day/25]\n\nPart 1\nToday's task was to implement a Turing machine. First task was to turn the\nrather verbose input into a usable structure. I used the following case classes\nto represent the various parts.\n\ncase class Action(write: Boolean, move: Boolean, next: Char)\n// defined class Action\n\ncase class State(on0: Action, on1: Action)\n// defined class State\n\ncase class Program(state: Char, iterations: Int, states: Map[Char, State]) {\n  lazy val startingState: State = states(state)\n}\n// defined class Program\n\n\nThe input itself only really has one useful piece of information on each line,\nso I can build a bunch of regular expressions to match each one. They are also\nregular enough that I can capture a whole state with a single large pattern\nmatch.\n\ndef parseInput(lines: Seq[String]): Program = {\n  val StateLine = \"Begin in state ([A-Z]).\".r\n  val state: Char = lines.head match {\n    case StateLine(s) => s.charAt(0)\n  }\n  \n  val IterationsLine = \"Perform a diagnostic checksum after (\\\\d+) steps.\".r\n  val iterations: Int = lines.drop(1).head match {\n    case IterationsLine(i) => i.toInt\n  }\n  \n  val StateHeader   = \"In state ([A-Z]):\".r\n  val ActionHeader  = \"  If the current value is (0|1):\".r\n  val WriteLine     = \"    - Write the value (0|1).\".r\n  val MoveLine      = \"    - Move one slot to the (right|left).\".r\n  val NextStateLine = \"    - Continue with state ([A-Z]).\".r\n  \n  def parseState(s: Seq[String]): (Char, State) = s match {\n    case\n      StateHeader(l) +:\n        ActionHeader(\"0\") +:\n        WriteLine(w0) +:\n        MoveLine(m0) +:\n        NextStateLine(ns0) +:\n        ActionHeader(\"1\") +:\n        WriteLine(w1) +:\n        MoveLine(m1) +:\n        NextStateLine(ns1) +: _ =>\n      (l.charAt(0), State(\n        Action(w0 == \"1\", m0 == \"right\", ns0.charAt(0)),\n        Action(w1 == \"1\", m1 == \"right\", ns1.charAt(0))\n      ))\n  }\n  \n  def parseStates(states: Seq[Seq[String]],\n                  map: Map[Char, State] = Map.empty): Map[Char, State] = {\n    states match {\n      case Nil => map\n      case s +: ss => parseStates(ss, map + parseState(s))\n    }\n  }\n  \n  val states = parseStates(lines.drop(3).grouped(10).toSeq)\n  \n  Program(state, iterations, states)\n}\n// parseInput: (lines: Seq[String])Program\n\n\nFor the actual Turing machine I can just recursively apply each state, using a\nSet[Int] to record the ribbon positions that are currently set to 1. Once\nthe required number of iterations are complete the size of the set is the number\nof 1s currently set.\n\ndef debugChecksum(program: Program): Int = {\n  def iter(pos: Int, state: State, ribbon: Set[Int], iterations: Int): Int =\n    if (iterations >= program.iterations)\n      ribbon.size\n    else {\n      val action: Action = if (ribbon.contains(pos)) state.on1 else state.on0\n      iter(\n        pos + (if (action.move) 1 else -1),\n        program.states(action.next),\n        if (action.write) ribbon + pos else ribbon - pos,\n        iterations + 1\n      )\n    }\n\n  iter(0, program.startingState, Set.empty, 0)\n}\n// debugChecksum: (program: Program)Int\n\n\nI can use the example from the puzzle to implement the tests.\n\nimport org.scalatest.{FunSuite, Matchers}\n// import org.scalatest.{FunSuite, Matchers}\n\nclass Day25Test extends FunSuite with Matchers {\n\n  test(\"can parse input\") {\n    parseInput(\"\"\"Begin in state A.\n      |Perform a diagnostic checksum after 6 steps.\n      |\n      |In state A:\n      |  If the current value is 0:\n      |    - Write the value 1.\n      |    - Move one slot to the right.\n      |    - Continue with state B.\n      |  If the current value is 1:\n      |    - Write the value 0.\n      |    - Move one slot to the left.\n      |    - Continue with state B.\n      |\n      |In state B:\n      |  If the current value is 0:\n      |    - Write the value 1.\n      |    - Move one slot to the left.\n      |    - Continue with state A.\n      |  If the current value is 1:\n      |    - Write the value 1.\n      |    - Move one slot to the right.\n      |    - Continue with state A.\"\"\".stripMargin.lines.toSeq) should be\n    Program(\n      'A',\n      6,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )\n  }\n\n  test(\"can get diagnostic checksum\") {\n    debugChecksum(Program(\n      'A',\n      6,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 3\n\n    debugChecksum(Program(\n      'A',\n      5,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 3\n\n    debugChecksum(Program(\n      'A',\n      4,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 2\n\n    debugChecksum(Program(\n      'A',\n      3,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 1\n\n    debugChecksum(Program(\n      'A',\n      2,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 2\n\n    debugChecksum(Program(\n      'A',\n      1,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 1\n\n    debugChecksum(Program(\n      'A',\n      0,\n      Map(\n        'A' -> State(\n          Action(write = true, move = true, 'B'),\n          Action(write = false, move = false, 'B')\n        ),\n        'B' -> State(\n          Action(write = true, move = false, 'A'),\n          Action(write = true, move = true, 'A')\n        )\n      )\n    )) shouldBe 0\n  }\n\n}\n// defined class Day25Test\n\n(new Day25Test).execute()\n// Day25Test:\n// - can parse input\n// - can get diagnostic checksum\n\n\nPart 2\nPart two was just complete all of the previous tasks, so I had nothing more to\ndo here.\n\nFinal Stats\n      --------Part 1--------   --------Part 2--------\nDay       Time   Rank  Score       Time   Rank  Score\n 25   14:37:45   2672      0   14:38:32   2272      0\n 24   05:42:01   1326      0   05:44:54   1268      0\n 23   05:44:25   1970      0   07:05:05   1270      0\n 22   15:00:25   2927      0   15:15:15   2790      0\n 21   17:47:42   2347      0   17:48:18   2274      0\n 20   18:20:07   4254      0   18:58:23   3628      0\n 19   04:00:04   1743      0   04:02:47   1692      0\n 18   10:40:41   3431      0   20:39:06   3475      0\n 17   04:08:57   2082      0   04:35:13   1788      0\n 16   06:03:26   2613      0   14:47:35   3637      0\n 15   03:57:25   2496      0   04:05:26   2298      0\n 14   03:51:16   2150      0   04:51:51   1641      0\n 13   03:52:54   2574      0   04:08:15   1864      0\n 12   07:16:31   3979      0   07:36:47   3768      0\n 11   04:00:34   2447      0   04:22:12   2361      0\n 10   05:30:16   2690      0   06:18:58   2260      0\n  9   09:15:14   4309      0   09:28:09   4221      0\n  8   11:57:52   6636      0   12:06:02   6511      0\n  7   08:48:52   6247      0   10:47:32   4143      0\n  6   06:32:40   5558      0   06:40:59   5303      0\n  5   10:28:00   8641      0   10:33:25   8231      0\n  4   17:57:50  11957      0   18:15:00  10841      0\n  3   04:03:30   2516      0   21:11:27   7616      0\n  2   04:41:57   4515      0   16:10:50  10812      0\n  1   04:38:15   3757      0   04:46:41   3061      0","feature_image":"__GHOST_URL__/content/images/2018/05/AoC-banner-1.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2018-05-27T09:41:24.000Z","updated_at":"2018-11-30T17:55:57.000Z","published_at":"2018-01-01T00:00:00.000Z","custom_excerpt":"Advent of Code 2017 - Day 25","codeinjection_head":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css\">","codeinjection_foot":"<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js\"></script>\n<script>hljs.initHighlightingOnLoad();</script>","custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5d113c8e7dda560778de2bb0","uuid":"dcc91190-0965-47de-8d4a-ed9130204bd9","title":"Goblins of The Dragon's Tooth","slug":"goblins-of-the-dragons-tooth","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"The Dragon's Tooth, a mountainous promontory sticking out into the endless ocean. Home to the last few outposts of the Guilds' hold over the lands. North of here civilisation loses its grip and gives way to the wilds of the north. Most that come this way are travellers. Caravaneers, adventurers, and bounty hunters. It probably wouldn't even see those if there were easier ways to trade with Moradin's Forge, the great but isolated Dwarven city deep in the Spire Mountains. Those that do travel its heights usually stay at the Guardian's Rest Inn. A day from the Halfling town of Heartholme, high in the mountains and the last stop before the treacherous pass to Bardryn's Crossing, where the caravans unload into the dwarven barges.\\n\\nIt is here that our story is set. Attacks on trade caravan's by goblin marauders have increased over the spring. The Caravaneer's Guild have offered a reward of one thousand gold pieces for any who would deal with the cause of these attacks. Adventures have come from near and far, some for the Gold, some for the Glory, and other's have more personal motives. You are one who has answered this call. Our story begins as the sun drops below the Spire Mountains and the last of the night's travellers crosses the inn's threshold.\\n\\n## The Adventure\\n\\nThis is a one-off Dungeons and Dragons adventure for 4 to 6 players, designed to be an introduction to the game. You will be playing a pre-generated character of level three, who will have a background giving them personal incentives to be involved in the adventure. I aim for it to last roughly four hours, but precise length will be down to the choices you and you characters make. \\n\\nThere will probably be quite a bit of combat because that is what D&D does best, but there will also be exploration and intrigue, with plenty of opportunities to bring your character to life throughout. There is no need to know anything about D&D or role-playing games beforehand, the adventure is designed with opportunities to teach the game as we play. \\n\\nOver the next few weeks I'll be releasing some setting information to whet your appetite, finishing with the cast of characters. You will be able to pick who you want to play before the session. This will get you some secret background information, and chance to personalise your character before we hit play.\\n\\n## Out of Character Conduct\\n\\nRole-playing games provide excellent opportunities for immersive escapism, exploring difficult or complex topics, and portraying flawed characters. For this to be fun and rewarding for all, the out-of-character environment needs to be inclusive and safe for everyone participating. You can help out with this, and I will present some tools and tips on the night. If you treat everyone with respect and look out for the groups' enjoyment, you'll not go far wrong.\\n\\nIf you want to discuss this in more detail before the session, or there are themes that could make you uncomfortable that I might not be aware of, please contact me in person or by email ([horton.jeffrey@googlemail.com](mailto:horton.jeffrey@googlemail.com)).\\n\\n*Wizards of the Coast, Dungeons & Dragons, and their logos are trademarks of Wizards of the Coast LLC in the United States and other countries.  2015 Wizards. All Rights Reserved.*\\n\\n\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>The Dragon's Tooth, a mountainous promontory sticking out into the endless ocean. Home to the last few outposts of the Guilds' hold over the lands. North of here civilisation loses its grip and gives way to the wilds of the north. Most that come this way are travellers. Caravaneers, adventurers, and bounty hunters. It probably wouldn't even see those if there were easier ways to trade with Moradin's Forge, the great but isolated Dwarven city deep in the Spire Mountains. Those that do travel its heights usually stay at the Guardian's Rest Inn. A day from the Halfling town of Heartholme, high in the mountains and the last stop before the treacherous pass to Bardryn's Crossing, where the caravans unload into the dwarven barges.</p>\n<p>It is here that our story is set. Attacks on trade caravan's by goblin marauders have increased over the spring. The Caravaneer's Guild have offered a reward of one thousand gold pieces for any who would deal with the cause of these attacks. Adventures have come from near and far, some for the Gold, some for the Glory, and other's have more personal motives. You are one who has answered this call. Our story begins as the sun drops below the Spire Mountains and the last of the night's travellers crosses the inn's threshold.</p>\n<h2 id=\"theadventure\">The Adventure</h2>\n<p>This is a one-off Dungeons and Dragons adventure for 4 to 6 players, designed to be an introduction to the game. You will be playing a pre-generated character of level three, who will have a background giving them personal incentives to be involved in the adventure. I aim for it to last roughly four hours, but precise length will be down to the choices you and you characters make.</p>\n<p>There will probably be quite a bit of combat because that is what D&amp;D does best, but there will also be exploration and intrigue, with plenty of opportunities to bring your character to life throughout. There is no need to know anything about D&amp;D or role-playing games beforehand, the adventure is designed with opportunities to teach the game as we play.</p>\n<p>Over the next few weeks I'll be releasing some setting information to whet your appetite, finishing with the cast of characters. You will be able to pick who you want to play before the session. This will get you some secret background information, and chance to personalise your character before we hit play.</p>\n<h2 id=\"outofcharacterconduct\">Out of Character Conduct</h2>\n<p>Role-playing games provide excellent opportunities for immersive escapism, exploring difficult or complex topics, and portraying flawed characters. For this to be fun and rewarding for all, the out-of-character environment needs to be inclusive and safe for everyone participating. You can help out with this, and I will present some tools and tips on the night. If you treat everyone with respect and look out for the groups' enjoyment, you'll not go far wrong.</p>\n<p>If you want to discuss this in more detail before the session, or there are themes that could make you uncomfortable that I might not be aware of, please contact me in person or by email (<a href=\"mailto:horton.jeffrey@googlemail.com\">horton.jeffrey@googlemail.com</a>).</p>\n<p><em>Wizards of the Coast, Dungeons &amp; Dragons, and their logos are trademarks of Wizards of the Coast LLC in the United States and other countries.  2015 Wizards. All Rights Reserved.</em></p>\n<!--kg-card-end: markdown-->","comment_id":"5d113c8e7dda560778de2bb0","plaintext":"The Dragon's Tooth, a mountainous promontory sticking out into the endless\nocean. Home to the last few outposts of the Guilds' hold over the lands. North\nof here civilisation loses its grip and gives way to the wilds of the north.\nMost that come this way are travellers. Caravaneers, adventurers, and bounty\nhunters. It probably wouldn't even see those if there were easier ways to trade\nwith Moradin's Forge, the great but isolated Dwarven city deep in the Spire\nMountains. Those that do travel its heights usually stay at the Guardian's Rest\nInn. A day from the Halfling town of Heartholme, high in the mountains and the\nlast stop before the treacherous pass to Bardryn's Crossing, where the caravans\nunload into the dwarven barges.\n\nIt is here that our story is set. Attacks on trade caravan's by goblin marauders\nhave increased over the spring. The Caravaneer's Guild have offered a reward of\none thousand gold pieces for any who would deal with the cause of these attacks.\nAdventures have come from near and far, some for the Gold, some for the Glory,\nand other's have more personal motives. You are one who has answered this call.\nOur story begins as the sun drops below the Spire Mountains and the last of the\nnight's travellers crosses the inn's threshold.\n\nThe Adventure\nThis is a one-off Dungeons and Dragons adventure for 4 to 6 players, designed\nto be an introduction to the game. You will be playing a pre-generated character\nof level three, who will have a background giving them personal incentives to be\ninvolved in the adventure. I aim for it to last roughly four hours, but precise\nlength will be down to the choices you and you characters make.\n\nThere will probably be quite a bit of combat because that is what D&D does\nbest, but there will also be exploration and intrigue, with plenty of\nopportunities to bring your character to life throughout. There is no need to\nknow anything about D&D or role-playing games beforehand, the adventure is\ndesigned with opportunities to teach the game as we play.\n\nOver the next few weeks I'll be releasing some setting information to whet your\nappetite, finishing with the cast of characters. You will be able to pick who\nyou want to play before the session. This will get you some secret background\ninformation, and chance to personalise your character before we hit play.\n\nOut of Character Conduct\nRole-playing games provide excellent opportunities for immersive escapism,\nexploring difficult or complex topics, and portraying flawed characters. For\nthis to be fun and rewarding for all, the out-of-character environment needs to\nbe inclusive and safe for everyone participating. You can help out with this,\nand I will present some tools and tips on the night. If you treat everyone with\nrespect and look out for the groups' enjoyment, you'll not go far wrong.\n\nIf you want to discuss this in more detail before the session, or there are\nthemes that could make you uncomfortable that I might not be aware of, please\ncontact me in person or by email (horton.jeffrey@googlemail.com).\n\nWizards of the Coast, Dungeons & Dragons, and their logos are trademarks of\nWizards of the Coast LLC in the United States and other countries.  2015\nWizards. All Rights Reserved.","feature_image":"__GHOST_URL__/content/images/2019/06/guardians-rest-with-goblin-small.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2019-06-24T21:11:42.000Z","updated_at":"2019-07-08T10:07:18.000Z","published_at":"2019-07-08T10:00:00.000Z","custom_excerpt":"The Dragon's Tooth, a mountainous promentary sticking out into the endless ocean. Home to the last few outposts of the Guilds' hold over the lands...\n\nThis is the prelude and background information for a Dungeons & Dragons One off.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5d126d037dda560778de2bb9","uuid":"edcb4664-b1d8-4595-bbe7-74e5c5ede2e6","title":"Dragons, Gods, and Mortals","slug":"dragons-gods-mortals","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"Even the Elves' epic sagas only go back two-thousand years. Before that time there are myths of Dragons who battled the Deities for control of the world. It is said the Deities walked amongst us, commanding legions of mortals shaped in their image. Now, victorious they have retired to their realms in the heavens and hells, leaving the material plane to their mortals.\\n\\n## The Pantheons and Races\\nThe Deities and races of this world are inextricably linked. To fight against the dragons, the deities took the mortals of the world and shaped them for war. Each race owes something of their ancestry to this. Those that devote their lives to a chosen deity manifest this to a much greater extent as the divine power gifted to them leaves its mark.\\n\\n### Elves\\nInfused with the magics of the Fey Wild elves are an otherworldly, mystical people. They follow three sibling Deities, Rillifane Rallathil, They of the Wild, who opened the elves up to the Fey; Corellon Larethain, He of the Sun who taught the elves Art and Magic that they may be more than beasts; and Sehanine Moonbow, She of the Moon, who taugt the elves of Song and Saga, that they might keep and spread their knowledge.\\n\\n### Dwarves\\nMoradin is said to have forged the dwarves from the very rock of the Spire Mountains. Moradin's child Baern forged them armour and weapons, and Moradin's child Thodris led them to war, wielding the storms from the highest peaks. Moradin remebered all their deeds, and watched over them all, in life and in death. They instilled in their creations a great sense of familiy and community, and the Dwarves have always worked hard together to achieve great things.\\n\\n### Gnomes\\nCreated from the union of Rillifane Rallathil and Baern, Garl Glittergold is a mischievous melding of Elf and Dwarf. He created the Gnomes in his image, and both his parents blessed his creations. Some are mischievous forest sprites, whilst others are innovative tinkerers, but all bring joy to the world and those around them.\\n\\n### Halflings\\nHalflings are a people of hearth and home. Yondalla and her partner Randall took it upon themselves to ensure the mortal armies did not lose hope in the horrors of war.  Yondalla teaches the halflings to care for and revel in the life and the world that the deities and mortals wrested from the dragons. Randall is the patron of guardians and crafters, those who make sure mortals are prepared for the worst.\\n\\n### Goblins\\nLyzaxa is part of the pantheon responsible for the goblinoid races, along with Hruggek patron of bugbears, and Maglubiyet patron of hobgoblins. As a pantheon they revere survival above all else, but only Lyzaxa's ideal of survival through cunning has allowed integration with the other mortal races. Each shaman of Lyzaxa teaches their own interpretation of their deities teachings, and as many of these work against the Alliance as with it. \\n\\n### Humans\\nScholars debate if the humans were the original people of this world, or if they too were created by the deities. There is certainly no pantheon that claims them, but the deities of the other races will happily reward their faith. The humans are the most widespread and versatile of the races of the world. \\n\\n### Dragonborn\\nThese take their name from the suspicion that they are what remains of the armies of the dragons, though whether this is true is lost in the mists of time. Certainly it is rare that one of them can channel divine magic. Most dragonborn in the Alliance are travellers; mercenaries, traders, sailors, and explorers. Tribes of nomadic dragonborn wander the desert to the south, and will trade with the towns on the Alliances southern border. If they have knowledge of what lies beyond, they have not shared it with the Guilds.\\n\\n### Other Races\\nThe humans mutability has resulted in a number of half-breeds; half-elves are the most common of these as humans and elves have a history of shared communities.  Whether tieflings are a race shaped by the deities of the Hells, or a product of mortal relationships with the fiends that inhabit them is not clear. Their hellish appearance leads to suspicion, but they seem to have the free-will of any other mortal race. \\n\\nThe warring orc tribes to the far north seem constantly at odds with each other, and the other goblinoid races, nevermind the other mortals. Created by Gruumsh for the most brutal fights of the dragon war, they now know nothing else. The fallen city of Valeguard had a small population of exiles, and there are still half-orc refugees living amongst the towns that cling to the shores of the Dragon's Maw.\\n\\nThere are also merfolk who inhabit the Endless Ocean, and even trade up the Alliance's rivers. They seem uncomfortable out of water and have not integrated with the Alliance even as much as the Dragonborn have. Of the deities they worship, Eadro who promotes adapting to the harsh marine environment sees some worship from Alliance sailors.\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>Even the Elves' epic sagas only go back two-thousand years. Before that time there are myths of Dragons who battled the Deities for control of the world. It is said the Deities walked amongst us, commanding legions of mortals shaped in their image. Now, victorious they have retired to their realms in the heavens and hells, leaving the material plane to their mortals.</p>\n<h2 id=\"thepantheonsandraces\">The Pantheons and Races</h2>\n<p>The Deities and races of this world are inextricably linked. To fight against the dragons, the deities took the mortals of the world and shaped them for war. Each race owes something of their ancestry to this. Those that devote their lives to a chosen deity manifest this to a much greater extent as the divine power gifted to them leaves its mark.</p>\n<h3 id=\"elves\">Elves</h3>\n<p>Infused with the magics of the Fey Wild elves are an otherworldly, mystical people. They follow three sibling Deities, Rillifane Rallathil, They of the Wild, who opened the elves up to the Fey; Corellon Larethain, He of the Sun who taught the elves Art and Magic that they may be more than beasts; and Sehanine Moonbow, She of the Moon, who taugt the elves of Song and Saga, that they might keep and spread their knowledge.</p>\n<h3 id=\"dwarves\">Dwarves</h3>\n<p>Moradin is said to have forged the dwarves from the very rock of the Spire Mountains. Moradin's child Baern forged them armour and weapons, and Moradin's child Thodris led them to war, wielding the storms from the highest peaks. Moradin remebered all their deeds, and watched over them all, in life and in death. They instilled in their creations a great sense of familiy and community, and the Dwarves have always worked hard together to achieve great things.</p>\n<h3 id=\"gnomes\">Gnomes</h3>\n<p>Created from the union of Rillifane Rallathil and Baern, Garl Glittergold is a mischievous melding of Elf and Dwarf. He created the Gnomes in his image, and both his parents blessed his creations. Some are mischievous forest sprites, whilst others are innovative tinkerers, but all bring joy to the world and those around them.</p>\n<h3 id=\"halflings\">Halflings</h3>\n<p>Halflings are a people of hearth and home. Yondalla and her partner Randall took it upon themselves to ensure the mortal armies did not lose hope in the horrors of war.  Yondalla teaches the halflings to care for and revel in the life and the world that the deities and mortals wrested from the dragons. Randall is the patron of guardians and crafters, those who make sure mortals are prepared for the worst.</p>\n<h3 id=\"goblins\">Goblins</h3>\n<p>Lyzaxa is part of the pantheon responsible for the goblinoid races, along with Hruggek patron of bugbears, and Maglubiyet patron of hobgoblins. As a pantheon they revere survival above all else, but only Lyzaxa's ideal of survival through cunning has allowed integration with the other mortal races. Each shaman of Lyzaxa teaches their own interpretation of their deities teachings, and as many of these work against the Alliance as with it.</p>\n<h3 id=\"humans\">Humans</h3>\n<p>Scholars debate if the humans were the original people of this world, or if they too were created by the deities. There is certainly no pantheon that claims them, but the deities of the other races will happily reward their faith. The humans are the most widespread and versatile of the races of the world.</p>\n<h3 id=\"dragonborn\">Dragonborn</h3>\n<p>These take their name from the suspicion that they are what remains of the armies of the dragons, though whether this is true is lost in the mists of time. Certainly it is rare that one of them can channel divine magic. Most dragonborn in the Alliance are travellers; mercenaries, traders, sailors, and explorers. Tribes of nomadic dragonborn wander the desert to the south, and will trade with the towns on the Alliances southern border. If they have knowledge of what lies beyond, they have not shared it with the Guilds.</p>\n<h3 id=\"otherraces\">Other Races</h3>\n<p>The humans mutability has resulted in a number of half-breeds; half-elves are the most common of these as humans and elves have a history of shared communities.  Whether tieflings are a race shaped by the deities of the Hells, or a product of mortal relationships with the fiends that inhabit them is not clear. Their hellish appearance leads to suspicion, but they seem to have the free-will of any other mortal race.</p>\n<p>The warring orc tribes to the far north seem constantly at odds with each other, and the other goblinoid races, nevermind the other mortals. Created by Gruumsh for the most brutal fights of the dragon war, they now know nothing else. The fallen city of Valeguard had a small population of exiles, and there are still half-orc refugees living amongst the towns that cling to the shores of the Dragon's Maw.</p>\n<p>There are also merfolk who inhabit the Endless Ocean, and even trade up the Alliance's rivers. They seem uncomfortable out of water and have not integrated with the Alliance even as much as the Dragonborn have. Of the deities they worship, Eadro who promotes adapting to the harsh marine environment sees some worship from Alliance sailors.</p>\n<!--kg-card-end: markdown-->","comment_id":"5d126d037dda560778de2bb9","plaintext":"Even the Elves' epic sagas only go back two-thousand years. Before that time\nthere are myths of Dragons who battled the Deities for control of the world. It\nis said the Deities walked amongst us, commanding legions of mortals shaped in\ntheir image. Now, victorious they have retired to their realms in the heavens\nand hells, leaving the material plane to their mortals.\n\nThe Pantheons and Races\nThe Deities and races of this world are inextricably linked. To fight against\nthe dragons, the deities took the mortals of the world and shaped them for war.\nEach race owes something of their ancestry to this. Those that devote their\nlives to a chosen deity manifest this to a much greater extent as the divine\npower gifted to them leaves its mark.\n\nElves\nInfused with the magics of the Fey Wild elves are an otherworldly, mystical\npeople. They follow three sibling Deities, Rillifane Rallathil, They of the\nWild, who opened the elves up to the Fey; Corellon Larethain, He of the Sun who\ntaught the elves Art and Magic that they may be more than beasts; and Sehanine\nMoonbow, She of the Moon, who taugt the elves of Song and Saga, that they might\nkeep and spread their knowledge.\n\nDwarves\nMoradin is said to have forged the dwarves from the very rock of the Spire\nMountains. Moradin's child Baern forged them armour and weapons, and Moradin's\nchild Thodris led them to war, wielding the storms from the highest peaks.\nMoradin remebered all their deeds, and watched over them all, in life and in\ndeath. They instilled in their creations a great sense of familiy and community,\nand the Dwarves have always worked hard together to achieve great things.\n\nGnomes\nCreated from the union of Rillifane Rallathil and Baern, Garl Glittergold is a\nmischievous melding of Elf and Dwarf. He created the Gnomes in his image, and\nboth his parents blessed his creations. Some are mischievous forest sprites,\nwhilst others are innovative tinkerers, but all bring joy to the world and those\naround them.\n\nHalflings\nHalflings are a people of hearth and home. Yondalla and her partner Randall took\nit upon themselves to ensure the mortal armies did not lose hope in the horrors\nof war. Yondalla teaches the halflings to care for and revel in the life and the\nworld that the deities and mortals wrested from the dragons. Randall is the\npatron of guardians and crafters, those who make sure mortals are prepared for\nthe worst.\n\nGoblins\nLyzaxa is part of the pantheon responsible for the goblinoid races, along with\nHruggek patron of bugbears, and Maglubiyet patron of hobgoblins. As a pantheon\nthey revere survival above all else, but only Lyzaxa's ideal of survival through\ncunning has allowed integration with the other mortal races. Each shaman of\nLyzaxa teaches their own interpretation of their deities teachings, and as many\nof these work against the Alliance as with it.\n\nHumans\nScholars debate if the humans were the original people of this world, or if they\ntoo were created by the deities. There is certainly no pantheon that claims\nthem, but the deities of the other races will happily reward their faith. The\nhumans are the most widespread and versatile of the races of the world.\n\nDragonborn\nThese take their name from the suspicion that they are what remains of the\narmies of the dragons, though whether this is true is lost in the mists of time.\nCertainly it is rare that one of them can channel divine magic. Most dragonborn\nin the Alliance are travellers; mercenaries, traders, sailors, and explorers.\nTribes of nomadic dragonborn wander the desert to the south, and will trade with\nthe towns on the Alliances southern border. If they have knowledge of what lies\nbeyond, they have not shared it with the Guilds.\n\nOther Races\nThe humans mutability has resulted in a number of half-breeds; half-elves are\nthe most common of these as humans and elves have a history of shared\ncommunities. Whether tieflings are a race shaped by the deities of the Hells, or\na product of mortal relationships with the fiends that inhabit them is not\nclear. Their hellish appearance leads to suspicion, but they seem to have the\nfree-will of any other mortal race.\n\nThe warring orc tribes to the far north seem constantly at odds with each other,\nand the other goblinoid races, nevermind the other mortals. Created by Gruumsh\nfor the most brutal fights of the dragon war, they now know nothing else. The\nfallen city of Valeguard had a small population of exiles, and there are still\nhalf-orc refugees living amongst the towns that cling to the shores of the\nDragon's Maw.\n\nThere are also merfolk who inhabit the Endless Ocean, and even trade up the\nAlliance's rivers. They seem uncomfortable out of water and have not integrated\nwith the Alliance even as much as the Dragonborn have. Of the deities they\nworship, Eadro who promotes adapting to the harsh marine environment sees some\nworship from Alliance sailors.","feature_image":"__GHOST_URL__/content/images/2019/07/circle-small.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2019-06-25T18:50:43.000Z","updated_at":"2019-07-15T13:52:35.000Z","published_at":"2019-07-15T13:00:00.000Z","custom_excerpt":"Even the Elves' epic sagas only go back two-thousand years. Before that time there are myths of Dragons who battled the Deities for control of the world. It is said the Deities walked amongst us, commanding legions of mortals shaped in their image.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5d1bce627dda560778de2bce","uuid":"d844d68c-c89e-4f3c-9880-4fe737302e1a","title":"The Dragon's Tooth","slug":"the-dragons-tooth","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"The main trade route is two days long, from Heartholme, the last market town in the Vale of Plenty. It climbs slowly for a day roughly north east through the forests of the upper river Plenty. It picks its way through the rock crags of Plenty's Edge, and a vast upland moor stretches out above. Ahead you will see the fortified walls of the Guardian's Rest Inn. On the northern horizon the spine of the mountain ridge dominates, and the trail continues north to its lowest pass. This is free from snow except in the darkest depths of winter. Form there it zig-zags down the much steeper North Face dropping the small port town of Bardryn's Crossing. This is the East-most harbour for the Dwarven barges that sail the Dragon's Maw Fjord to the docks of Moradin's Forge a day or two to the West.\\n\\n![Map of The Dragon's Tooth](/content/images/2019/06/the-dragons-tooth-small.png)\\n\\nThe entrance to the Dragon's Tooth Ruby and Silver Mine overlooks the south side of the pass. About 5 miles south of the Inn the Plenty flows through a deep gorge from where it flows from caves under the mountains. Clinging to the stone walls and trees that grow there is an elven temple village, dedicated to Sehanine Moonbow, and home to the Well of Mists. Further from the trail there are few signs of civilisation. Small Goblin, Human, and Elf tribes wander the mountains, as well as the varied beasts and monsters that roam the wild places.\\n\\n## Guardian's Rest Inn\\n\\nThis Inn is relatively new to the area, being founded a little under thirty years ago. When the city of Valeguard to the North was lost to marauding orcs, the refugees began to settle the shores of the Dragon's Maw. The trade route through the valley became vital to bring supplies from the Vale of Plenty to the less fertile northern shores. The Guardian's Rest was built up from a crude shelter to the fortified inn of today by human refugees Arveene and Darvin Tallstag.\\n\\nThe inn has beds and stables for about three trade caravans and a handful of other travellers. It has a forge, a brewery, a shrine to the five pantheons, and space for a handful of market stalls. It employs a small staff of permanent guards, supplemented by caravan guards as required. The more civilised local tribes will visit to trade with the caravans, as will the Dwarves of the mine and the Elves of the temple. Darvin and Skamos, the Tallstags' Tiefling child are both involved in maintaining the Guild of the Arcane's network of teleportation circles, including one inside the Inn's walled compound.\\n\\n## The Dragon's Tooth Ruby and Silver Mine\\n\\nThis mine is much older than the Inn. Shortly after the Three Cities signed the Charter of Alliance and the Guilds started to cast their gaze out into the world. Prospectors, lead by divine guidance from Baern discovered rich veins of iron, silver, and gems. They founded a mine, and the first shaft was dug a little over five hundred years ago.\\n\\nAbodes and facilities are built into the long exhausted upper levels of the mine are home to about fifty dwarves; miners, craftsdwarves, traders, and priests. There are also some Gnomish tinkerers and a family of Halfling chefs and brewers.\\n\\nUnder the mine is a warren of old and new mine shafts, and there still seems to be plenty of rich deposits left to exploit.  Many of the deeper shafts have broken into the caverns that lie under the mountains, and abandoned shafts are sealed with heavy iron doors and bulkheads. The Dwarves must keep constant vigil against the terrors of the deep.\\n\\n## The Temple of Sehanine Moonbow\\n\\nIt is said that one of Sehanine Moonbow's arrows fell to earth gouging the huge rift out of which the river Plenty flows. There is certainly something otherworldly about the forests in and around the rift. Here dotted amongst the trees rise slender elven towers, and elegant halls hang in the canopy. This is one of the largest temples to  Sehanine Moonbow in the lands of the Guilds. Priests and scholars come here to learn and continue the great sagas that form the oral history of the Elves.\\n\\nThe cliffs of Plenty's Edge rise above even the temple's tower. At the highest point there is a mystical spring surrounded by five standing stones. The mossy clearing is always enshrouded in faintly glowing mists, but the Moon's reflection in the pool is never obscured. Is is said that those devoted to the Elven deities are sometimes blessed with visions if they stare long enough into the pool.\\n\\n## Bardryn's Crossing\\n\\nBefore the fall of Valeguard, this was a small fishing village with an Inn for those few traveller's who had need to travel the Dragon's Tooth. The now ruined Bardryn's Landing on the North shore saw the traffic from Valeguard head West to Moradin's Forge, or by sea to the capitol of Randall's Watch. Now Valeguard is no more, the trading families have moved South across the Fjord, and it's port is vital for bringing food from the Vale of Plenty to the refugee settlements that dot the shores of the Dragon's Maw.\\n\\nIt is everything you'd expect from a port town on the edge of the civilised world. The Mayor and the city watch are in the pockets of the Merchant families and smuggling gangs. There is a walled enclave where the Mayor and richer families live. The Mage's and Caravaneer's Guilds have outposts here. Staying at the Soaring Dragon Inn here is expensive, but relatively safe. The fortified port office of the Ruby and Silver Mine offers a secure place for those friendly with the Dwarves. Everyone else takes their chances in the various dockside inn's, which are 'safe' if you're in the good books of which ever merchant house or gang operates out of there.\\n\\n## The Wider World\\n\\nThe Dragon's Tooth is on the northern edge of the Lands of the Guilds. An alliance of three cities formed nearly five hundred years ago by the Charter of Alliance. This ushered in an age of stability, exploration, and innovation. The Plenty flows south, eventually joining the Greenwater and flowing out east into the Endless Ocean through the habour city of Randall's Watch. Most of the Guilds have their headquarters here, and it is the closest to a capital that the Alliance have. To the west in the Spire Mountains is the dwarven city of Moradin's Forge, and the Market City of Glitterglade sits on the shore of an immense lake deep in the forests to the south.\\n\\nFurther north is the fallen city of Valeguard, testament that civilisation cannot always keep the wilds at bay. Little is known beyond that, warring bands of orcs and worse making short work of those who have ventured out. The Endless Ocean spreads out to the east, home to merfolk and monsters. There are some inhabited islands that trade with the guilds. To the south the land becomes a vast desert, nomadic tribes of Dragonborn live there and occasionally bring exotic goods and tales to the towns on the southern border. To the west rise the Spire Mountains, these inhospitable peaks are claimed by clans of giants and the Guilds keep a healthy distance.\"}]],\"markups\":[],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>The main trade route is two days long, from Heartholme, the last market town in the Vale of Plenty. It climbs slowly for a day roughly north east through the forests of the upper river Plenty. It picks its way through the rock crags of Plenty's Edge, and a vast upland moor stretches out above. Ahead you will see the fortified walls of the Guardian's Rest Inn. On the northern horizon the spine of the mountain ridge dominates, and the trail continues north to its lowest pass. This is free from snow except in the darkest depths of winter. Form there it zig-zags down the much steeper North Face dropping the small port town of Bardryn's Crossing. This is the East-most harbour for the Dwarven barges that sail the Dragon's Maw Fjord to the docks of Moradin's Forge a day or two to the West.</p>\n<p><img src=\"/content/images/2019/06/the-dragons-tooth-small.png\" alt=\"Map of The Dragon's Tooth\" loading=\"lazy\"></p>\n<p>The entrance to the Dragon's Tooth Ruby and Silver Mine overlooks the south side of the pass. About 5 miles south of the Inn the Plenty flows through a deep gorge from where it flows from caves under the mountains. Clinging to the stone walls and trees that grow there is an elven temple village, dedicated to Sehanine Moonbow, and home to the Well of Mists. Further from the trail there are few signs of civilisation. Small Goblin, Human, and Elf tribes wander the mountains, as well as the varied beasts and monsters that roam the wild places.</p>\n<h2 id=\"guardiansrestinn\">Guardian's Rest Inn</h2>\n<p>This Inn is relatively new to the area, being founded a little under thirty years ago. When the city of Valeguard to the North was lost to marauding orcs, the refugees began to settle the shores of the Dragon's Maw. The trade route through the valley became vital to bring supplies from the Vale of Plenty to the less fertile northern shores. The Guardian's Rest was built up from a crude shelter to the fortified inn of today by human refugees Arveene and Darvin Tallstag.</p>\n<p>The inn has beds and stables for about three trade caravans and a handful of other travellers. It has a forge, a brewery, a shrine to the five pantheons, and space for a handful of market stalls. It employs a small staff of permanent guards, supplemented by caravan guards as required. The more civilised local tribes will visit to trade with the caravans, as will the Dwarves of the mine and the Elves of the temple. Darvin and Skamos, the Tallstags' Tiefling child are both involved in maintaining the Guild of the Arcane's network of teleportation circles, including one inside the Inn's walled compound.</p>\n<h2 id=\"thedragonstoothrubyandsilvermine\">The Dragon's Tooth Ruby and Silver Mine</h2>\n<p>This mine is much older than the Inn. Shortly after the Three Cities signed the Charter of Alliance and the Guilds started to cast their gaze out into the world. Prospectors, lead by divine guidance from Baern discovered rich veins of iron, silver, and gems. They founded a mine, and the first shaft was dug a little over five hundred years ago.</p>\n<p>Abodes and facilities are built into the long exhausted upper levels of the mine are home to about fifty dwarves; miners, craftsdwarves, traders, and priests. There are also some Gnomish tinkerers and a family of Halfling chefs and brewers.</p>\n<p>Under the mine is a warren of old and new mine shafts, and there still seems to be plenty of rich deposits left to exploit.  Many of the deeper shafts have broken into the caverns that lie under the mountains, and abandoned shafts are sealed with heavy iron doors and bulkheads. The Dwarves must keep constant vigil against the terrors of the deep.</p>\n<h2 id=\"thetempleofsehaninemoonbow\">The Temple of Sehanine Moonbow</h2>\n<p>It is said that one of Sehanine Moonbow's arrows fell to earth gouging the huge rift out of which the river Plenty flows. There is certainly something otherworldly about the forests in and around the rift. Here dotted amongst the trees rise slender elven towers, and elegant halls hang in the canopy. This is one of the largest temples to  Sehanine Moonbow in the lands of the Guilds. Priests and scholars come here to learn and continue the great sagas that form the oral history of the Elves.</p>\n<p>The cliffs of Plenty's Edge rise above even the temple's tower. At the highest point there is a mystical spring surrounded by five standing stones. The mossy clearing is always enshrouded in faintly glowing mists, but the Moon's reflection in the pool is never obscured. Is is said that those devoted to the Elven deities are sometimes blessed with visions if they stare long enough into the pool.</p>\n<h2 id=\"bardrynscrossing\">Bardryn's Crossing</h2>\n<p>Before the fall of Valeguard, this was a small fishing village with an Inn for those few traveller's who had need to travel the Dragon's Tooth. The now ruined Bardryn's Landing on the North shore saw the traffic from Valeguard head West to Moradin's Forge, or by sea to the capitol of Randall's Watch. Now Valeguard is no more, the trading families have moved South across the Fjord, and it's port is vital for bringing food from the Vale of Plenty to the refugee settlements that dot the shores of the Dragon's Maw.</p>\n<p>It is everything you'd expect from a port town on the edge of the civilised world. The Mayor and the city watch are in the pockets of the Merchant families and smuggling gangs. There is a walled enclave where the Mayor and richer families live. The Mage's and Caravaneer's Guilds have outposts here. Staying at the Soaring Dragon Inn here is expensive, but relatively safe. The fortified port office of the Ruby and Silver Mine offers a secure place for those friendly with the Dwarves. Everyone else takes their chances in the various dockside inn's, which are 'safe' if you're in the good books of which ever merchant house or gang operates out of there.</p>\n<h2 id=\"thewiderworld\">The Wider World</h2>\n<p>The Dragon's Tooth is on the northern edge of the Lands of the Guilds. An alliance of three cities formed nearly five hundred years ago by the Charter of Alliance. This ushered in an age of stability, exploration, and innovation. The Plenty flows south, eventually joining the Greenwater and flowing out east into the Endless Ocean through the habour city of Randall's Watch. Most of the Guilds have their headquarters here, and it is the closest to a capital that the Alliance have. To the west in the Spire Mountains is the dwarven city of Moradin's Forge, and the Market City of Glitterglade sits on the shore of an immense lake deep in the forests to the south.</p>\n<p>Further north is the fallen city of Valeguard, testament that civilisation cannot always keep the wilds at bay. Little is known beyond that, warring bands of orcs and worse making short work of those who have ventured out. The Endless Ocean spreads out to the east, home to merfolk and monsters. There are some inhabited islands that trade with the guilds. To the south the land becomes a vast desert, nomadic tribes of Dragonborn live there and occasionally bring exotic goods and tales to the towns on the southern border. To the west rise the Spire Mountains, these inhospitable peaks are claimed by clans of giants and the Guilds keep a healthy distance.</p>\n<!--kg-card-end: markdown-->","comment_id":"5d1bce627dda560778de2bce","plaintext":"The main trade route is two days long, from Heartholme, the last market town in\nthe Vale of Plenty. It climbs slowly for a day roughly north east through the\nforests of the upper river Plenty. It picks its way through the rock crags of\nPlenty's Edge, and a vast upland moor stretches out above. Ahead you will see\nthe fortified walls of the Guardian's Rest Inn. On the northern horizon the\nspine of the mountain ridge dominates, and the trail continues north to its\nlowest pass. This is free from snow except in the darkest depths of winter. Form\nthere it zig-zags down the much steeper North Face dropping the small port town\nof Bardryn's Crossing. This is the East-most harbour for the Dwarven barges that\nsail the Dragon's Maw Fjord to the docks of Moradin's Forge a day or two to the\nWest.\n\n\n\nThe entrance to the Dragon's Tooth Ruby and Silver Mine overlooks the south side\nof the pass. About 5 miles south of the Inn the Plenty flows through a deep\ngorge from where it flows from caves under the mountains. Clinging to the stone\nwalls and trees that grow there is an elven temple village, dedicated to\nSehanine Moonbow, and home to the Well of Mists. Further from the trail there\nare few signs of civilisation. Small Goblin, Human, and Elf tribes wander the\nmountains, as well as the varied beasts and monsters that roam the wild places.\n\nGuardian's Rest Inn\nThis Inn is relatively new to the area, being founded a little under thirty\nyears ago. When the city of Valeguard to the North was lost to marauding orcs,\nthe refugees began to settle the shores of the Dragon's Maw. The trade route\nthrough the valley became vital to bring supplies from the Vale of Plenty to the\nless fertile northern shores. The Guardian's Rest was built up from a crude\nshelter to the fortified inn of today by human refugees Arveene and Darvin\nTallstag.\n\nThe inn has beds and stables for about three trade caravans and a handful of\nother travellers. It has a forge, a brewery, a shrine to the five pantheons, and\nspace for a handful of market stalls. It employs a small staff of permanent\nguards, supplemented by caravan guards as required. The more civilised local\ntribes will visit to trade with the caravans, as will the Dwarves of the mine\nand the Elves of the temple. Darvin and Skamos, the Tallstags' Tiefling child\nare both involved in maintaining the Guild of the Arcane's network of\nteleportation circles, including one inside the Inn's walled compound.\n\nThe Dragon's Tooth Ruby and Silver Mine\nThis mine is much older than the Inn. Shortly after the Three Cities signed the\nCharter of Alliance and the Guilds started to cast their gaze out into the\nworld. Prospectors, lead by divine guidance from Baern discovered rich veins of\niron, silver, and gems. They founded a mine, and the first shaft was dug a\nlittle over five hundred years ago.\n\nAbodes and facilities are built into the long exhausted upper levels of the mine\nare home to about fifty dwarves; miners, craftsdwarves, traders, and priests.\nThere are also some Gnomish tinkerers and a family of Halfling chefs and\nbrewers.\n\nUnder the mine is a warren of old and new mine shafts, and there still seems to\nbe plenty of rich deposits left to exploit. Many of the deeper shafts have\nbroken into the caverns that lie under the mountains, and abandoned shafts are\nsealed with heavy iron doors and bulkheads. The Dwarves must keep constant vigil\nagainst the terrors of the deep.\n\nThe Temple of Sehanine Moonbow\nIt is said that one of Sehanine Moonbow's arrows fell to earth gouging the huge\nrift out of which the river Plenty flows. There is certainly something\notherworldly about the forests in and around the rift. Here dotted amongst the\ntrees rise slender elven towers, and elegant halls hang in the canopy. This is\none of the largest temples to Sehanine Moonbow in the lands of the Guilds.\nPriests and scholars come here to learn and continue the great sagas that form\nthe oral history of the Elves.\n\nThe cliffs of Plenty's Edge rise above even the temple's tower. At the highest\npoint there is a mystical spring surrounded by five standing stones. The mossy\nclearing is always enshrouded in faintly glowing mists, but the Moon's\nreflection in the pool is never obscured. Is is said that those devoted to the\nElven deities are sometimes blessed with visions if they stare long enough into\nthe pool.\n\nBardryn's Crossing\nBefore the fall of Valeguard, this was a small fishing village with an Inn for\nthose few traveller's who had need to travel the Dragon's Tooth. The now ruined\nBardryn's Landing on the North shore saw the traffic from Valeguard head West to\nMoradin's Forge, or by sea to the capitol of Randall's Watch. Now Valeguard is\nno more, the trading families have moved South across the Fjord, and it's port\nis vital for bringing food from the Vale of Plenty to the refugee settlements\nthat dot the shores of the Dragon's Maw.\n\nIt is everything you'd expect from a port town on the edge of the civilised\nworld. The Mayor and the city watch are in the pockets of the Merchant families\nand smuggling gangs. There is a walled enclave where the Mayor and richer\nfamilies live. The Mage's and Caravaneer's Guilds have outposts here. Staying at\nthe Soaring Dragon Inn here is expensive, but relatively safe. The fortified\nport office of the Ruby and Silver Mine offers a secure place for those friendly\nwith the Dwarves. Everyone else takes their chances in the various dockside\ninn's, which are 'safe' if you're in the good books of which ever merchant house\nor gang operates out of there.\n\nThe Wider World\nThe Dragon's Tooth is on the northern edge of the Lands of the Guilds. An\nalliance of three cities formed nearly five hundred years ago by the Charter of\nAlliance. This ushered in an age of stability, exploration, and innovation. The\nPlenty flows south, eventually joining the Greenwater and flowing out east into\nthe Endless Ocean through the habour city of Randall's Watch. Most of the Guilds\nhave their headquarters here, and it is the closest to a capital that the\nAlliance have. To the west in the Spire Mountains is the dwarven city of\nMoradin's Forge, and the Market City of Glitterglade sits on the shore of an\nimmense lake deep in the forests to the south.\n\nFurther north is the fallen city of Valeguard, testament that civilisation\ncannot always keep the wilds at bay. Little is known beyond that, warring bands\nof orcs and worse making short work of those who have ventured out. The Endless\nOcean spreads out to the east, home to merfolk and monsters. There are some\ninhabited islands that trade with the guilds. To the south the land becomes a\nvast desert, nomadic tribes of Dragonborn live there and occasionally bring\nexotic goods and tales to the towns on the southern border. To the west rise the\nSpire Mountains, these inhospitable peaks are claimed by clans of giants and the\nGuilds keep a healthy distance.","feature_image":"__GHOST_URL__/content/images/2019/07/the-dragons-tooth-small.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2019-07-02T21:36:34.000Z","updated_at":"2020-03-21T12:45:15.000Z","published_at":"2019-07-12T12:00:02.000Z","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5d21fa9a7dda560778de2be2","uuid":"2508cba3-33f0-4f1e-9331-65ffd2643da6","title":"Dramatis Personae","slug":"dramatis-personae","mobiledoc":"{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"The heroes that have answered the call of the Caravaneer's guild are many and diverse. The characters below are designed to be a rough outline for you to shape as you please. They are written with neutral gender and without physical descriptions so that you can have them present with whichever identities you prefer. Once the group has decided on their characters I will send you some more details about the character you choose. You are welcome to alter any part of their background or personality, but please discuss it with me so that I can keep the rest of the world up to date.\\n\\n## Bardryn Fireforge, Devoted Dwarven Forgemaster\\nA cleric devoted to Baern, dwarven deity of the forge. Bardryn came from humble beginnings to make a name for themselves, at least locally. They are a skilled smith and stalwart protector of the few outposts of civilisation that stand on the Dragon's Tooth.\\n\\n## Caelynn Evenwood, Estranged Noble Half-elf Warlock\\nA highborn merchant who had a life of luxury laid out at their feet from birth. Inadvisable dabbling with infernal powers has led to Caelynn cutting ties with their family and hiding behind multiple masks and identities to maintain their connections. They now seek redemption by performing great deeds, and also a bit of treasure to keep up their lifestyle won't go amiss. \\n\\n## Grim Tallstag, Solitary Human Ranger\\nOne of the children of the landlords of the Guardian's Rest Inn. Grim knows nor wants any other home than the wild mountains they grew up in. An adept, solitary hunter who knows Dragon's Tooth well, and will shoot anything that threatens it.\\n\\n## Korinn Yarjerit, Mercenary Dragonborn Bodyguard\\nKorinn has spent most of their lives on the high seas of the Endless Ocean as a marine. An altercation with the new captain left them with a sore head and a bad reputation. Korinn is up to guard anyone with a bit of coin, and their last employer left them in the Inn looking for the next job. \\n\\n## Myev, Wandering Half-orc War Skald\\nA refugee of the fall of Valeguard, and raised amongst the veterans of the city, it was a tough life of cold winds and distrustful stares. Now the threat of the north has dissipated, they wander the roads of the Guilds. Myev plays in the inns and taverns for coin, and earns a bit on the side as a Waywatcher, an undercover informant for the Caravaneers' Guild.\\n\\n## Myznar, Angry Goblin Freedom Fighter\\nA hot-headed leader of a group of rebel goblins that have set themselves against the local shamen. Ever since they were trapped in a cave with a wild bear, they have been able to call on spirits to enter bestial rages. They solve problems directly, usually with their axe. They've approached the Inn hearing that allies to their cause may be gathering.\\n\\n## Rowan Ilphelkiir, Half-elf Green Knight\\nRowan was kidnapped by a coven of hags at an early age. They were rescued by a paladin of Rillifane Rallathil, and feel they have a debt to repay. They have come to the Dragon's Tooth on a pilgrimage to test their devotion to their new oath as a paladin. Rowan was ambushed and robbed by goblins near the Inn, they are now determined to make the goblins see the error of their ways.\\n\\n## Sariel Galakiir, Mystical Elven Druid\\nHaving lost their mother to the perils of adventuring at an early age, Sariel has become convinced they have inherited her destiny. Growing up in the mystical glades of the local elven temple, the Fey and the divine have always been part of their life. Gifted with a vision of the Goblin threat, they feel drawn to the Inn.\\n\\n## Sindri Nackle, Prophetic Gnome Urchin\\nA gnome orphaned in the depths of Moradin's Forge, Sindri has taught themselves magic from a stolen spellbook. Their studies have given them and understanding of the threads of fate, and allowed them to earn a few coins. Approaching the Inn on their way to the divination pool at the temple Sindri saw that their fates were in some way entwined with the place. \\n\\n## Skamos Tallstag, Gifted Tiefling Sorceror\\nSkamos is the tiefling child of the owners of the tavern, born shortly after the founding of the Inn in mysterious circumstances. They have always had innate magics, and were sent away to the Mage's Guild to learn to control this. They are studying to work for the Guild maintaining the teleportation network, and have noticed something suspicious.\\n\\n## Stixil, Sneaky Goblin Scout\\nHaving run away at an early age and fallen in with a fence who operates in Bardryn's Crossing, Stixil is very sneaky, and highly independent. They have quick fingers and reflexes, and are as home in the wilds as they are in town. When their wits fail, they can be deadly with their shortswords, especially if they catch their victim by surprise. They have recently fallen in with Myznar's rebel goblins.\\n\\n## Trym Tealeaf, Disciplined Halfling Monk\\nTrym retreated to the Monastery of Elemental Harmony when about a quarter of their village were killed by starving wolves, and the plague they brought with them. They are calm and disciplined, and have mastered traditional halfling weapons to the point they are just an extension of their own body and mind. They come to the inn seeking a gem stolen from their monastery by goblins a week ago.\\n\\n<small>*The cover image on this page is provided by Wizards of the Coast LLC as part of their fan site kit. This site is not affiliated with, endorsed, sponsored, or specifically approved by Wizards of the Coast LLC. This site may use the trademarks and other intellectual property of Wizards of the Coast LLC, which is permitted under Wizards' [Fan Site Policy](https://dnd.wizards.com/articles/features/fan-site-kit). Dungeons & Dragons is a trademark of Wizards of the Coast. For more information about Wizards of the Coast or any of Wizards' trademarks or other intellectual property, please visit their website at [www.wizards.com](http://www.wizards.com).*</small>\"}]],\"sections\":[[10,0]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>The heroes that have answered the call of the Caravaneer's guild are many and diverse. The characters below are designed to be a rough outline for you to shape as you please. They are written with neutral gender and without physical descriptions so that you can have them present with whichever identities you prefer. Once the group has decided on their characters I will send you some more details about the character you choose. You are welcome to alter any part of their background or personality, but please discuss it with me so that I can keep the rest of the world up to date.</p>\n<h2 id=\"bardrynfireforgedevoteddwarvenforgemaster\">Bardryn Fireforge, Devoted Dwarven Forgemaster</h2>\n<p>A cleric devoted to Baern, dwarven deity of the forge. Bardryn came from humble beginnings to make a name for themselves, at least locally. They are a skilled smith and stalwart protector of the few outposts of civilisation that stand on the Dragon's Tooth.</p>\n<h2 id=\"caelynnevenwoodestrangednoblehalfelfwarlock\">Caelynn Evenwood, Estranged Noble Half-elf Warlock</h2>\n<p>A highborn merchant who had a life of luxury laid out at their feet from birth. Inadvisable dabbling with infernal powers has led to Caelynn cutting ties with their family and hiding behind multiple masks and identities to maintain their connections. They now seek redemption by performing great deeds, and also a bit of treasure to keep up their lifestyle won't go amiss.</p>\n<h2 id=\"grimtallstagsolitaryhumanranger\">Grim Tallstag, Solitary Human Ranger</h2>\n<p>One of the children of the landlords of the Guardian's Rest Inn. Grim knows nor wants any other home than the wild mountains they grew up in. An adept, solitary hunter who knows Dragon's Tooth well, and will shoot anything that threatens it.</p>\n<h2 id=\"korinnyarjeritmercenarydragonbornbodyguard\">Korinn Yarjerit, Mercenary Dragonborn Bodyguard</h2>\n<p>Korinn has spent most of their lives on the high seas of the Endless Ocean as a marine. An altercation with the new captain left them with a sore head and a bad reputation. Korinn is up to guard anyone with a bit of coin, and their last employer left them in the Inn looking for the next job.</p>\n<h2 id=\"myevwanderinghalforcwarskald\">Myev, Wandering Half-orc War Skald</h2>\n<p>A refugee of the fall of Valeguard, and raised amongst the veterans of the city, it was a tough life of cold winds and distrustful stares. Now the threat of the north has dissipated, they wander the roads of the Guilds. Myev plays in the inns and taverns for coin, and earns a bit on the side as a Waywatcher, an undercover informant for the Caravaneers' Guild.</p>\n<h2 id=\"myznarangrygoblinfreedomfighter\">Myznar, Angry Goblin Freedom Fighter</h2>\n<p>A hot-headed leader of a group of rebel goblins that have set themselves against the local shamen. Ever since they were trapped in a cave with a wild bear, they have been able to call on spirits to enter bestial rages. They solve problems directly, usually with their axe. They've approached the Inn hearing that allies to their cause may be gathering.</p>\n<h2 id=\"rowanilphelkiirhalfelfgreenknight\">Rowan Ilphelkiir, Half-elf Green Knight</h2>\n<p>Rowan was kidnapped by a coven of hags at an early age. They were rescued by a paladin of Rillifane Rallathil, and feel they have a debt to repay. They have come to the Dragon's Tooth on a pilgrimage to test their devotion to their new oath as a paladin. Rowan was ambushed and robbed by goblins near the Inn, they are now determined to make the goblins see the error of their ways.</p>\n<h2 id=\"sarielgalakiirmysticalelvendruid\">Sariel Galakiir, Mystical Elven Druid</h2>\n<p>Having lost their mother to the perils of adventuring at an early age, Sariel has become convinced they have inherited her destiny. Growing up in the mystical glades of the local elven temple, the Fey and the divine have always been part of their life. Gifted with a vision of the Goblin threat, they feel drawn to the Inn.</p>\n<h2 id=\"sindrinacklepropheticgnomeurchin\">Sindri Nackle, Prophetic Gnome Urchin</h2>\n<p>A gnome orphaned in the depths of Moradin's Forge, Sindri has taught themselves magic from a stolen spellbook. Their studies have given them and understanding of the threads of fate, and allowed them to earn a few coins. Approaching the Inn on their way to the divination pool at the temple Sindri saw that their fates were in some way entwined with the place.</p>\n<h2 id=\"skamostallstaggiftedtieflingsorceror\">Skamos Tallstag, Gifted Tiefling Sorceror</h2>\n<p>Skamos is the tiefling child of the owners of the tavern, born shortly after the founding of the Inn in mysterious circumstances. They have always had innate magics, and were sent away to the Mage's Guild to learn to control this. They are studying to work for the Guild maintaining the teleportation network, and have noticed something suspicious.</p>\n<h2 id=\"stixilsneakygoblinscout\">Stixil, Sneaky Goblin Scout</h2>\n<p>Having run away at an early age and fallen in with a fence who operates in Bardryn's Crossing, Stixil is very sneaky, and highly independent. They have quick fingers and reflexes, and are as home in the wilds as they are in town. When their wits fail, they can be deadly with their shortswords, especially if they catch their victim by surprise. They have recently fallen in with Myznar's rebel goblins.</p>\n<h2 id=\"trymtealeafdisciplinedhalflingmonk\">Trym Tealeaf, Disciplined Halfling Monk</h2>\n<p>Trym retreated to the Monastery of Elemental Harmony when about a quarter of their village were killed by starving wolves, and the plague they brought with them. They are calm and disciplined, and have mastered traditional halfling weapons to the point they are just an extension of their own body and mind. They come to the inn seeking a gem stolen from their monastery by goblins a week ago.</p>\n<p><small><em>The cover image on this page is provided by Wizards of the Coast LLC as part of their fan site kit. This site is not affiliated with, endorsed, sponsored, or specifically approved by Wizards of the Coast LLC. This site may use the trademarks and other intellectual property of Wizards of the Coast LLC, which is permitted under Wizards' <a href=\"https://dnd.wizards.com/articles/features/fan-site-kit\">Fan Site Policy</a>. Dungeons &amp; Dragons is a trademark of Wizards of the Coast. For more information about Wizards of the Coast or any of Wizards' trademarks or other intellectual property, please visit their website at <a href=\"http://www.wizards.com\">www.wizards.com</a>.</em></small></p>\n<!--kg-card-end: markdown-->","comment_id":"5d21fa9a7dda560778de2be2","plaintext":"The heroes that have answered the call of the Caravaneer's guild are many and\ndiverse. The characters below are designed to be a rough outline for you to\nshape as you please. They are written with neutral gender and without physical\ndescriptions so that you can have them present with whichever identities you\nprefer. Once the group has decided on their characters I will send you some more\ndetails about the character you choose. You are welcome to alter any part of\ntheir background or personality, but please discuss it with me so that I can\nkeep the rest of the world up to date.\n\nBardryn Fireforge, Devoted Dwarven Forgemaster\nA cleric devoted to Baern, dwarven deity of the forge. Bardryn came from humble\nbeginnings to make a name for themselves, at least locally. They are a skilled\nsmith and stalwart protector of the few outposts of civilisation that stand on\nthe Dragon's Tooth.\n\nCaelynn Evenwood, Estranged Noble Half-elf Warlock\nA highborn merchant who had a life of luxury laid out at their feet from birth.\nInadvisable dabbling with infernal powers has led to Caelynn cutting ties with\ntheir family and hiding behind multiple masks and identities to maintain their\nconnections. They now seek redemption by performing great deeds, and also a bit\nof treasure to keep up their lifestyle won't go amiss.\n\nGrim Tallstag, Solitary Human Ranger\nOne of the children of the landlords of the Guardian's Rest Inn. Grim knows nor\nwants any other home than the wild mountains they grew up in. An adept, solitary\nhunter who knows Dragon's Tooth well, and will shoot anything that threatens it.\n\nKorinn Yarjerit, Mercenary Dragonborn Bodyguard\nKorinn has spent most of their lives on the high seas of the Endless Ocean as a\nmarine. An altercation with the new captain left them with a sore head and a bad\nreputation. Korinn is up to guard anyone with a bit of coin, and their last\nemployer left them in the Inn looking for the next job.\n\nMyev, Wandering Half-orc War Skald\nA refugee of the fall of Valeguard, and raised amongst the veterans of the city,\nit was a tough life of cold winds and distrustful stares. Now the threat of the\nnorth has dissipated, they wander the roads of the Guilds. Myev plays in the\ninns and taverns for coin, and earns a bit on the side as a Waywatcher, an\nundercover informant for the Caravaneers' Guild.\n\nMyznar, Angry Goblin Freedom Fighter\nA hot-headed leader of a group of rebel goblins that have set themselves against\nthe local shamen. Ever since they were trapped in a cave with a wild bear, they\nhave been able to call on spirits to enter bestial rages. They solve problems\ndirectly, usually with their axe. They've approached the Inn hearing that allies\nto their cause may be gathering.\n\nRowan Ilphelkiir, Half-elf Green Knight\nRowan was kidnapped by a coven of hags at an early age. They were rescued by a\npaladin of Rillifane Rallathil, and feel they have a debt to repay. They have\ncome to the Dragon's Tooth on a pilgrimage to test their devotion to their new\noath as a paladin. Rowan was ambushed and robbed by goblins near the Inn, they\nare now determined to make the goblins see the error of their ways.\n\nSariel Galakiir, Mystical Elven Druid\nHaving lost their mother to the perils of adventuring at an early age, Sariel\nhas become convinced they have inherited her destiny. Growing up in the mystical\nglades of the local elven temple, the Fey and the divine have always been part\nof their life. Gifted with a vision of the Goblin threat, they feel drawn to the\nInn.\n\nSindri Nackle, Prophetic Gnome Urchin\nA gnome orphaned in the depths of Moradin's Forge, Sindri has taught themselves\nmagic from a stolen spellbook. Their studies have given them and understanding\nof the threads of fate, and allowed them to earn a few coins. Approaching the\nInn on their way to the divination pool at the temple Sindri saw that their\nfates were in some way entwined with the place.\n\nSkamos Tallstag, Gifted Tiefling Sorceror\nSkamos is the tiefling child of the owners of the tavern, born shortly after the\nfounding of the Inn in mysterious circumstances. They have always had innate\nmagics, and were sent away to the Mage's Guild to learn to control this. They\nare studying to work for the Guild maintaining the teleportation network, and\nhave noticed something suspicious.\n\nStixil, Sneaky Goblin Scout\nHaving run away at an early age and fallen in with a fence who operates in\nBardryn's Crossing, Stixil is very sneaky, and highly independent. They have\nquick fingers and reflexes, and are as home in the wilds as they are in town.\nWhen their wits fail, they can be deadly with their shortswords, especially if\nthey catch their victim by surprise. They have recently fallen in with Myznar's\nrebel goblins.\n\nTrym Tealeaf, Disciplined Halfling Monk\nTrym retreated to the Monastery of Elemental Harmony when about a quarter of\ntheir village were killed by starving wolves, and the plague they brought with\nthem. They are calm and disciplined, and have mastered traditional halfling\nweapons to the point they are just an extension of their own body and mind. They\ncome to the inn seeking a gem stolen from their monastery by goblins a week ago.\n\nThe cover image on this page is provided by Wizards of the Coast LLC as part of\ntheir fan site kit. This site is not affiliated with, endorsed, sponsored, or\nspecifically approved by Wizards of the Coast LLC. This site may use the\ntrademarks and other intellectual property of Wizards of the Coast LLC, which is\npermitted under Wizards' Fan Site Policy\n[https://dnd.wizards.com/articles/features/fan-site-kit]. Dungeons & Dragons is\na trademark of Wizards of the Coast. For more information about Wizards of the\nCoast or any of Wizards' trademarks or other intellectual property, please visit\ntheir website at www.wizards.com [http://www.wizards.com].","feature_image":"__GHOST_URL__/content/images/2019/07/illo3.jpg","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2019-07-07T13:58:50.000Z","updated_at":"2019-07-16T11:04:12.000Z","published_at":"2019-07-16T11:00:00.000Z","custom_excerpt":"The heroes that have answered the call of the Caravaneer's guild are many and diverse. This details the tweve options the player's have for their character in the game.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5edac1384d1d5c09a4c0c9b7","uuid":"fa6f99a3-280d-4e5b-b80b-b450e4eb535c","title":"Needy Cat Game Jam","slug":"needy-cat-game-jam","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"Last weekend I took part in a charity table-top game jam organised by Needy Cat Games in aid of Feline and Wildlife Rescue Nottingham. It ran for 48 hours, Friday to Sunday. I'm writing here to talk about the process I went through to build my game. \\n\\nYou can see more details of the event itself on the Needy Cat website. They were mentioning that they will probably run one again. It was a lot of fun and I recommend anyone interested in this sort of thing to give it a go.\"}],[\"bookmark\",{\"type\":\"bookmark\",\"url\":\"https://www.needycatgames.com/blog/2020/5/15/join-us-for-a-game-jam-and-help-some-needy-cats\",\"metadata\":{\"url\":\"https://www.needycatgames.com/blog/2020/5/15/join-us-for-a-game-jam-and-help-some-needy-cats\",\"title\":\"Join us for a Game Jam - and help some Needy Cats!  Needy Cat Games\",\"description\":\"<p>Needy Cat Games is a small tabletop games design studio based in Nottingham, creating bespoke designs and offering a comprehensive rules review service.</p>\",\"author\":\"James Hewitt\",\"publisher\":\"Needy Cat Games\",\"thumbnail\":\"http://static1.squarespace.com/static/5924341c59cc68a4582034fc/t/5ebece6176e7e3752ed721bd/1589563019467/Onyx.jpg?format=1500w\",\"icon\":\"https://images.squarespace-cdn.com/content/v1/5924341c59cc68a4582034fc/1517465390890-HHTL9QMFCC9IIRY21B21/ke17ZwdGBToddI8pDm48kKiu4DoEndA9NUr2Wxudvep7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QHyNOqBUUEtDDsRWrJLTmHn8vUrf3k8CboE2z68MTpzStVIx18CFTeKhZjCAbzbwMZ1SLOxGWwCG7okUsCdFP/favicon.ico?format=100w\"},\"caption\":\"\"}],[\"markdown\",{\"markdown\":\"I've recently taken part in their online table-top games design course, and this was my first time to put this into practice. The theme of Pets and/or Wildlife, and we had to include at least one of three mechanics: Drafting, Ladder climbing, and/or Score-and-reset. There was also strict limits on what components we could use, which really shaped the design space and made for a very interesting challenge.\\n\\n* The final submission had to be a maximum of 3 pages, inclusive of rules, play sheets, printable cards, etc.\\n* Up to twenty counters, in any mix of up to four colours.\\n* Up to ten identical Six-sided dice\\n* Tools to make components, e.g. pen/pencils, scissors, glue, card.\\n\\n## First Thoughts\\nI had a bit of a handicap as I was at work until 6pm. I'd read the document with the theme and mechanics on my lunch break, so was turning over ideas in the back of my head when I could too.\\n\\nFor the theme I wanted to lean into the charity support, so decided to vaguely build a game about animal rescue. For mechanics I definitely wanted to use at least drafting, it's one of my favourite board game mechanics in general. The default implementation would be to use cards but it would be difficult to fit a decent set of cards into three pages alongside rules. I turned to the dice, and decided to see if there was any mileage in having the players draft dice to limit their choice of actions. \\n\\nFor dice-drafting to work, I need a pool of actions to match up to dice. If the players are managing wildlife rescue centers then I have options for rescuing animals, feeding them and caring for any problems they have, and getting them adopted. I'm also starting to look for ways for players to mitigate the randomness of dice, and to make sure whoever is drafting last still has choice. \\n\\nAt this point I reach for some pencil and paper, sketch out a grid with six rows, and start brainstorming some actions. I started split on feed, rescue, first aid/surgery,  maintenance, training, and adoption. For these to make sense there need to be animals to rescue, that possibly need medical help, and may be more or less appealing for adoption. \\n\\n## Test Build\\nThe course hammered home the idea of getting the core mechanics/components tested as soon as possible. Get as simple a mock-up as you can get away with and play assuming setup has been done. Having done this I totally agree and it really helped. It was quickly obvious that having a dice face per action type lead to dead-ends where the dice left to a player were useless. \\n\\nThe game quickly morphed into getting to choose to focus on food/donations, animal care, or managing people with your action. The dice determined the nuance of those options. For food the game ended up with five food resources. Mostly, this was decided because it allowed me to use the 20 tokens to track these for four players. I added in money that could be used to purchase any of the different foods, to make the sixth result. There wasn't a simple way to assign these to faces in a meaningful way, but it did end up mattering how they matched up to the other options. I ended up making the assignment random, to sneak in a bit of replayability.\\n\\nFor people management, this started off as an action for people coming along and adopting animals, and one for volunteers that helped out at the centre. Particularly the volunteer action needed to feel versatile, and it ended up being that the player took the dice and could spend pips from that dice to do instant actions in the future. The adopt action was feeling too much like the care action. It also had its better versions on faces three and four, to prevent it competing with the other actions, and this felt arbitrary. I tried merging them on a whim, and it felt much better so it stayed. It simplified things, and added a nice tension to the decision to spend volunteers, as you also need to hold them back for the purposes of scoring.\\n\\n\"}]],\"markups\":[[\"a\",[\"href\",\"__GHOST_URL__/content/images/2020/06/animal-rescue-game.pdf\"]]],\"sections\":[[10,0],[10,1],[1,\"p\",[[0,[],0,\"You can get my final submission here: \"],[0,[0],1,\"Animal Rescue Game.pdf\"]]],[10,2],[1,\"p\",[]]],\"ghostVersion\":\"3.0\"}","html":"<!--kg-card-begin: markdown--><p>Last weekend I took part in a charity table-top game jam organised by Needy Cat Games in aid of Feline and Wildlife Rescue Nottingham. It ran for 48 hours, Friday to Sunday. I'm writing here to talk about the process I went through to build my game.</p>\n<p>You can see more details of the event itself on the Needy Cat website. They were mentioning that they will probably run one again. It was a lot of fun and I recommend anyone interested in this sort of thing to give it a go.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://www.needycatgames.com/blog/2020/5/15/join-us-for-a-game-jam-and-help-some-needy-cats\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Join us for a Game Jam - and help some Needy Cats!  Needy Cat Games</div><div class=\"kg-bookmark-description\">&lt;p&gt;Needy Cat Games is a small tabletop games design studio based in Nottingham, creating bespoke designs and offering a comprehensive rules review service.&lt;/p&gt;</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://images.squarespace-cdn.com/content/v1/5924341c59cc68a4582034fc/1517465390890-HHTL9QMFCC9IIRY21B21/ke17ZwdGBToddI8pDm48kKiu4DoEndA9NUr2Wxudvep7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QHyNOqBUUEtDDsRWrJLTmHn8vUrf3k8CboE2z68MTpzStVIx18CFTeKhZjCAbzbwMZ1SLOxGWwCG7okUsCdFP/favicon.ico?format&#x3D;100w\"><span class=\"kg-bookmark-author\">Needy Cat Games</span><span class=\"kg-bookmark-publisher\">James Hewitt</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"http://static1.squarespace.com/static/5924341c59cc68a4582034fc/t/5ebece6176e7e3752ed721bd/1589563019467/Onyx.jpg?format&#x3D;1500w\"></div></a></figure><p>You can get my final submission here: <a href=\"__GHOST_URL__/content/images/2020/06/animal-rescue-game.pdf\">Animal Rescue Game.pdf</a></p><!--kg-card-begin: markdown--><p>I've recently taken part in their online table-top games design course, and this was my first time to put this into practice. The theme of Pets and/or Wildlife, and we had to include at least one of three mechanics: Drafting, Ladder climbing, and/or Score-and-reset. There was also strict limits on what components we could use, which really shaped the design space and made for a very interesting challenge.</p>\n<ul>\n<li>The final submission had to be a maximum of 3 pages, inclusive of rules, play sheets, printable cards, etc.</li>\n<li>Up to twenty counters, in any mix of up to four colours.</li>\n<li>Up to ten identical Six-sided dice</li>\n<li>Tools to make components, e.g. pen/pencils, scissors, glue, card.</li>\n</ul>\n<h2 id=\"firstthoughts\">First Thoughts</h2>\n<p>I had a bit of a handicap as I was at work until 6pm. I'd read the document with the theme and mechanics on my lunch break, so was turning over ideas in the back of my head when I could too.</p>\n<p>For the theme I wanted to lean into the charity support, so decided to vaguely build a game about animal rescue. For mechanics I definitely wanted to use at least drafting, it's one of my favourite board game mechanics in general. The default implementation would be to use cards but it would be difficult to fit a decent set of cards into three pages alongside rules. I turned to the dice, and decided to see if there was any mileage in having the players draft dice to limit their choice of actions.</p>\n<p>For dice-drafting to work, I need a pool of actions to match up to dice. If the players are managing wildlife rescue centers then I have options for rescuing animals, feeding them and caring for any problems they have, and getting them adopted. I'm also starting to look for ways for players to mitigate the randomness of dice, and to make sure whoever is drafting last still has choice.</p>\n<p>At this point I reach for some pencil and paper, sketch out a grid with six rows, and start brainstorming some actions. I started split on feed, rescue, first aid/surgery,  maintenance, training, and adoption. For these to make sense there need to be animals to rescue, that possibly need medical help, and may be more or less appealing for adoption.</p>\n<h2 id=\"testbuild\">Test Build</h2>\n<p>The course hammered home the idea of getting the core mechanics/components tested as soon as possible. Get as simple a mock-up as you can get away with and play assuming setup has been done. Having done this I totally agree and it really helped. It was quickly obvious that having a dice face per action type lead to dead-ends where the dice left to a player were useless.</p>\n<p>The game quickly morphed into getting to choose to focus on food/donations, animal care, or managing people with your action. The dice determined the nuance of those options. For food the game ended up with five food resources. Mostly, this was decided because it allowed me to use the 20 tokens to track these for four players. I added in money that could be used to purchase any of the different foods, to make the sixth result. There wasn't a simple way to assign these to faces in a meaningful way, but it did end up mattering how they matched up to the other options. I ended up making the assignment random, to sneak in a bit of replayability.</p>\n<p>For people management, this started off as an action for people coming along and adopting animals, and one for volunteers that helped out at the centre. Particularly the volunteer action needed to feel versatile, and it ended up being that the player took the dice and could spend pips from that dice to do instant actions in the future. The adopt action was feeling too much like the care action. It also had its better versions on faces three and four, to prevent it competing with the other actions, and this felt arbitrary. I tried merging them on a whim, and it felt much better so it stayed. It simplified things, and added a nice tension to the decision to spend volunteers, as you also need to hold them back for the purposes of scoring.</p>\n<!--kg-card-end: markdown-->","comment_id":"5edac1384d1d5c09a4c0c9b7","plaintext":"Last weekend I took part in a charity table-top game jam organised by Needy Cat\nGames in aid of Feline and Wildlife Rescue Nottingham. It ran for 48 hours,\nFriday to Sunday. I'm writing here to talk about the process I went through to\nbuild my game.\n\nYou can see more details of the event itself on the Needy Cat website. They were\nmentioning that they will probably run one again. It was a lot of fun and I\nrecommend anyone interested in this sort of thing to give it a go.\n\nJoin us for a Game Jam - and help some Needy Cats!  Needy Cat Games<p>Needy\nCat\nGames is a small tabletop games design studio based in Nottingham, creating\nbespoke designs and offering a comprehensive rules review service.</p>Needy\nCat\nGamesJames Hewitt\n[https://www.needycatgames.com/blog/2020/5/15/join-us-for-a-game-jam-and-help-some-needy-cats]\nYou can get my final submission here: Animal Rescue Game.pdf\n[__GHOST_URL__/content/images/2020/06/animal-rescue-game.pdf]\n\nI've recently taken part in their online table-top games design course, and this\nwas my first time to put this into practice. The theme of Pets and/or Wildlife,\nand we had to include at least one of three mechanics: Drafting, Ladder\nclimbing, and/or Score-and-reset. There was also strict limits on what\ncomponents we could use, which really shaped the design space and made for a\nvery interesting challenge.\n\n * The final submission had to be a maximum of 3 pages, inclusive of rules, play\n   sheets, printable cards, etc.\n * Up to twenty counters, in any mix of up to four colours.\n * Up to ten identical Six-sided dice\n * Tools to make components, e.g. pen/pencils, scissors, glue, card.\n\nFirst Thoughts\nI had a bit of a handicap as I was at work until 6pm. I'd read the document with\nthe theme and mechanics on my lunch break, so was turning over ideas in the back\nof my head when I could too.\n\nFor the theme I wanted to lean into the charity support, so decided to vaguely\nbuild a game about animal rescue. For mechanics I definitely wanted to use at\nleast drafting, it's one of my favourite board game mechanics in general. The\ndefault implementation would be to use cards but it would be difficult to fit a\ndecent set of cards into three pages alongside rules. I turned to the dice, and\ndecided to see if there was any mileage in having the players draft dice to\nlimit their choice of actions.\n\nFor dice-drafting to work, I need a pool of actions to match up to dice. If the\nplayers are managing wildlife rescue centers then I have options for rescuing\nanimals, feeding them and caring for any problems they have, and getting them\nadopted. I'm also starting to look for ways for players to mitigate the\nrandomness of dice, and to make sure whoever is drafting last still has choice.\n\nAt this point I reach for some pencil and paper, sketch out a grid with six\nrows, and start brainstorming some actions. I started split on feed, rescue,\nfirst aid/surgery, maintenance, training, and adoption. For these to make sense\nthere need to be animals to rescue, that possibly need medical help, and may be\nmore or less appealing for adoption.\n\nTest Build\nThe course hammered home the idea of getting the core mechanics/components\ntested as soon as possible. Get as simple a mock-up as you can get away with and\nplay assuming setup has been done. Having done this I totally agree and it\nreally helped. It was quickly obvious that having a dice face per action type\nlead to dead-ends where the dice left to a player were useless.\n\nThe game quickly morphed into getting to choose to focus on food/donations,\nanimal care, or managing people with your action. The dice determined the nuance\nof those options. For food the game ended up with five food resources. Mostly,\nthis was decided because it allowed me to use the 20 tokens to track these for\nfour players. I added in money that could be used to purchase any of the\ndifferent foods, to make the sixth result. There wasn't a simple way to assign\nthese to faces in a meaningful way, but it did end up mattering how they matched\nup to the other options. I ended up making the assignment random, to sneak in a\nbit of replayability.\n\nFor people management, this started off as an action for people coming along and\nadopting animals, and one for volunteers that helped out at the centre.\nParticularly the volunteer action needed to feel versatile, and it ended up\nbeing that the player took the dice and could spend pips from that dice to do\ninstant actions in the future. The adopt action was feeling too much like the\ncare action. It also had its better versions on faces three and four, to prevent\nit competing with the other actions, and this felt arbitrary. I tried merging\nthem on a whim, and it felt much better so it stayed. It simplified things, and\nadded a nice tension to the decision to spend volunteers, as you also need to\nhold them back for the purposes of scoring.","feature_image":"__GHOST_URL__/content/images/2020/06/DSC_0100.JPG","featured":0,"status":"draft","locale":null,"visibility":"public","author_id":"1","created_at":"2020-06-05T22:03:36.000Z","updated_at":"2020-06-06T11:36:26.000Z","published_at":null,"custom_excerpt":"Last weekend I took part in a charity table-top game jam organised by Needy Cat Games in aid of Feline and Wildlife Rescue Nottingham. I'm writing here to talk about the process I went through to build my game. ","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"5ff1df307ced540c8c44c362","uuid":"fbdf45e4-8bbf-4cc1-9a2c-41acd6259d8c","title":"Hammerheads Game","slug":"hammerheads-game","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"bookmark\",{\"type\":\"bookmark\",\"url\":\"https://www.cortexrpg.com/compendium/hammerheads-spotlight/\",\"metadata\":{\"url\":\"https://www.cortexrpg.com\",\"title\":\"Cortex Tabletop Roleplaying Game | Fandom Tabletop\",\"description\":\"Cortex is a multi-genre, modular, session-centered tabletop roleplaying game system. Build your own custom tabletop RPG game with Cortex.\",\"author\":null,\"publisher\":\"Cortex\",\"thumbnail\":\"https://www.cortexrpg.com/cdn/media/static/cortex/img/opengraph.jpg\",\"icon\":\"https://www.cortexrpg.com/cdn/media/static/cortex/img/favicon.png\"}}],[\"bookmark\",{\"type\":\"bookmark\",\"url\":\"https://briebeau.com/thoughty/script-change/\",\"metadata\":{\"url\":\"https://briebeau.com/thoughty/script-change/\",\"title\":\"Script Change RPG Toolbox\",\"description\":\"The formatted, printable Script Change file can be downloaded here. Find full page table safety tool references from Tomer Gurantz,and index card references here from Tomer as well! Script \",\"author\":null,\"publisher\":\"Thoughty\",\"thumbnail\":\"https://i0.wp.com/briebeau.com/thoughty/wp-content/uploads/2019/02/cropped-ThoughtyC_text-1.png?fit=512%2C512&ssl=1\",\"icon\":\"https://i0.wp.com/briebeau.com/thoughty/wp-content/uploads/2019/02/cropped-ThoughtyC_text-1.png?fit=192%2C192&ssl=1\"}}],[\"image\",{\"src\":\"__GHOST_URL__/content/images/2021/01/05-037.agents.png\",\"width\":850,\"height\":665}],[\"html\",{\"html\":\"<table>\\n    <tbody>\\n        <tr>\\n            <th style=\\\"width: 8rem;\\\">\\n                <img src=\\\"__GHOST_URL__/content/images/2021/01/map-pc.png\\\" alt=\\\"Rectangle (PC): Anna Smith\\\" />\\n            </th>\\n            <td>\\n                <p>\\n                <strong>Rectangles: Player Characters</strong>: The protagonists and focus of the the game and setting. The map starts with the players distributed around the edges.\\n            </td>\\n        </tr>\\n        <tr>\\n            <th>\\n                <img src=\\\"__GHOST_URL__/content/images/2021/01/map-gmc.png\\\" alt=\\\"Oval (GMC): Herbert West\\\" />\\n            </th>\\n            <td>\\n                <strong>Ovals: Game Moderator Characters</strong>: Other characers that feature in the setting. Will be portrayed by the Game Moderator if they turn up in play. \\n            </td>\\n        </tr>\\n        <tr>\\n            <th>\\n                <img src=\\\"__GHOST_URL__/content/images/2021/01/map-resource.png\\\" alt=\\\"Diamond (Resource): World Crisis Organisation\\\" />\\n            </th>\\n            <td>\\n                <strong>Diamonds: Resources</strong>: Resources are things in the world that players interact with, e.g. Organisations, Locations, or Props. The map starts with the World Crisis Organisation as a resource in the centre.\\n            </td>\\n        </tr>\\n        <tr>\\n            <th>\\n                <img src=\\\"__GHOST_URL__/content/images/2021/01/map-event.png\\\" alt=\\\"Triangle (Situation): Iraq War Protest\\\" />\\n            </th>\\n            <td>\\n                <strong>Triangles: Situations</strong>: An event or status that effects the characters in some way. Occupations, hobbies, crises, etc.\\n            </td>\\n        </tr>\\n    </tbody>\\n</table>\"}]],\"markups\":[[\"a\",[\"href\",\"https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFile-Hammerheads.pdf\"]],[\"a\",[\"href\",\"https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFileFillable-Hammerheads.pdf\"]],[\"strong\"],[\"em\"],[\"a\",[\"href\",\"https://www.cortexrpg.com/compendium/hammerheads-spotlight/#Credits\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"Hammerheads is set in the near future as climate change really starts to bite. You play an agent of the secretive World Crisis Organisation. The WCO is an elite group recruited from first responders, military, aid workers, and scientists. Their Hammerhead craft (High-Altitude, Multi-Mission, Emergency Response HEADquarters) allow them to be first on the scene when disaster strikes. It takes inspiration from Thunderbirds and various disaster movies, and is intended to be episodic with each session seeing the team tackle a new crisis.\"]]],[1,\"p\",[[0,[],0,\"All the rules and background needed to play are free online, as this is the sample setting available on the Cortex Website.\"]]],[10,0],[1,\"p\",[[0,[],0,\"Everything will be explained during play anyway, so read as much or as little as you have time for.\"]]],[1,\"h2\",[[0,[],0,\"Script Change RPG Toolkit\"]]],[1,\"p\",[[0,[],0,\"Roleplaying should be safe and fun for everyone. We'll be using the Script Change RPG Toolkit to help faciltate this. \"]]],[10,1],[1,\"p\",[[0,[],0,\"This adds a bunch of tools for skipping, redoing, changing pace. It can be used if something is making you uncomfortable, or if you've just made a mistake, or had a better idea. \"]]],[1,\"p\",[[0,[],0,\"We'll open session zero with a discussion to allow players and the game moderator to discuss any topics to avoid or approach cautiously, and how we want to use the tools. If anyone has something they want to be avoided, but don't feel comfortable bringing up during a group discussion, feel free to message me privately.\"]]],[1,\"p\",[[0,[],0,\"The interrupt tools (pause, rewind, etc.) will be available as emojis in Discord, and should be included in the shared dice roller too.\"]]],[10,2],[1,\"h2\",[[0,[],0,\"Character Building\"]]],[1,\"p\",[[0,[],0,\"All you need to start with is a rough outline of the character you'd like to play, their name, and preferred pronouns. e.g.\"]]],[3,\"ul\",[[[0,[],0,\"Anna Smith, She/Her - An aid worker who has voluteered for charity work since what was supposed to be a gap year.\"]],[[0,[],0,\"Uhtred Ran, He/Him - Ex-special forces, who is self reliant to a fault.\"]],[[0,[],0,\"Chris Tine, They/Them - Physicist with ADHD, worked on the Hammerhead designs.\"]]]],[1,\"p\",[[0,[],0,\"You can play a character as similar or different from yourself as you like. If you are portraying someone with different life experiences to your own, make sure to consider how to do so respectfully.\"]]],[1,\"p\",[[0,[],0,\"You will also need a discord account, and a Google account to access the Pathways Map. Please also download a character sheet.\"]]],[3,\"ul\",[[[0,[0],1,\"Standard\"],[0,[],0,\" - to print and fill in.\"]],[[0,[1],1,\"Form-fillable\"],[0,[],0,\" - to fill in digitally.\"]]]],[1,\"p\",[[0,[],0,\"I'll be expanding on the provided character generation steps using a version of the Pathways. All of the below will be introduced and explained during the session as well.\"]]],[1,\"h3\",[[0,[],0,\"Pathways - Mapping out the setting.\"]]],[1,\"p\",[[0,[],0,\"Beyond the basic premise, very little about the setting is defined. This is intentional. Alongside building characters we will work together to build a setting around and connected to the characters.\"]]],[1,\"p\",[[0,[],0,\"Character generation will proceed through five stages. During each stage you will  add new setting elements and/or link them to your character. Each stage also has a perticular trait or trait set to fill out on your character sheet, which will be done once everyone, including the Game Moderator, has had their chance to add to the map for that stage. \"]]],[1,\"p\",[[0,[],0,\"The map will be built on google slides to enable us all to edit it at once. There are four types of elements that can be added to the map.\"]]],[10,3],[1,\"p\",[[0,[],0,\"These will be connected to each other by lines, with a label explaining how the two are related.\"]]],[1,\"p\",[[0,[],0,\"Each stage also has a type that determines how you can modify the map during that stage:\"]]],[1,\"p\",[[0,[2],1,\"Standard: \"],[0,[],0,\"Add a connection between an existing Character, Resource, or Situation and your player character; or add a new GMC, Resource, or Situaltion and connect it to your player character. If you are linking to another player character, discuss it with them first and agree on the relationship.\"]]],[1,\"p\",[[0,[2],1,\"Major: \"],[0,[],0,\"Same as a standard stage, but connect to \"],[0,[3],1,\"two \"],[0,[],0,\"existing or new elements. \"]]],[1,\"p\",[[0,[2],1,\"Meta: \"],[0,[],0,\"Choose one of the following three options:\"]]],[3,\"ul\",[[[0,[2],1,\"Connect: \"],[0,[],0,\"two non-player character elements\"]],[[0,[2],1,\"Replace: \"],[0,[],0,\"Remove an existing connection to your player character, and replace it with another connection to an existing element, or create a new one.\"]],[[0,[2],1,\"Introduce: \"],[0,[],0,\"With another player's consent, create a new element and connect it with their player character. That player gets to define the nature of the new connection\"]]]],[1,\"p\",[[0,[],0,\"Remember the Script Change tools. If a change is made to the map that you are unhappy with, or want to discuss, or if new information makes you regret a previous choice, feel free to ask for a rewind or pause.\"]]],[1,\"h3\",[[0,[],0,\"Step 1: Origin (Standard - One Addition)\"]]],[1,\"p\",[[0,[],0,\"Where did you come from, what were your formative experiences? We're your parents rich or poor, did thet have connections that affected your life? Did you excel in a particular subject at school? Did you focus on a particular career or lifestyle? Was there a major event that affected you and pushed you down a certain path?\"]]],[1,\"p\",[[0,[],0,\"Choose the die ratings for your Physical,Mental, and Social attributes, either assign a d10, a d8, and a d6, or assign a d8 to all three.\"]]],[1,\"h3\",[[0,[],0,\"Step 2: Life before (Major- Two Additions)\"]]],[1,\"p\",[[0,[],0,\"What were you before you became a Hammerhead Agent. Did you have a defining career, or membership of an organisation? Were there ongoing events that impacted your life? Do you have a spouse or long-term partner?\"]]],[1,\"p\",[[0,[],0,\"Write down the statement that defines the 'Your Life Before' distinction. \"]]],[1,\"h3\",[[0,[],0,\"Step 3: Focus (Standard - One Addition)\"]]],[1,\"p\",[[0,[],0,\"What motivates you, or defines who you are the most. Is there a status or posession you are striving for? Is or was there a situation, person, or organisation that inspired you? \"]]],[1,\"p\",[[0,[],0,\"Fill out the die ratings for your training packages. You can assign a single d10, four d8s, four d6s, and the rest default to d4s.\"]]],[1,\"h3\",[[0,[],0,\"Step 4: Life-Changing Event (Meta - One Change)\"]]],[1,\"p\",[[0,[],0,\"What has been the most disruptive thing to happen to you? Did you have a major achievement, or suffer a great tragedy? Did you witness somthing that changed your politics or beliefs? \"]]],[1,\"p\",[[0,[],0,\"Write down the statements for your remaining two distinctions: 'Your approach or attitude', and 'Your Quirk or Quality'.\"]]],[1,\"h3\",[[0,[],0,\"Step 5: Recruitment and Training (Major - Two Additions)\"]]],[1,\"p\",[[0,[],0,\"Was there a particular contact or experience that lead to your recruitment? Was there something that motivated you to seek membership of the WCO? Was there something significant that happened whilst you were training? What defines your relationship with your teammates?\"]]],[1,\"p\",[[0,[],0,\"You should try to ensure you have a connection to the World Crisis Organsiation and at least two player characters by the end of this stage.\"]]],[1,\"p\",[[0,[],0,\"You should add your relationship to each of the player characters, assigning one a d10, one a d8, and the rest a d6. The d10, and d8 should be for players you are connected to on the setting map. You may fill out the remaining relationship slots with any GMCs you have a connection to, or leave them blank.\"]]],[1,\"h3\",[[0,[],0,\"Everything else\"]]],[1,\"p\",[[0,[],0,\"The team building then proceeds as normal. Choose your Hammerhead model, and decide on your call signs. In Addition add 'Shared Background' to the a mission slot in the XP track. Once per mission, you can callback to any one of the elements connected to your character as though it was a previous mission.\"]]],[1,\"p\",[[0,[3],0,\"All art from \"],[0,[4],1,\"https://www.cortexrpg.com/compendium/hammerheads-spotlight/#Credits\"],[0,[],1,\",  2020 Fandom.\"]]]],\"ghostVersion\":\"3.0\"}","html":"<p>Hammerheads is set in the near future as climate change really starts to bite. You play an agent of the secretive World Crisis Organisation. The WCO is an elite group recruited from first responders, military, aid workers, and scientists. Their Hammerhead craft (High-Altitude, Multi-Mission, Emergency Response HEADquarters) allow them to be first on the scene when disaster strikes. It takes inspiration from Thunderbirds and various disaster movies, and is intended to be episodic with each session seeing the team tackle a new crisis.</p><p>All the rules and background needed to play are free online, as this is the sample setting available on the Cortex Website.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://www.cortexrpg.com/compendium/hammerheads-spotlight/\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Cortex Tabletop Roleplaying Game | Fandom Tabletop</div><div class=\"kg-bookmark-description\">Cortex is a multi-genre, modular, session-centered tabletop roleplaying game system. Build your own custom tabletop RPG game with Cortex.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://www.cortexrpg.com/cdn/media/static/cortex/img/favicon.png\"><span class=\"kg-bookmark-author\">Cortex</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://www.cortexrpg.com/cdn/media/static/cortex/img/opengraph.jpg\"></div></a></figure><p>Everything will be explained during play anyway, so read as much or as little as you have time for.</p><h2 id=\"script-change-rpg-toolkit\">Script Change RPG Toolkit</h2><p>Roleplaying should be safe and fun for everyone. We'll be using the Script Change RPG Toolkit to help faciltate this. </p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://briebeau.com/thoughty/script-change/\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Script Change RPG Toolbox</div><div class=\"kg-bookmark-description\">The formatted, printable Script Change file can be downloaded here. Find full page table safety tool references from Tomer Gurantz,and index card references here from Tomer as well! Script </div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://i0.wp.com/briebeau.com/thoughty/wp-content/uploads/2019/02/cropped-ThoughtyC_text-1.png?fit&#x3D;192%2C192&amp;ssl&#x3D;1\"><span class=\"kg-bookmark-author\">Thoughty</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://i0.wp.com/briebeau.com/thoughty/wp-content/uploads/2019/02/cropped-ThoughtyC_text-1.png?fit&#x3D;512%2C512&amp;ssl&#x3D;1\"></div></a></figure><p>This adds a bunch of tools for skipping, redoing, changing pace. It can be used if something is making you uncomfortable, or if you've just made a mistake, or had a better idea. </p><p>We'll open session zero with a discussion to allow players and the game moderator to discuss any topics to avoid or approach cautiously, and how we want to use the tools. If anyone has something they want to be avoided, but don't feel comfortable bringing up during a group discussion, feel free to message me privately.</p><p>The interrupt tools (pause, rewind, etc.) will be available as emojis in Discord, and should be included in the shared dice roller too.</p><figure class=\"kg-card kg-image-card\"><img src=\"__GHOST_URL__/content/images/2021/01/05-037.agents.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"850\" height=\"665\" srcset=\"__GHOST_URL__/content/images/size/w600/2021/01/05-037.agents.png 600w, __GHOST_URL__/content/images/2021/01/05-037.agents.png 850w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"character-building\">Character Building</h2><p>All you need to start with is a rough outline of the character you'd like to play, their name, and preferred pronouns. e.g.</p><ul><li>Anna Smith, She/Her - An aid worker who has voluteered for charity work since what was supposed to be a gap year.</li><li>Uhtred Ran, He/Him - Ex-special forces, who is self reliant to a fault.</li><li>Chris Tine, They/Them - Physicist with ADHD, worked on the Hammerhead designs.</li></ul><p>You can play a character as similar or different from yourself as you like. If you are portraying someone with different life experiences to your own, make sure to consider how to do so respectfully.</p><p>You will also need a discord account, and a Google account to access the Pathways Map. Please also download a character sheet.</p><ul><li><a href=\"https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFile-Hammerheads.pdf\">Standard</a> - to print and fill in.</li><li><a href=\"https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFileFillable-Hammerheads.pdf\">Form-fillable</a> - to fill in digitally.</li></ul><p>I'll be expanding on the provided character generation steps using a version of the Pathways. All of the below will be introduced and explained during the session as well.</p><h3 id=\"pathways-mapping-out-the-setting-\">Pathways - Mapping out the setting.</h3><p>Beyond the basic premise, very little about the setting is defined. This is intentional. Alongside building characters we will work together to build a setting around and connected to the characters.</p><p>Character generation will proceed through five stages. During each stage you will add new setting elements and/or link them to your character. Each stage also has a perticular trait or trait set to fill out on your character sheet, which will be done once everyone, including the Game Moderator, has had their chance to add to the map for that stage. </p><p>The map will be built on google slides to enable us all to edit it at once. There are four types of elements that can be added to the map.</p><!--kg-card-begin: html--><table>\n    <tbody>\n        <tr>\n            <th>\n                <img src=\"__GHOST_URL__/content/images/2021/01/map-pc.png\" alt=\"Rectangle (PC): Anna Smith\" />\n            </th>\n            <td>\n                <p>\n                <strong>Rectangles: Player Characters</strong>: The protagonists and focus of the the game and setting. The map starts with the players distributed around the edges.\n            </td>\n        </tr>\n        <tr>\n            <th>\n                <img src=\"__GHOST_URL__/content/images/2021/01/map-gmc.png\" alt=\"Oval (GMC): Herbert West\" />\n            </th>\n            <td>\n                <strong>Ovals: Game Moderator Characters</strong>: Other characers that feature in the setting. Will be portrayed by the Game Moderator if they turn up in play. \n            </td>\n        </tr>\n        <tr>\n            <th>\n                <img src=\"__GHOST_URL__/content/images/2021/01/map-resource.png\" alt=\"Diamond (Resource): World Crisis Organisation\" />\n            </th>\n            <td>\n                <strong>Diamonds: Resources</strong>: Resources are things in the world that players interact with, e.g. Organisations, Locations, or Props. The map starts with the World Crisis Organisation as a resource in the centre.\n            </td>\n        </tr>\n        <tr>\n            <th>\n                <img src=\"__GHOST_URL__/content/images/2021/01/map-event.png\" alt=\"Triangle (Situation): Iraq War Protest\" />\n            </th>\n            <td>\n                <strong>Triangles: Situations</strong>: An event or status that effects the characters in some way. Occupations, hobbies, crises, etc.\n            </td>\n        </tr>\n    </tbody>\n</table><!--kg-card-end: html--><p>These will be connected to each other by lines, with a label explaining how the two are related.</p><p>Each stage also has a type that determines how you can modify the map during that stage:</p><p><strong>Standard: </strong>Add a connection between an existing Character, Resource, or Situation and your player character; or add a new GMC, Resource, or Situaltion and connect it to your player character. If you are linking to another player character, discuss it with them first and agree on the relationship.</p><p><strong>Major: </strong>Same as a standard stage, but connect to <em>two </em>existing or new elements. </p><p><strong>Meta: </strong>Choose one of the following three options:</p><ul><li><strong>Connect: </strong>two non-player character elements</li><li><strong>Replace: </strong>Remove an existing connection to your player character, and replace it with another connection to an existing element, or create a new one.</li><li><strong>Introduce: </strong>With another player's consent, create a new element and connect it with their player character. That player gets to define the nature of the new connection</li></ul><p>Remember the Script Change tools. If a change is made to the map that you are unhappy with, or want to discuss, or if new information makes you regret a previous choice, feel free to ask for a rewind or pause.</p><h3 id=\"step-1-origin-standard-one-addition-\">Step 1: Origin (Standard - One Addition)</h3><p>Where did you come from, what were your formative experiences? We're your parents rich or poor, did thet have connections that affected your life? Did you excel in a particular subject at school? Did you focus on a particular career or lifestyle? Was there a major event that affected you and pushed you down a certain path?</p><p>Choose the die ratings for your Physical,Mental, and Social attributes, either assign a d10, a d8, and a d6, or assign a d8 to all three.</p><h3 id=\"step-2-life-before-major-two-additions-\">Step 2: Life before (Major- Two Additions)</h3><p>What were you before you became a Hammerhead Agent. Did you have a defining career, or membership of an organisation? Were there ongoing events that impacted your life? Do you have a spouse or long-term partner?</p><p>Write down the statement that defines the 'Your Life Before' distinction. </p><h3 id=\"step-3-focus-standard-one-addition-\">Step 3: Focus (Standard - One Addition)</h3><p>What motivates you, or defines who you are the most. Is there a status or posession you are striving for? Is or was there a situation, person, or organisation that inspired you? </p><p>Fill out the die ratings for your training packages. You can assign a single d10, four d8s, four d6s, and the rest default to d4s.</p><h3 id=\"step-4-life-changing-event-meta-one-change-\">Step 4: Life-Changing Event (Meta - One Change)</h3><p>What has been the most disruptive thing to happen to you? Did you have a major achievement, or suffer a great tragedy? Did you witness somthing that changed your politics or beliefs? </p><p>Write down the statements for your remaining two distinctions: 'Your approach or attitude', and 'Your Quirk or Quality'.</p><h3 id=\"step-5-recruitment-and-training-major-two-additions-\">Step 5: Recruitment and Training (Major - Two Additions)</h3><p>Was there a particular contact or experience that lead to your recruitment? Was there something that motivated you to seek membership of the WCO? Was there something significant that happened whilst you were training? What defines your relationship with your teammates?</p><p>You should try to ensure you have a connection to the World Crisis Organsiation and at least two player characters by the end of this stage.</p><p>You should add your relationship to each of the player characters, assigning one a d10, one a d8, and the rest a d6. The d10, and d8 should be for players you are connected to on the setting map. You may fill out the remaining relationship slots with any GMCs you have a connection to, or leave them blank.</p><h3 id=\"everything-else\">Everything else</h3><p>The team building then proceeds as normal. Choose your Hammerhead model, and decide on your call signs. In Addition add 'Shared Background' to the a mission slot in the XP track. Once per mission, you can callback to any one of the elements connected to your character as though it was a previous mission.</p><p><em>All art from <a href=\"https://www.cortexrpg.com/compendium/hammerheads-spotlight/#Credits\">https://www.cortexrpg.com/compendium/hammerheads-spotlight/#Credits</a>,  2020 Fandom.</em></p>","comment_id":"5ff1df307ced540c8c44c362","plaintext":"Hammerheads is set in the near future as climate change really starts to bite.\nYou play an agent of the secretive World Crisis Organisation. The WCO is an\nelite group recruited from first responders, military, aid workers, and\nscientists. Their Hammerhead craft (High-Altitude, Multi-Mission, Emergency\nResponse HEADquarters) allow them to be first on the scene when disaster\nstrikes. It takes inspiration from Thunderbirds and various disaster movies, and\nis intended to be episodic with each session seeing the team tackle a new\ncrisis.\n\nAll the rules and background needed to play are free online, as this is the\nsample setting available on the Cortex Website.\n\nCortex Tabletop Roleplaying Game | Fandom TabletopCortex is a multi-genre,\nmodular, session-centered tabletop roleplaying game system. Build your own\ncustom tabletop RPG game with Cortex.Cortex\n[https://www.cortexrpg.com/compendium/hammerheads-spotlight/]Everything will be\nexplained during play anyway, so read as much or as little as you have time for.\n\nScript Change RPG Toolkit\nRoleplaying should be safe and fun for everyone. We'll be using the Script\nChange RPG Toolkit to help faciltate this. \n\nScript Change RPG ToolboxThe formatted, printable Script Change file can be\ndownloaded here. Find full page table safety tool references from Tomer\nGurantz,and index card references here from Tomer as well! Script Thoughty\n[https://briebeau.com/thoughty/script-change/]This adds a bunch of tools for\nskipping, redoing, changing pace. It can be used if something is making you\nuncomfortable, or if you've just made a mistake, or had a better idea. \n\nWe'll open session zero with a discussion to allow players and the game\nmoderator to discuss any topics to avoid or approach cautiously, and how we want\nto use the tools. If anyone has something they want to be avoided, but don't\nfeel comfortable bringing up during a group discussion, feel free to message me\nprivately.\n\nThe interrupt tools (pause, rewind, etc.) will be available as emojis in\nDiscord, and should be included in the shared dice roller too.\n\nCharacter Building\nAll you need to start with is a rough outline of the character you'd like to\nplay, their name, and preferred pronouns. e.g.\n\n * Anna Smith, She/Her - An aid worker who has voluteered for charity work since\n   what was supposed to be a gap year.\n * Uhtred Ran, He/Him - Ex-special forces, who is self reliant to a fault.\n * Chris Tine, They/Them - Physicist with ADHD, worked on the Hammerhead\n   designs.\n\nYou can play a character as similar or different from yourself as you like. If\nyou are portraying someone with different life experiences to your own, make\nsure to consider how to do so respectfully.\n\nYou will also need a discord account, and a Google account to access the\nPathways Map. Please also download a character sheet.\n\n * Standard\n   [https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFile-Hammerheads.pdf] \n   - to print and fill in.\n * Form-fillable\n   [https://www.cortexrpg.com/cdn/media/compendium/cortex-prime-game-handbook/CortexPrime-CharacterFileFillable-Hammerheads.pdf] \n   - to fill in digitally.\n\nI'll be expanding on the provided character generation steps using a version of\nthe Pathways. All of the below will be introduced and explained during the\nsession as well.\n\nPathways - Mapping out the setting.\nBeyond the basic premise, very little about the setting is defined. This is\nintentional. Alongside building characters we will work together to build a\nsetting around and connected to the characters.\n\nCharacter generation will proceed through five stages. During each stage you\nwill add new setting elements and/or link them to your character. Each stage\nalso has a perticular trait or trait set to fill out on your character sheet,\nwhich will be done once everyone, including the Game Moderator, has had their\nchance to add to the map for that stage. \n\nThe map will be built on google slides to enable us all to edit it at once.\nThere are four types of elements that can be added to the map.\n\n Rectangles: Player Characters: The protagonists and focus of the the game and\nsetting. The map starts with the players distributed around the edges. \n\nOvals: Game Moderator Characters: Other characers that feature in the setting.\nWill be portrayed by the Game Moderator if they turn up in play. Diamonds:\nResources: Resources are things in the world that players interact with, e.g.\nOrganisations, Locations, or Props. The map starts with the World Crisis\nOrganisation as a resource in the centre. Triangles: Situations: An event or\nstatus that effects the characters in some way. Occupations, hobbies, crises,\netc. These will be connected to each other by lines, with a label explaining how\nthe two are related.\n\nEach stage also has a type that determines how you can modify the map during\nthat stage:\n\nStandard: Add a connection between an existing Character, Resource, or Situation\nand your player character; or add a new GMC, Resource, or Situaltion and connect\nit to your player character. If you are linking to another player character,\ndiscuss it with them first and agree on the relationship.\n\nMajor: Same as a standard stage, but connect to two existing or new elements. \n\nMeta: Choose one of the following three options:\n\n * Connect: two non-player character elements\n * Replace: Remove an existing connection to your player character, and replace\n   it with another connection to an existing element, or create a new one.\n * Introduce: With another player's consent, create a new element and connect it\n   with their player character. That player gets to define the nature of the new\n   connection\n\nRemember the Script Change tools. If a change is made to the map that you are\nunhappy with, or want to discuss, or if new information makes you regret a\nprevious choice, feel free to ask for a rewind or pause.\n\nStep 1: Origin (Standard - One Addition)\nWhere did you come from, what were your formative experiences? We're your\nparents rich or poor, did thet have connections that affected your life? Did you\nexcel in a particular subject at school? Did you focus on a particular career or\nlifestyle? Was there a major event that affected you and pushed you down a\ncertain path?\n\nChoose the die ratings for your Physical,Mental, and Social attributes, either\nassign a d10, a d8, and a d6, or assign a d8 to all three.\n\nStep 2: Life before (Major- Two Additions)\nWhat were you before you became a Hammerhead Agent. Did you have a defining\ncareer, or membership of an organisation? Were there ongoing events that\nimpacted your life? Do you have a spouse or long-term partner?\n\nWrite down the statement that defines the 'Your Life Before' distinction. \n\nStep 3: Focus (Standard - One Addition)\nWhat motivates you, or defines who you are the most. Is there a status or\nposession you are striving for? Is or was there a situation, person, or\norganisation that inspired you? \n\nFill out the die ratings for your training packages. You can assign a single\nd10, four d8s, four d6s, and the rest default to d4s.\n\nStep 4: Life-Changing Event (Meta - One Change)\nWhat has been the most disruptive thing to happen to you? Did you have a major\nachievement, or suffer a great tragedy? Did you witness somthing that changed\nyour politics or beliefs? \n\nWrite down the statements for your remaining two distinctions: 'Your approach or\nattitude', and 'Your Quirk or Quality'.\n\nStep 5: Recruitment and Training (Major - Two Additions)\nWas there a particular contact or experience that lead to your recruitment? Was\nthere something that motivated you to seek membership of the WCO? Was there\nsomething significant that happened whilst you were training? What defines your\nrelationship with your teammates?\n\nYou should try to ensure you have a connection to the World Crisis Organsiation\nand at least two player characters by the end of this stage.\n\nYou should add your relationship to each of the player characters, assigning one\na d10, one a d8, and the rest a d6. The d10, and d8 should be for players you\nare connected to on the setting map. You may fill out the remaining relationship\nslots with any GMCs you have a connection to, or leave them blank.\n\nEverything else\nThe team building then proceeds as normal. Choose your Hammerhead model, and\ndecide on your call signs. In Addition add 'Shared Background' to the a mission\nslot in the XP track. Once per mission, you can callback to any one of the\nelements connected to your character as though it was a previous mission.\n\nAll art from https://www.cortexrpg.com/compendium/hammerheads-spotlight/#Credits\n,  2020 Fandom.","feature_image":"__GHOST_URL__/content/images/2021/01/05-043.disaster.png","featured":0,"status":"published","locale":null,"visibility":"public","author_id":"1","created_at":"2021-01-03T15:13:52.000Z","updated_at":"2021-01-11T19:43:46.000Z","published_at":"2021-01-03T22:00:02.000Z","custom_excerpt":null,"codeinjection_head":"<style>\n    .post-full-content table td {\n        white-space: normal;\n        vertical-align: middle;\n    }\n</style>","codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"60d8f3a403d91a1964d010e2","uuid":"b343f3da-d19e-483e-97d8-706ef573290f","title":"React, Redux, RxJS","slug":"untitled","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n\\nThere are a number of single page react apps in Antler, and most use React as a view, Redux as a model, and redux-observable as (roughly) a controller. This explains roughly why this was chosen and how these interact. It is designed to demistify the existing react/redux apps so you can identify what each part is for and have the context to work out how it is working.\\n\\nThis doc assumes youve already setup installing react and setting up the build tools. You can find instrctions for this here:  \\n\\n .\\n\\nIt is also not intended to teach React from scratch. \\n\\n and the rest of the official react docs already do this really well.\\n\\n  This is now free and if you have the time it is a much better deepdive into Redux from its creator than I could ever do myself. It was this series that I used to learn this ion the first place.\\nRedux\\n\\nManaging state between components in React gets very complicated very quickly. If two disparate components need access to the same bit of data then that state has to be lifted up to a shared ancestor component. Then both the current value, and functions to modify the value passed down through each intermediate components props to the components that need to read and write that piece of data. Repeat this for each individual piece of shared data and it quickly becomes unmanageable. It can also end up with all your components being really tightly coupled.\\n\\nRedux solves this problem by providing:\\n\\n- A store of application state at the top level, essentially your applications model.\\n\\n- A way to access that in components without passing it through the props of intermediate components (read state)\\n\\n- A way for components to emit messages, and a standard way to update the application state in a modular way (update state).\\n\\n## Redux\\n\\nFirst install redux: `npm install -save redux react-redux`\\n\\nThen there is some boilerplate to add to get it all started. Below is an example doing this all in one file, but usually I split the store creation into its own file.\\n\\n```jsx\\n// index.jsx\\nimport React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\nimport {Provider} from \\\"react-redux\\\";\\nimport {combineReducers, createStore} from \\\"redux\\\";\\n// Or whatever the root component of your app currently is/will be\\nimport {CountingComponent} from \\\"./count\\\";\\n\\n// Individual reducers should be imported from the file that handles the \\n// components etc. for the relevant functionality to keep related things \\n// together.\\nfunction countReducer(state = 0, action) {\\n    switch (action.type) {\\n        // this is overly simple, it starts with an initial state of 0 and\\n        // no actions change that - I'll expand on these later. Note: the\\n        // default should always be to return the exact same state unchanged.\\n        default: return state;\\n    }\\n}\\n\\n// This both initialises the application state and handles updating it.\\n// When react starts up it calls each reducer with a no-op action and \\n// populates each of the keys in the object with the value that reducer\\n// returns, setting the application state to be that whole object. Then \\n// as each action is received it passes the relevant object property + the\\n// action, and builds the returned values into the new state, etc.\\n//\\n// It is called a reducer because conceptually a lot like a callback\\n// you could pass to Array.reduce if you had an array of actions.\\nconst rootReducer = combineReducers({\\n    count: countReducer,\\n});\\n\\nconst store = createStore(rootReducer);\\n\\n// normal react boilerplate\\nconst mount = document.getElementById('react-container');\\n\\n// If there is some data passed from the html you can dispatch actions here \\n// with the data read from mount.dataset e.g.\\n// `store.dispatch(setSupplierLookup(JSON.parse(mount.dataset.supplierLookup)));`\\n\\n// Wrap the root component in the Provider component imported from Redux. This is a\\n// key part of the mechanism that allows access to the state without intermediate props.\\nReactDOM.render(\\n    <Provider store={store}>\\n        <CountingComponent/>\\n    </Provider>,\\n    mount\\n);\\n```\\n\\nRedux is now setup, but its not doing anything noticeable.\\n\\n### Connecting Components\\n\\nTo access that state in a component we need to wrap it with Reduxs connect boilerplate. Continuing from above, Ill write the CountingComponent used as the root component.\\n\\n```jsx\\n// count.jsx\\nimport {connect} from \\\"react-redux\\\";\\nimport React from \\\"react\\\";\\n\\n// Usually the count reducer from above would go here\\n\\nexport const CountingComponent = connect(\\n    // a function that takes the current root state and returns an object that will be\\n    // merged with any props passed into the component. Note this uses object\\n    // destructuring/shorthand properties to get and set the required keys with minimal\\n    // characters \\n    ({count}) => ({count}), // <--- read just the count key from the root state, and \\n                            //      pass it to the component as the count prop.\\n    // Will hold functions used to emit actions - I'll cover this later\\n    {}\\n)\\n// connect returns a function that should be immediately called, passing the\\n// component it is wrapping as the only argument\\n(\\n    // Here I'll use a Function component: \\n    // https://reactjs.org/docs/components-and-props.html\\n    ({count}) => <h1>The count is {count}</h1>\\n)()\\n```\\n\\nThis will read the current count (currently 0) from the root stat, and display it. So we can now see it working, but it doesnt do much yet.\\n\\n![An image of a web browser displaying \\\"The count is 0\\\"](__GHOST_URL__/content/images/2021/07/image.png)\\n\\n### Updating state\\n\\nTo update state, actions are dispatched to the store. An action is just a javascript object that has a type key and then any arbitrary data to give context the action. For each action type you should write a function that takes the context and produces the desired action object. This is because redux needs to be able to wrap this function, giving you a function that will take the resulting action and dispatch it to the store. \\n\\n```jsx\\n// count.jsx - after the imports\\nconst INCREMENT_COUNT = Symbol('increment-count'); // can be a string if preferred\\n\\nconst incrementCount = (delta = 1) => ({\\n    type: INCREMENT_COUNT,\\n    delta\\n});\\n\\n// Then update the connect wrapper to pass in the action producing function\\nexport const CountingComponent = connect(\\n    ({count}) => ({count}),\\n    // The keys of this object will be the keys added to the props array\\n    // The values should be functions that generate the action objects\\n    {incrementCount}\\n)(\\n    ({count, incrementCount /* This is now wrapped to dispatch to the store */}) =>\\n        <div>\\n            <h1>The count is {count}</h1>\\n            // You can just call it as a normal function.\\n            <button onClick={() => incrementCount()}>+1</button>\\n            <button onClick={() => incrementCount(2)}>+2</button>\\n            <button onClick={() => incrementCount(-1)}>-1</button>\\n        </div>\\n);\\n\\nSo so the instructions to update the state are now bening sent to the store. To have that update the state, the reducer needs to be updated to make a change to its part of the state when that action is received.\\nexport function countReducer(state = 0, action) {\\n    switch (action.type) {\\n        case INCREMENT_COUNT:\\n            return state + action.delta\\n\\n        default:\\n            return state;\\n    }\\n}\\n```\\n\\nThis now runs and you can use the buttons to adjust the count.\\n\\n![An image of a web browser displaying \\\"The count is 5\\\" Under which are three buttons labelled +1, +2, and -1](blob:https://blog.goblinoid.co.uk/39330b92-a3b2-41a1-98c4-09fc5fc1691e)\\n\\n## RxJS and Redux Observable\\n\\nThere are still some things missing however. Often we want to do other things as well as just update the state/view when responding to user interaction. Examples of this are posting requests to a web server, or displaying something for a short period of time, then removing it. Redux has a concept of middleware that receives all the actions emitted by the components and can also dispatch its own actions to the store that allows for these types of responses.\\n\\nThe asynchronous nature of these lends itself very well to functional reactive programming, and [RxJS](https://rxjs.dev/guide/overview)  is one of the better libraries out there for doing this in Javascript. Based on RxJava the concepts are also transferrable to other languages where it is implemented. Redux Observable is a library that has utilities for using RxJS as Redux middleware. RxJS in simple terms allows you to conceptualise streams of events as arrays that also have a time dimension, and allows you to use methods like map, filter, etc. as you would on an array.\\n\\nFirst, install these extra dependencies `npm install --save rxjs redux-observable` \\n\\nLike Redux breaks up the state with a reducer for each key, Redux Observable divides its work into multiple epics each with their own responsibiliy. Were going to add a short success message each time the user changes the count that will display for 5 seconds then disappear. This will require two epics. One to respond to the INCREMENT_COUNT with another action to add a success message with an auto-incrementing id, and another that responds to that ADD_MESSAGE action with a REMOVE_MESSAGE action, delayed by 5 seconds.\\n\\nFirst lets update the existing counter with a list of messages. Theres nothing new here, this part is more Redux.\\n// count.jsx\\n// Actions and action producers:\\nconst ADD_MESSAGE = Symbol('add-message');\\nconst REMOVE_MESSAGE = Symbol('remove-message');\\n\\nconst addMessage = (id, message) => ({\\n    type: ADD_MESSAGE,\\n    id,\\n    message\\n});\\n\\nconst removeMessage = (id) => ({\\n    type: REMOVE_MESSAGE,\\n    id\\n});\\n\\n// Add a reducer to respond to the above\\nexport function messagesReducer(state = {}, action) {\\n    switch (action.type) {\\n        case ADD_MESSAGE:\\n            // Return a copy of the state object with just the relevant key changed\\n            return {...state, [action.id]: action.message}\\n\\n        case REMOVE_MESSAGE:\\n            // Return a copy of the state object with the relevant key filtered out\\n            return Object.fromEntries(\\n                Object.entries(state)\\n                      .filter(([k]) => k !== action.id.toString())\\n            );\\n\\n        default:\\n            return state;\\n    }\\n}\\n\\n// And update the component to show the messages\\nexport const CountingComponent = connect(\\n    ({count, messages}) => ({count, messages}),\\n    {incrementCount}\\n)(\\n    ({count, messages, incrementCount}) =>\\n        <div>\\n            <h1>The count is {count}</h1>\\n            <button onClick={() => incrementCount()}>+1</button>\\n            <button onClick={() => incrementCount(2)}>+2</button>\\n            <button onClick={() => incrementCount(-1)}>-1</button>\\n            <ul>\\n                {Object.entries(messages)\\n                       .map(([id, message]) => <li key={id}>{message}</li>)\\n                }\\n            </ul>\\n        </div>\\n);\\n\\nThe new reducer also needs registering in the root reducer. Note Ive also moved the countReducer into to count.js for consistency.\\n// index.jsx\\n// ...\\nimport {CountingComponent, countReducer, messagesReducer} from \\\"./count\\\";\\n\\nconst rootReducer = combineReducers({\\n    count:    countReducer,\\n    messages: messagesReducer,\\n});\\n// ...\\n\\nThat done, there now needs to be some epics to add and remove those messages before there is a noticable change. An epic is a function that takes two observable streams; action$ and state$, and returns a new stream of additional actions. Most of the time you just need the actions, but occasionally you need access to the rest of the state and not just what is contained in the action. Seach Antler for withLatestFrom(state$) for examples of doing this.\\n\\nIt can be easy to create unintentional infinite loops here. Each message output by the epic is added to the stream of messages going through Redux, including being passed back in to all the epics. If you emit a message of the same type that came in, that will just loop forever. Likewise if a pair of epics each respond to a type that the other emits, in combination they will keep responding to each others actions forever.\\n\\nWe need two epics, one that maps INCREMENT_COUNT actions to ADD_MESSAGE actions, and one that maps those ADD_MESSAGE actions into REMOVE_MESSAGE actions, but with a delay.\\n// count.jsx\\n// New imports for all the RxJS/redux-observable\\nimport {map} from \\\"rxjs/operators\\\";\\nimport {ofType} from \\\"redux-observable\\\";\\n\\n// ...\\n\\n// Store an id we can increment with each message. Having an external variable like \\n// this is often useful when coordinating changes over multiple actions.\\nlet id = 0;\\n\\nexport const addCountMessagesEpic = action$ =>\\n    // `pipe` is just RxJS boiler plate for transforming a stream. Each value that\\n    // comes into the stream gets passed to the first argument to pipe, the output\\n    // of that to the second argument and so on, the final argument's output is\\n    // published to the stream that pipe returns\\n    action$.pipe(\\n        // ofType is a utility from redux-observable, it filters to only the\\n        // message type(s) provided\\n        ofType(INCREMENT_COUNT),\\n        // straight up map the increment into a message\\n        map(({delta}) => addMessage(\\n            id++,\\n            // template strings are awesome!\\n            `You ${delta >= 0 ? 'incremented' : 'decremented'}` +\\n             ` the count by ${Math.abs(delta)}.`\\n        ))\\n    )\\n\\nexport const removeMessagesEpic = action$ =>\\n    action$.pipe(\\n        ofType(ADD_MESSAGE),\\n        map(({id}) => removeMessage(id)),\\n        // This adds the delay in ms. All of the timing/scheduling is handled #\\n        // inside RxJS and 'just works'\\n        delay(5000)\\n    )\\n\\nLike with reducers, epics need to be registered with Redux to actually be used:\\n// index.jsx\\n// ...\\nimport {applyMiddleware, combineReducers, createStore} from \\\"redux\\\";\\nimport {combineEpics, createEpicMiddleware} from \\\"redux-observable\\\";\\nimport {\\n    addCountMessagesEpic,\\n    CountingComponent,\\n    countReducer,\\n    messagesReducer,\\n    removeMessagesEpic\\n} from \\\"./count\\\";\\n\\n// If webpack is built using 'development' mode this will log all the\\n// messages passing through Redux. Note despite not emitting anything\\n// this still needs to return an observable stream to be valid, but\\n// RxJS has a built in EMPTY observable the never emits anything just\\n// for cases like this\\nconst loggingEpic = action$ => {\\n    if(process.env.NODE_ENV === 'development') {\\n        action$.subscribe(msg => console.log('Action:', new Date(), msg));\\n    }\\n\\n    return EMPTY;\\n};\\n\\n// Set up a rootEpic similar to the rootReducer. The stream of actions will be pushed to \\n// each of these, and the returned streams will all be merged together, ready to be \\n// fed into Redux\\nconst rootEpic = combineEpics(\\n    loggingEpic,\\n    addCountMessagesEpic,\\n    removeMessagesEpic\\n);\\n\\n// The middleware is passed as a second argument to Redux.createStore, this is all just \\n// boilerplate to make RxJS and Redux talk to each other. The store must be created\\n// before the epicMiddleware is run however.\\nconst epicMiddleware = createEpicMiddleware();\\n\\nconst store = createStore(rootReducer, applyMiddleware(epicMiddleware));\\n\\nepicMiddleware.run(rootEpic);\\n\\nAnd that is everything. You should now see a message show each time you press a button, only to disappear after 5 seconds.\\nImmutable.js\\nThere is one final issue with the setup described above. A key feature of React is that it has its own internal representation of the DOM, and it can calculate the diff beween the new view and the old, and just update the bits of the DOM tha have changed. \\n\\n There is an additional optimisation, a component can implement shouldComponentUpdate(nextProps, nextState) which should return true or false if given the change (or not) in state/props whether the view will change or not. This allows react to skip calling the render method for that component, and skip doing the diff of that part of its internal representation of the DOM.\\n\\nThe simplest way to implement this is to loop over all the props and state keys and compare them to the current values with ===. This is so common in fact that there is React.PureComponent that your component classes can extend which includes this, and Function components also use that implementation by default. Because state for the app is held at the root level, any change requires React to check the whole tree for updates, liberal use of Pure/Function components makes this much quicker.\\n\\nYou may have noticed the wierd extra steps I took to return a new object in the reducer for the messages array. This is because the downside of this strategy is if you just update a property of an object, it is still the same object: The === check then passes and the component isnt re-rendered. This copying of huge chunks of the application state is not performant. The code needed to make sure you return a copy can also be quite verbose, and its easy to make a mistake that then leads to subtle rendering bugs when you accidentaly mutate an object rather than copy it.\\n\\nThis is where \\n\\n is useful. It provides a bunch of primitive objects that you cant accidentally mutate, and that can be efficiently copied. It can be installed with npm install --save immutable. To give an example, Ill update the messagesReducer to use it:\\n// count.jsx\\n// ...\\nimport {Map} from \\\"immutable\\\"\\n\\n// ...\\nexport function messagesReducer(state = Map(), action) {\\n    switch (action.type) {\\n        case ADD_MESSAGE:\\n            // All the methods on the immutable objects return a new copy with the\\n            // appropriate update applied\\n            return state.set(action.id, action.message);\\n\\n        case REMOVE_MESSAGE:\\n            return state.remove(action.id)\\n\\n        default:\\n            return state;\\n    }\\n}\\n\\n// ... Inside the component. the `ul` of messages needs to  be rendered slightly \\n// differently now messages is an immutable map rather than a javascript object\\n<ul>\\n    {messages.entrySeq()\\n             .map(([id, message]) => <li key={id}>{message}</li>)\\n    }\\n</ul>\\n\\nWith those changes the apps behaviour is no different, but the code for updating the messages is cleaner and more efficient.\\nMiscellany\\n\\nRxJs comes with a built in websocket client, and it is this that is used to connect to the websocket server. This includes automatic reconnection logic within the websocket epic.\\n\\nSometimes even the PureComponents and immutable state is not efficient enough. One example of this is the description editor on the Third Party Approval page. The process of converting the whole editor state to the external representation, sending the action to update the application state, reading that state in a props, and converting back to DraftJSs internal state caused noticeable lag to typing. This was fixed by letting DraftJS keep its internal state independent of the application state. Changes to that state were pushed to an RxJS observable, which in turn used debounceTime to limit how often the application state was updated with the new description. shouldComponentUpdate was also manually implemented. The approval_id is added as a prop, and if it is present and the same as the existing source_id then a new editorState from props is ignored.\\n\\nAnother more common performance gotcha is when functions are passed as props into child components. Because these functions are created new each time render is called, it means PureComponents will see that the function for that prop has changed, and also re-render. Youll see all over the Third Party Approval app calls to this.cacheForApproval that is just a helper method that returns the same function if the id and function match one that was already created. You can also get around this in a class component by using a method of the class rather than an anonymous function in the render() method. Finally, since React v16.8 there are Hooks. Since the offending function is usually one to update state in some way  \\n\\n  can also help for some use cases.\\nExample\\n\\nThe full code for the example built through-out the above process should look something like these two files.\\n\\nindex.jsx\\n\"}],[\"image\",{\"src\":\"__GHOST_URL__/content/images/2021/07/image.png\",\"width\":343,\"height\":153}],[\"image\",{\"src\":\"__GHOST_URL__/content/images/2021/07/image-1.png\",\"width\":245,\"height\":178}]],\"markups\":[],\"sections\":[[10,0],[10,1],[10,2],[1,\"p\",[[0,[],0,\"d\"]]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>There are a number of single page react apps in Antler, and most use React as a view, Redux as a model, and redux-observable as (roughly) a controller. This explains roughly why this was chosen and how these interact. It is designed to demistify the existing react/redux apps so you can identify what each part is for and have the context to work out how it is working.</p>\n<p>This doc assumes youve already setup installing react and setting up the build tools. You can find instrctions for this here:</p>\n<p>.</p>\n<p>It is also not intended to teach React from scratch.</p>\n<p>and the rest of the official react docs already do this really well.</p>\n<p>This is now free and if you have the time it is a much better deepdive into Redux from its creator than I could ever do myself. It was this series that I used to learn this ion the first place.<br>\nRedux</p>\n<p>Managing state between components in React gets very complicated very quickly. If two disparate components need access to the same bit of data then that state has to be lifted up to a shared ancestor component. Then both the current value, and functions to modify the value passed down through each intermediate components props to the components that need to read and write that piece of data. Repeat this for each individual piece of shared data and it quickly becomes unmanageable. It can also end up with all your components being really tightly coupled.</p>\n<p>Redux solves this problem by providing:</p>\n<ul>\n<li>\n<p>A store of application state at the top level, essentially your applications model.</p>\n</li>\n<li>\n<p>A way to access that in components without passing it through the props of intermediate components (read state)</p>\n</li>\n<li>\n<p>A way for components to emit messages, and a standard way to update the application state in a modular way (update state).</p>\n</li>\n</ul>\n<h2 id=\"redux\">Redux</h2>\n<p>First install redux: <code>npm install -save redux react-redux</code></p>\n<p>Then there is some boilerplate to add to get it all started. Below is an example doing this all in one file, but usually I split the store creation into its own file.</p>\n<pre><code class=\"language-jsx\">// index.jsx\nimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport {Provider} from &quot;react-redux&quot;;\nimport {combineReducers, createStore} from &quot;redux&quot;;\n// Or whatever the root component of your app currently is/will be\nimport {CountingComponent} from &quot;./count&quot;;\n\n// Individual reducers should be imported from the file that handles the \n// components etc. for the relevant functionality to keep related things \n// together.\nfunction countReducer(state = 0, action) {\n    switch (action.type) {\n        // this is overly simple, it starts with an initial state of 0 and\n        // no actions change that - I'll expand on these later. Note: the\n        // default should always be to return the exact same state unchanged.\n        default: return state;\n    }\n}\n\n// This both initialises the application state and handles updating it.\n// When react starts up it calls each reducer with a no-op action and \n// populates each of the keys in the object with the value that reducer\n// returns, setting the application state to be that whole object. Then \n// as each action is received it passes the relevant object property + the\n// action, and builds the returned values into the new state, etc.\n//\n// It is called a reducer because conceptually a lot like a callback\n// you could pass to Array.reduce if you had an array of actions.\nconst rootReducer = combineReducers({\n    count: countReducer,\n});\n\nconst store = createStore(rootReducer);\n\n// normal react boilerplate\nconst mount = document.getElementById('react-container');\n\n// If there is some data passed from the html you can dispatch actions here \n// with the data read from mount.dataset e.g.\n// `store.dispatch(setSupplierLookup(JSON.parse(mount.dataset.supplierLookup)));`\n\n// Wrap the root component in the Provider component imported from Redux. This is a\n// key part of the mechanism that allows access to the state without intermediate props.\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;CountingComponent/&gt;\n    &lt;/Provider&gt;,\n    mount\n);\n</code></pre>\n<p>Redux is now setup, but its not doing anything noticeable.</p>\n<h3 id=\"connecting-components\">Connecting Components</h3>\n<p>To access that state in a component we need to wrap it with Reduxs connect boilerplate. Continuing from above, Ill write the CountingComponent used as the root component.</p>\n<pre><code class=\"language-jsx\">// count.jsx\nimport {connect} from &quot;react-redux&quot;;\nimport React from &quot;react&quot;;\n\n// Usually the count reducer from above would go here\n\nexport const CountingComponent = connect(\n    // a function that takes the current root state and returns an object that will be\n    // merged with any props passed into the component. Note this uses object\n    // destructuring/shorthand properties to get and set the required keys with minimal\n    // characters \n    ({count}) =&gt; ({count}), // &lt;--- read just the count key from the root state, and \n                            //      pass it to the component as the count prop.\n    // Will hold functions used to emit actions - I'll cover this later\n    {}\n)\n// connect returns a function that should be immediately called, passing the\n// component it is wrapping as the only argument\n(\n    // Here I'll use a Function component: \n    // https://reactjs.org/docs/components-and-props.html\n    ({count}) =&gt; &lt;h1&gt;The count is {count}&lt;/h1&gt;\n)()\n</code></pre>\n<p>This will read the current count (currently 0) from the root stat, and display it. So we can now see it working, but it doesnt do much yet.</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/07/image.png\" alt=\"An image of a web browser displaying &quot;The count is 0&quot;\" loading=\"lazy\"></p>\n<h3 id=\"updating-state\">Updating state</h3>\n<p>To update state, actions are dispatched to the store. An action is just a javascript object that has a type key and then any arbitrary data to give context the action. For each action type you should write a function that takes the context and produces the desired action object. This is because redux needs to be able to wrap this function, giving you a function that will take the resulting action and dispatch it to the store.</p>\n<pre><code class=\"language-jsx\">// count.jsx - after the imports\nconst INCREMENT_COUNT = Symbol('increment-count'); // can be a string if preferred\n\nconst incrementCount = (delta = 1) =&gt; ({\n    type: INCREMENT_COUNT,\n    delta\n});\n\n// Then update the connect wrapper to pass in the action producing function\nexport const CountingComponent = connect(\n    ({count}) =&gt; ({count}),\n    // The keys of this object will be the keys added to the props array\n    // The values should be functions that generate the action objects\n    {incrementCount}\n)(\n    ({count, incrementCount /* This is now wrapped to dispatch to the store */}) =&gt;\n        &lt;div&gt;\n            &lt;h1&gt;The count is {count}&lt;/h1&gt;\n            // You can just call it as a normal function.\n            &lt;button onClick={() =&gt; incrementCount()}&gt;+1&lt;/button&gt;\n            &lt;button onClick={() =&gt; incrementCount(2)}&gt;+2&lt;/button&gt;\n            &lt;button onClick={() =&gt; incrementCount(-1)}&gt;-1&lt;/button&gt;\n        &lt;/div&gt;\n);\n\nSo so the instructions to update the state are now bening sent to the store. To have that update the state, the reducer needs to be updated to make a change to its part of the state when that action is received.\nexport function countReducer(state = 0, action) {\n    switch (action.type) {\n        case INCREMENT_COUNT:\n            return state + action.delta\n\n        default:\n            return state;\n    }\n}\n</code></pre>\n<p>This now runs and you can use the buttons to adjust the count.</p>\n<p><img src=\"blob:https://blog.goblinoid.co.uk/39330b92-a3b2-41a1-98c4-09fc5fc1691e\" alt=\"An image of a web browser displaying &quot;The count is 5&quot; Under which are three buttons labelled +1, +2, and -1\" loading=\"lazy\"></p>\n<h2 id=\"rxjs-and-redux-observable\">RxJS and Redux Observable</h2>\n<p>There are still some things missing however. Often we want to do other things as well as just update the state/view when responding to user interaction. Examples of this are posting requests to a web server, or displaying something for a short period of time, then removing it. Redux has a concept of middleware that receives all the actions emitted by the components and can also dispatch its own actions to the store that allows for these types of responses.</p>\n<p>The asynchronous nature of these lends itself very well to functional reactive programming, and <a href=\"https://rxjs.dev/guide/overview\">RxJS</a>  is one of the better libraries out there for doing this in Javascript. Based on RxJava the concepts are also transferrable to other languages where it is implemented. Redux Observable is a library that has utilities for using RxJS as Redux middleware. RxJS in simple terms allows you to conceptualise streams of events as arrays that also have a time dimension, and allows you to use methods like map, filter, etc. as you would on an array.</p>\n<p>First, install these extra dependencies <code>npm install --save rxjs redux-observable</code></p>\n<p>Like Redux breaks up the state with a reducer for each key, Redux Observable divides its work into multiple epics each with their own responsibiliy. Were going to add a short success message each time the user changes the count that will display for 5 seconds then disappear. This will require two epics. One to respond to the INCREMENT_COUNT with another action to add a success message with an auto-incrementing id, and another that responds to that ADD_MESSAGE action with a REMOVE_MESSAGE action, delayed by 5 seconds.</p>\n<p>First lets update the existing counter with a list of messages. Theres nothing new here, this part is more Redux.<br>\n// count.jsx<br>\n// Actions and action producers:<br>\nconst ADD_MESSAGE = Symbol('add-message');<br>\nconst REMOVE_MESSAGE = Symbol('remove-message');</p>\n<p>const addMessage = (id, message) =&gt; ({<br>\ntype: ADD_MESSAGE,<br>\nid,<br>\nmessage<br>\n});</p>\n<p>const removeMessage = (id) =&gt; ({<br>\ntype: REMOVE_MESSAGE,<br>\nid<br>\n});</p>\n<p>// Add a reducer to respond to the above<br>\nexport function messagesReducer(state = {}, action) {<br>\nswitch (action.type) {<br>\ncase ADD_MESSAGE:<br>\n// Return a copy of the state object with just the relevant key changed<br>\nreturn {...state, [action.id]: action.message}</p>\n<pre><code>    case REMOVE_MESSAGE:\n        // Return a copy of the state object with the relevant key filtered out\n        return Object.fromEntries(\n            Object.entries(state)\n                  .filter(([k]) =&gt; k !== action.id.toString())\n        );\n\n    default:\n        return state;\n}\n</code></pre>\n<p>}</p>\n<p>// And update the component to show the messages<br>\nexport const CountingComponent = connect(<br>\n({count, messages}) =&gt; ({count, messages}),<br>\n{incrementCount}<br>\n)(<br>\n({count, messages, incrementCount}) =&gt;<br>\n<div><br>\n<h1>The count is {count}</h1><br>\n&lt;button onClick={() =&gt; incrementCount()}&gt;+1</button><br>\n&lt;button onClick={() =&gt; incrementCount(2)}&gt;+2</button><br>\n&lt;button onClick={() =&gt; incrementCount(-1)}&gt;-1</button><br>\n<ul><br>\n{Object.entries(messages)<br>\n.map(([id, message]) =&gt; <li key={id}>{message}</li>)<br>\n}<br>\n</ul><br>\n</div><br>\n);</p>\n<p>The new reducer also needs registering in the root reducer. Note Ive also moved the countReducer into to count.js for consistency.<br>\n// index.jsx<br>\n// ...<br>\nimport {CountingComponent, countReducer, messagesReducer} from &quot;./count&quot;;</p>\n<p>const rootReducer = combineReducers({<br>\ncount:    countReducer,<br>\nmessages: messagesReducer,<br>\n});<br>\n// ...</p>\n<p>That done, there now needs to be some epics to add and remove those messages before there is a noticable change. An epic is a function that takes two observable streams; action$ and state$, and returns a new stream of additional actions. Most of the time you just need the actions, but occasionally you need access to the rest of the state and not just what is contained in the action. Seach Antler for withLatestFrom(state$) for examples of doing this.</p>\n<p>It can be easy to create unintentional infinite loops here. Each message output by the epic is added to the stream of messages going through Redux, including being passed back in to all the epics. If you emit a message of the same type that came in, that will just loop forever. Likewise if a pair of epics each respond to a type that the other emits, in combination they will keep responding to each others actions forever.</p>\n<p>We need two epics, one that maps INCREMENT_COUNT actions to ADD_MESSAGE actions, and one that maps those ADD_MESSAGE actions into REMOVE_MESSAGE actions, but with a delay.<br>\n// count.jsx<br>\n// New imports for all the RxJS/redux-observable<br>\nimport {map} from &quot;rxjs/operators&quot;;<br>\nimport {ofType} from &quot;redux-observable&quot;;</p>\n<p>// ...</p>\n<p>// Store an id we can increment with each message. Having an external variable like<br>\n// this is often useful when coordinating changes over multiple actions.<br>\nlet id = 0;</p>\n<p>export const addCountMessagesEpic = action$ =&gt;<br>\n// <code>pipe</code> is just RxJS boiler plate for transforming a stream. Each value that<br>\n// comes into the stream gets passed to the first argument to pipe, the output<br>\n// of that to the second argument and so on, the final argument's output is<br>\n// published to the stream that pipe returns<br>\naction$.pipe(<br>\n// ofType is a utility from redux-observable, it filters to only the<br>\n// message type(s) provided<br>\nofType(INCREMENT_COUNT),<br>\n// straight up map the increment into a message<br>\nmap(({delta}) =&gt; addMessage(<br>\nid++,<br>\n// template strings are awesome!<br>\n<code>You ${delta &gt;= 0 ? 'incremented' : 'decremented'}</code> +<br>\n<code> the count by ${Math.abs(delta)}.</code><br>\n))<br>\n)</p>\n<p>export const removeMessagesEpic = action$ =&gt;<br>\naction$.pipe(<br>\nofType(ADD_MESSAGE),<br>\nmap(({id}) =&gt; removeMessage(id)),<br>\n// This adds the delay in ms. All of the timing/scheduling is handled #<br>\n// inside RxJS and 'just works'<br>\ndelay(5000)<br>\n)</p>\n<p>Like with reducers, epics need to be registered with Redux to actually be used:<br>\n// index.jsx<br>\n// ...<br>\nimport {applyMiddleware, combineReducers, createStore} from &quot;redux&quot;;<br>\nimport {combineEpics, createEpicMiddleware} from &quot;redux-observable&quot;;<br>\nimport {<br>\naddCountMessagesEpic,<br>\nCountingComponent,<br>\ncountReducer,<br>\nmessagesReducer,<br>\nremoveMessagesEpic<br>\n} from &quot;./count&quot;;</p>\n<p>// If webpack is built using 'development' mode this will log all the<br>\n// messages passing through Redux. Note despite not emitting anything<br>\n// this still needs to return an observable stream to be valid, but<br>\n// RxJS has a built in EMPTY observable the never emits anything just<br>\n// for cases like this<br>\nconst loggingEpic = action$ =&gt; {<br>\nif(process.env.NODE_ENV === 'development') {<br>\naction$.subscribe(msg =&gt; console.log('Action:', new Date(), msg));<br>\n}</p>\n<pre><code>return EMPTY;\n</code></pre>\n<p>};</p>\n<p>// Set up a rootEpic similar to the rootReducer. The stream of actions will be pushed to<br>\n// each of these, and the returned streams will all be merged together, ready to be<br>\n// fed into Redux<br>\nconst rootEpic = combineEpics(<br>\nloggingEpic,<br>\naddCountMessagesEpic,<br>\nremoveMessagesEpic<br>\n);</p>\n<p>// The middleware is passed as a second argument to Redux.createStore, this is all just<br>\n// boilerplate to make RxJS and Redux talk to each other. The store must be created<br>\n// before the epicMiddleware is run however.<br>\nconst epicMiddleware = createEpicMiddleware();</p>\n<p>const store = createStore(rootReducer, applyMiddleware(epicMiddleware));</p>\n<p>epicMiddleware.run(rootEpic);</p>\n<p>And that is everything. You should now see a message show each time you press a button, only to disappear after 5 seconds.<br>\nImmutable.js<br>\nThere is one final issue with the setup described above. A key feature of React is that it has its own internal representation of the DOM, and it can calculate the diff beween the new view and the old, and just update the bits of the DOM tha have changed.</p>\n<p>There is an additional optimisation, a component can implement shouldComponentUpdate(nextProps, nextState) which should return true or false if given the change (or not) in state/props whether the view will change or not. This allows react to skip calling the render method for that component, and skip doing the diff of that part of its internal representation of the DOM.</p>\n<p>The simplest way to implement this is to loop over all the props and state keys and compare them to the current values with ===. This is so common in fact that there is React.PureComponent that your component classes can extend which includes this, and Function components also use that implementation by default. Because state for the app is held at the root level, any change requires React to check the whole tree for updates, liberal use of Pure/Function components makes this much quicker.</p>\n<p>You may have noticed the wierd extra steps I took to return a new object in the reducer for the messages array. This is because the downside of this strategy is if you just update a property of an object, it is still the same object: The === check then passes and the component isnt re-rendered. This copying of huge chunks of the application state is not performant. The code needed to make sure you return a copy can also be quite verbose, and its easy to make a mistake that then leads to subtle rendering bugs when you accidentaly mutate an object rather than copy it.</p>\n<p>This is where</p>\n<p>is useful. It provides a bunch of primitive objects that you cant accidentally mutate, and that can be efficiently copied. It can be installed with npm install --save immutable. To give an example, Ill update the messagesReducer to use it:<br>\n// count.jsx<br>\n// ...<br>\nimport {Map} from &quot;immutable&quot;</p>\n<p>// ...<br>\nexport function messagesReducer(state = Map(), action) {<br>\nswitch (action.type) {<br>\ncase ADD_MESSAGE:<br>\n// All the methods on the immutable objects return a new copy with the<br>\n// appropriate update applied<br>\nreturn state.set(action.id, action.message);</p>\n<pre><code>    case REMOVE_MESSAGE:\n        return state.remove(action.id)\n\n    default:\n        return state;\n}\n</code></pre>\n<p>}</p>\n<p>// ... Inside the component. the <code>ul</code> of messages needs to  be rendered slightly<br>\n// differently now messages is an immutable map rather than a javascript object</p>\n<ul>\n    {messages.entrySeq()\n             .map(([id, message]) => <li key={id}>{message}</li>)\n    }\n</ul>\n<p>With those changes the apps behaviour is no different, but the code for updating the messages is cleaner and more efficient.<br>\nMiscellany</p>\n<p>RxJs comes with a built in websocket client, and it is this that is used to connect to the websocket server. This includes automatic reconnection logic within the websocket epic.</p>\n<p>Sometimes even the PureComponents and immutable state is not efficient enough. One example of this is the description editor on the Third Party Approval page. The process of converting the whole editor state to the external representation, sending the action to update the application state, reading that state in a props, and converting back to DraftJSs internal state caused noticeable lag to typing. This was fixed by letting DraftJS keep its internal state independent of the application state. Changes to that state were pushed to an RxJS observable, which in turn used debounceTime to limit how often the application state was updated with the new description. shouldComponentUpdate was also manually implemented. The approval_id is added as a prop, and if it is present and the same as the existing source_id then a new editorState from props is ignored.</p>\n<p>Another more common performance gotcha is when functions are passed as props into child components. Because these functions are created new each time render is called, it means PureComponents will see that the function for that prop has changed, and also re-render. Youll see all over the Third Party Approval app calls to this.cacheForApproval that is just a helper method that returns the same function if the id and function match one that was already created. You can also get around this in a class component by using a method of the class rather than an anonymous function in the render() method. Finally, since React v16.8 there are Hooks. Since the offending function is usually one to update state in some way</p>\n<p>can also help for some use cases.<br>\nExample</p>\n<p>The full code for the example built through-out the above process should look something like these two files.</p>\n<p>index.jsx</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"__GHOST_URL__/content/images/2021/07/image.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"343\" height=\"153\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"__GHOST_URL__/content/images/2021/07/image-1.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"245\" height=\"178\"></figure><p>d</p>","comment_id":"60d8f3a403d91a1964d010e2","plaintext":"There are a number of single page react apps in Antler, and most use React as a\nview, Redux as a model, and redux-observable as (roughly) a controller. This\nexplains roughly why this was chosen and how these interact. It is designed to\ndemistify the existing react/redux apps so you can identify what each part is\nfor and have the context to work out how it is working.\n\nThis doc assumes youve already setup installing react and setting up the build\ntools. You can find instrctions for this here:\n\n.\n\nIt is also not intended to teach React from scratch.\n\nand the rest of the official react docs already do this really well.\n\nThis is now free and if you have the time it is a much better deepdive into\nRedux from its creator than I could ever do myself. It was this series that I\nused to learn this ion the first place.\nRedux\n\nManaging state between components in React gets very complicated very quickly.\nIf two disparate components need access to the same bit of data then that state\nhas to be lifted up to a shared ancestor component. Then both the current value,\nand functions to modify the value passed down through each intermediate\ncomponents props to the components that need to read and write that piece of\ndata. Repeat this for each individual piece of shared data and it quickly\nbecomes unmanageable. It can also end up with all your components being really\ntightly coupled.\n\nRedux solves this problem by providing:\n\n * A store of application state at the top level, essentially your applications\n   model.\n   \n   \n * A way to access that in components without passing it through the props of\n   intermediate components (read state)\n   \n   \n * A way for components to emit messages, and a standard way to update the\n   application state in a modular way (update state).\n   \n   \n\nRedux\nFirst install redux: npm install -save redux react-redux\n\nThen there is some boilerplate to add to get it all started. Below is an example\ndoing this all in one file, but usually I split the store creation into its own\nfile.\n\n// index.jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {Provider} from \"react-redux\";\nimport {combineReducers, createStore} from \"redux\";\n// Or whatever the root component of your app currently is/will be\nimport {CountingComponent} from \"./count\";\n\n// Individual reducers should be imported from the file that handles the \n// components etc. for the relevant functionality to keep related things \n// together.\nfunction countReducer(state = 0, action) {\n    switch (action.type) {\n        // this is overly simple, it starts with an initial state of 0 and\n        // no actions change that - I'll expand on these later. Note: the\n        // default should always be to return the exact same state unchanged.\n        default: return state;\n    }\n}\n\n// This both initialises the application state and handles updating it.\n// When react starts up it calls each reducer with a no-op action and \n// populates each of the keys in the object with the value that reducer\n// returns, setting the application state to be that whole object. Then \n// as each action is received it passes the relevant object property + the\n// action, and builds the returned values into the new state, etc.\n//\n// It is called a reducer because conceptually a lot like a callback\n// you could pass to Array.reduce if you had an array of actions.\nconst rootReducer = combineReducers({\n    count: countReducer,\n});\n\nconst store = createStore(rootReducer);\n\n// normal react boilerplate\nconst mount = document.getElementById('react-container');\n\n// If there is some data passed from the html you can dispatch actions here \n// with the data read from mount.dataset e.g.\n// `store.dispatch(setSupplierLookup(JSON.parse(mount.dataset.supplierLookup)));`\n\n// Wrap the root component in the Provider component imported from Redux. This is a\n// key part of the mechanism that allows access to the state without intermediate props.\nReactDOM.render(\n    <Provider store={store}>\n        <CountingComponent/>\n    </Provider>,\n    mount\n);\n\n\nRedux is now setup, but its not doing anything noticeable.\n\nConnecting Components\nTo access that state in a component we need to wrap it with Reduxs connect\nboilerplate. Continuing from above, Ill write the CountingComponent used as the\nroot component.\n\n// count.jsx\nimport {connect} from \"react-redux\";\nimport React from \"react\";\n\n// Usually the count reducer from above would go here\n\nexport const CountingComponent = connect(\n    // a function that takes the current root state and returns an object that will be\n    // merged with any props passed into the component. Note this uses object\n    // destructuring/shorthand properties to get and set the required keys with minimal\n    // characters \n    ({count}) => ({count}), // <--- read just the count key from the root state, and \n                            //      pass it to the component as the count prop.\n    // Will hold functions used to emit actions - I'll cover this later\n    {}\n)\n// connect returns a function that should be immediately called, passing the\n// component it is wrapping as the only argument\n(\n    // Here I'll use a Function component: \n    // https://reactjs.org/docs/components-and-props.html\n    ({count}) => <h1>The count is {count}</h1>\n)()\n\n\nThis will read the current count (currently 0) from the root stat, and display\nit. So we can now see it working, but it doesnt do much yet.\n\n\n\nUpdating state\nTo update state, actions are dispatched to the store. An action is just a\njavascript object that has a type key and then any arbitrary data to give\ncontext the action. For each action type you should write a function that takes\nthe context and produces the desired action object. This is because redux needs\nto be able to wrap this function, giving you a function that will take the\nresulting action and dispatch it to the store.\n\n// count.jsx - after the imports\nconst INCREMENT_COUNT = Symbol('increment-count'); // can be a string if preferred\n\nconst incrementCount = (delta = 1) => ({\n    type: INCREMENT_COUNT,\n    delta\n});\n\n// Then update the connect wrapper to pass in the action producing function\nexport const CountingComponent = connect(\n    ({count}) => ({count}),\n    // The keys of this object will be the keys added to the props array\n    // The values should be functions that generate the action objects\n    {incrementCount}\n)(\n    ({count, incrementCount /* This is now wrapped to dispatch to the store */}) =>\n        <div>\n            <h1>The count is {count}</h1>\n            // You can just call it as a normal function.\n            <button onClick={() => incrementCount()}>+1</button>\n            <button onClick={() => incrementCount(2)}>+2</button>\n            <button onClick={() => incrementCount(-1)}>-1</button>\n        </div>\n);\n\nSo so the instructions to update the state are now bening sent to the store. To have that update the state, the reducer needs to be updated to make a change to its part of the state when that action is received.\nexport function countReducer(state = 0, action) {\n    switch (action.type) {\n        case INCREMENT_COUNT:\n            return state + action.delta\n\n        default:\n            return state;\n    }\n}\n\n\nThis now runs and you can use the buttons to adjust the count.\n\n\n\nRxJS and Redux Observable\nThere are still some things missing however. Often we want to do other things as\nwell as just update the state/view when responding to user interaction. Examples\nof this are posting requests to a web server, or displaying something for a\nshort period of time, then removing it. Redux has a concept of middleware that\nreceives all the actions emitted by the components and can also dispatch its own\nactions to the store that allows for these types of responses.\n\nThe asynchronous nature of these lends itself very well to functional reactive\nprogramming, and RxJS [https://rxjs.dev/guide/overview] is one of the better\nlibraries out there for doing this in Javascript. Based on RxJava the concepts\nare also transferrable to other languages where it is implemented. Redux\nObservable is a library that has utilities for using RxJS as Redux middleware.\nRxJS in simple terms allows you to conceptualise streams of events as arrays\nthat also have a time dimension, and allows you to use methods like map, filter,\netc. as you would on an array.\n\nFirst, install these extra dependencies npm install --save rxjs redux-observable\n\nLike Redux breaks up the state with a reducer for each key, Redux Observable\ndivides its work into multiple epics each with their own responsibiliy. Were\ngoing to add a short success message each time the user changes the count that\nwill display for 5 seconds then disappear. This will require two epics. One to\nrespond to the INCREMENT_COUNT with another action to add a success message with\nan auto-incrementing id, and another that responds to that ADD_MESSAGE action\nwith a REMOVE_MESSAGE action, delayed by 5 seconds.\n\nFirst lets update the existing counter with a list of messages. Theres nothing\nnew here, this part is more Redux.\n// count.jsx\n// Actions and action producers:\nconst ADD_MESSAGE = Symbol('add-message');\nconst REMOVE_MESSAGE = Symbol('remove-message');\n\nconst addMessage = (id, message) => ({\ntype: ADD_MESSAGE,\nid,\nmessage\n});\n\nconst removeMessage = (id) => ({\ntype: REMOVE_MESSAGE,\nid\n});\n\n// Add a reducer to respond to the above\nexport function messagesReducer(state = {}, action) {\nswitch (action.type) {\ncase ADD_MESSAGE:\n// Return a copy of the state object with just the relevant key changed\nreturn {...state, [action.id]: action.message}\n\n    case REMOVE_MESSAGE:\n        // Return a copy of the state object with the relevant key filtered out\n        return Object.fromEntries(\n            Object.entries(state)\n                  .filter(([k]) => k !== action.id.toString())\n        );\n\n    default:\n        return state;\n}\n\n\n}\n\n// And update the component to show the messages\nexport const CountingComponent = connect(\n({count, messages}) => ({count, messages}),\n{incrementCount}\n)(\n({count, messages, incrementCount}) =>\n\nThe count is {count}\n\n<button onClick={() => incrementCount()}>+1\n<button onClick={() => incrementCount(2)}>+2\n<button onClick={() => incrementCount(-1)}>-1\n * \n * \n * \n * \n * {message}\n * \n * \n * \n * \n\n\n\n);\n\nThe new reducer also needs registering in the root reducer. Note Ive also moved\nthe countReducer into to count.js for consistency.\n// index.jsx\n// ...\nimport {CountingComponent, countReducer, messagesReducer} from \"./count\";\n\nconst rootReducer = combineReducers({\ncount: countReducer,\nmessages: messagesReducer,\n});\n// ...\n\nThat done, there now needs to be some epics to add and remove those messages\nbefore there is a noticable change. An epic is a function that takes two\nobservable streams; action$ and state$, and returns a new stream of additional\nactions. Most of the time you just need the actions, but occasionally you need\naccess to the rest of the state and not just what is contained in the action.\nSeach Antler for withLatestFrom(state$) for examples of doing this.\n\nIt can be easy to create unintentional infinite loops here. Each message output\nby the epic is added to the stream of messages going through Redux, including\nbeing passed back in to all the epics. If you emit a message of the same type\nthat came in, that will just loop forever. Likewise if a pair of epics each\nrespond to a type that the other emits, in combination they will keep responding\nto each others actions forever.\n\nWe need two epics, one that maps INCREMENT_COUNT actions to ADD_MESSAGE actions,\nand one that maps those ADD_MESSAGE actions into REMOVE_MESSAGE actions, but\nwith a delay.\n// count.jsx\n// New imports for all the RxJS/redux-observable\nimport {map} from \"rxjs/operators\";\nimport {ofType} from \"redux-observable\";\n\n// ...\n\n// Store an id we can increment with each message. Having an external variable\nlike\n// this is often useful when coordinating changes over multiple actions.\nlet id = 0;\n\nexport const addCountMessagesEpic = action$ =>\n// pipe is just RxJS boiler plate for transforming a stream. Each value that\n// comes into the stream gets passed to the first argument to pipe, the output\n// of that to the second argument and so on, the final argument's output is\n// published to the stream that pipe returns\naction$.pipe(\n// ofType is a utility from redux-observable, it filters to only the\n// message type(s) provided\nofType(INCREMENT_COUNT),\n// straight up map the increment into a message\nmap(({delta}) => addMessage(\nid++,\n// template strings are awesome!\nYou ${delta >= 0 ? 'incremented' : 'decremented'} +\nthe count by ${Math.abs(delta)}.\n))\n)\n\nexport const removeMessagesEpic = action$ =>\naction$.pipe(\nofType(ADD_MESSAGE),\nmap(({id}) => removeMessage(id)),\n// This adds the delay in ms. All of the timing/scheduling is handled #\n// inside RxJS and 'just works'\ndelay(5000)\n)\n\nLike with reducers, epics need to be registered with Redux to actually be used:\n// index.jsx\n// ...\nimport {applyMiddleware, combineReducers, createStore} from \"redux\";\nimport {combineEpics, createEpicMiddleware} from \"redux-observable\";\nimport {\naddCountMessagesEpic,\nCountingComponent,\ncountReducer,\nmessagesReducer,\nremoveMessagesEpic\n} from \"./count\";\n\n// If webpack is built using 'development' mode this will log all the\n// messages passing through Redux. Note despite not emitting anything\n// this still needs to return an observable stream to be valid, but\n// RxJS has a built in EMPTY observable the never emits anything just\n// for cases like this\nconst loggingEpic = action$ => {\nif(process.env.NODE_ENV === 'development') {\naction$.subscribe(msg => console.log('Action:', new Date(), msg));\n}\n\nreturn EMPTY;\n\n\n};\n\n// Set up a rootEpic similar to the rootReducer. The stream of actions will be\npushed to\n// each of these, and the returned streams will all be merged together, ready to\nbe\n// fed into Redux\nconst rootEpic = combineEpics(\nloggingEpic,\naddCountMessagesEpic,\nremoveMessagesEpic\n);\n\n// The middleware is passed as a second argument to Redux.createStore, this is\nall just\n// boilerplate to make RxJS and Redux talk to each other. The store must be\ncreated\n// before the epicMiddleware is run however.\nconst epicMiddleware = createEpicMiddleware();\n\nconst store = createStore(rootReducer, applyMiddleware(epicMiddleware));\n\nepicMiddleware.run(rootEpic);\n\nAnd that is everything. You should now see a message show each time you press a\nbutton, only to disappear after 5 seconds.\nImmutable.js\nThere is one final issue with the setup described above. A key feature of React\nis that it has its own internal representation of the DOM, and it can calculate\nthe diff beween the new view and the old, and just update the bits of the DOM\ntha have changed.\n\nThere is an additional optimisation, a component can implement\nshouldComponentUpdate(nextProps, nextState) which should return true or false if\ngiven the change (or not) in state/props whether the view will change or not.\nThis allows react to skip calling the render method for that component, and skip\ndoing the diff of that part of its internal representation of the DOM.\n\nThe simplest way to implement this is to loop over all the props and state keys\nand compare them to the current values with ===. This is so common in fact that\nthere is React.PureComponent that your component classes can extend which\nincludes this, and Function components also use that implementation by default.\nBecause state for the app is held at the root level, any change requires React\nto check the whole tree for updates, liberal use of Pure/Function components\nmakes this much quicker.\n\nYou may have noticed the wierd extra steps I took to return a new object in the\nreducer for the messages array. This is because the downside of this strategy is\nif you just update a property of an object, it is still the same object: The ===\ncheck then passes and the component isnt re-rendered. This copying of huge\nchunks of the application state is not performant. The code needed to make sure\nyou return a copy can also be quite verbose, and its easy to make a mistake\nthat then leads to subtle rendering bugs when you accidentaly mutate an object\nrather than copy it.\n\nThis is where\n\nis useful. It provides a bunch of primitive objects that you cant accidentally\nmutate, and that can be efficiently copied. It can be installed with npm install\n--save immutable. To give an example, Ill update the messagesReducer to use it:\n// count.jsx\n// ...\nimport {Map} from \"immutable\"\n\n// ...\nexport function messagesReducer(state = Map(), action) {\nswitch (action.type) {\ncase ADD_MESSAGE:\n// All the methods on the immutable objects return a new copy with the\n// appropriate update applied\nreturn state.set(action.id, action.message);\n\n    case REMOVE_MESSAGE:\n        return state.remove(action.id)\n\n    default:\n        return state;\n}\n\n\n}\n\n// ... Inside the component. the ul of messages needs to be rendered slightly\n// differently now messages is an immutable map rather than a javascript object\n\n * \n * {message}\n * \n\nWith those changes the apps behaviour is no different, but the code for updating\nthe messages is cleaner and more efficient.\nMiscellany\n\nRxJs comes with a built in websocket client, and it is this that is used to\nconnect to the websocket server. This includes automatic reconnection logic\nwithin the websocket epic.\n\nSometimes even the PureComponents and immutable state is not efficient enough.\nOne example of this is the description editor on the Third Party Approval page.\nThe process of converting the whole editor state to the external representation,\nsending the action to update the application state, reading that state in a\nprops, and converting back to DraftJSs internal state caused noticeable lag to\ntyping. This was fixed by letting DraftJS keep its internal state independent of\nthe application state. Changes to that state were pushed to an RxJS observable,\nwhich in turn used debounceTime to limit how often the application state was\nupdated with the new description. shouldComponentUpdate was also manually\nimplemented. The approval_id is added as a prop, and if it is present and the\nsame as the existing source_id then a new editorState from props is ignored.\n\nAnother more common performance gotcha is when functions are passed as props\ninto child components. Because these functions are created new each time render\nis called, it means PureComponents will see that the function for that prop has\nchanged, and also re-render. Youll see all over the Third Party Approval app\ncalls to this.cacheForApproval that is just a helper method that returns the\nsame function if the id and function match one that was already created. You can\nalso get around this in a class component by using a method of the class rather\nthan an anonymous function in the render() method. Finally, since React v16.8\nthere are Hooks. Since the offending function is usually one to update state in\nsome way\n\ncan also help for some use cases.\nExample\n\nThe full code for the example built through-out the above process should look\nsomething like these two files.\n\nindex.jsx\n\nd","feature_image":null,"featured":0,"status":"draft","locale":null,"visibility":"public","author_id":"1","created_at":"2021-06-27T21:54:44.000Z","updated_at":"2021-07-04T01:22:09.000Z","published_at":null,"custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"},{"id":"610dc78dc8337633942e438e","uuid":"6d220a54-255a-4ea8-93a3-6d40ec4f72b3","title":"Cortex - Narrative, Characterful RPG with finesse.","slug":"cortex-overview","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"I have known about Cortex for about two years now. It took a while to properly grow on me, but has now supplanted D&D as my sytem of choice. It has changed how I think about table-top roleplay, and I think it is making me a better player and game moderator. I want to try and explain what it is, and share some of my thoughts on how it works, and what makes it so good.\"]]],[1,\"h2\",[[0,[],0,\"Origins\"]]],[1,\"p\",[[0,[],0,\"Cortex has been around for a while, underlying a bunch of IP tie-in RPGs. Recently Cortex Prime was kickstarted (by Fandom?) and the core book was released late last year. Built out of mechanics distilled from these previous games and collated into a modular toolkit. \"]]],[1,\"p\",[[0,[],0,\"The legacy of previous games shines through. At the core there is a feedback loop between mechanics, story, and roleplay that has obviously been polished and finessed through multiple iterations. Each module tweaks this in some often saignificant way but still feels part of the cohesive whole.\"]]],[1,\"h2\",[[0,[],0,\"How it works\"]]],[1,\"p\",[[0,[],0,\"Dice pools\"]]],[1,\"h3\",[[0,[],0,\"Prime sets and distinctions\"]]],[1,\"h3\",[[0,[],0,\"Narrative focus\"]]],[1,\"p\",[[0,[],0,\"Player-led\"]]],[1,\"p\",[[0,[],0,\"Episodes, scenes, beats\"]]],[1,\"h3\",[[0,[],0,\"Abstract\"]]],[1,\"p\",[[0,[],0,\"Pro/con\"]]],[1,\"p\",[[0,[],0,\"Allows breaking the norms - splitting the party, jumping into action, de-emphases combat\"]]],[1,\"p\",[[0,[],0,\"Not always easy to moderate, lots to unlearn\"]]],[1,\"h2\",[[0,[],0,\"Upcoming\"]]],[1,\"p\",[[0,[],0,\"On the horizon, there is an online toolset being developed by the same people who make D&D Beyond (but with the rights to include digital access with physical book purchase.) \"]]],[1,\"h3\",[[0,[],0,\"Game pitches/games run\"]]]],\"ghostVersion\":\"4.0\"}","html":"<p>I have known about Cortex for about two years now. It took a while to properly grow on me, but has now supplanted D&amp;D as my sytem of choice. It has changed how I think about table-top roleplay, and I think it is making me a better player and game moderator. I want to try and explain what it is, and share some of my thoughts on how it works, and what makes it so good.</p><h2 id=\"origins\">Origins</h2><p>Cortex has been around for a while, underlying a bunch of IP tie-in RPGs. Recently Cortex Prime was kickstarted (by Fandom?) and the core book was released late last year. Built out of mechanics distilled from these previous games and collated into a modular toolkit. </p><p>The legacy of previous games shines through. At the core there is a feedback loop between mechanics, story, and roleplay that has obviously been polished and finessed through multiple iterations. Each module tweaks this in some often saignificant way but still feels part of the cohesive whole.</p><h2 id=\"how-it-works\">How it works</h2><p>Dice pools</p><h3 id=\"prime-sets-and-distinctions\">Prime sets and distinctions</h3><h3 id=\"narrative-focus\">Narrative focus</h3><p>Player-led</p><p>Episodes, scenes, beats</p><h3 id=\"abstract\">Abstract</h3><p>Pro/con</p><p>Allows breaking the norms - splitting the party, jumping into action, de-emphases combat</p><p>Not always easy to moderate, lots to unlearn</p><h2 id=\"upcoming\">Upcoming</h2><p>On the horizon, there is an online toolset being developed by the same people who make D&amp;D Beyond (but with the rights to include digital access with physical book purchase.) </p><h3 id=\"game-pitchesgames-run\">Game pitches/games run</h3>","comment_id":"610dc78dc8337633942e438e","plaintext":"I have known about Cortex for about two years now. It took a while to properly\ngrow on me, but has now supplanted D&D as my sytem of choice. It has changed how\nI think about table-top roleplay, and I think it is making me a better player\nand game moderator. I want to try and explain what it is, and share some of my\nthoughts on how it works, and what makes it so good.\n\nOrigins\nCortex has been around for a while, underlying a bunch of IP tie-in RPGs.\nRecently Cortex Prime was kickstarted (by Fandom?) and the core book was\nreleased late last year. Built out of mechanics distilled from these previous\ngames and collated into a modular toolkit. \n\nThe legacy of previous games shines through. At the core there is a feedback\nloop between mechanics, story, and roleplay that has obviously been polished and\nfinessed through multiple iterations. Each module tweaks this in some often\nsaignificant way but still feels part of the cohesive whole.\n\nHow it works\nDice pools\n\nPrime sets and distinctions\nNarrative focus\nPlayer-led\n\nEpisodes, scenes, beats\n\nAbstract\nPro/con\n\nAllows breaking the norms - splitting the party, jumping into action,\nde-emphases combat\n\nNot always easy to moderate, lots to unlearn\n\nUpcoming\nOn the horizon, there is an online toolset being developed by the same people\nwho make D&D Beyond (but with the rights to include digital access with physical\nbook purchase.) \n\nGame pitches/games run","feature_image":null,"featured":0,"status":"draft","locale":null,"visibility":"public","author_id":"1","created_at":"2021-08-06T23:36:45.000Z","updated_at":"2021-08-07T00:30:20.000Z","published_at":null,"custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"type":"post","email_recipient_filter":"none"}],"posts_authors":[{"id":"5d2db814e9550a73056793d4","post_id":"59dbffdd33f8721992d35a27","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793d5","post_id":"59dcc98533f8721992d35a2d","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793d6","post_id":"59dd35d933f8721992d35a3b","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793d7","post_id":"5a2d994ad39b4937e727d70d","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793d8","post_id":"5a2e503c9136d71a373352c6","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793d9","post_id":"5a3088e09136d71a373352d2","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793da","post_id":"5a31af2a9136d71a373352da","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793db","post_id":"5a31b3959136d71a373352e1","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793dc","post_id":"5a32ef0f9136d71a373352ea","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793dd","post_id":"5a32f2959c9605113d0a4986","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793de","post_id":"5a3309939c9605113d0a498d","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793df","post_id":"5a33186f9c9605113d0a4994","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e0","post_id":"5a34731e9c9605113d0a499d","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e1","post_id":"5a35a28a9c9605113d0a49a4","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e2","post_id":"5a39a9969c9605113d0a49b3","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e3","post_id":"5a39b0549c9605113d0a49ba","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e4","post_id":"5a3a8a539c9605113d0a49c3","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e5","post_id":"5a3b04e59c9605113d0a49c6","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e6","post_id":"5a3c411b9c9605113d0a49cd","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e7","post_id":"5a3db3339c9605113d0a49d8","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e8","post_id":"5a3ee0de9c9605113d0a49df","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793e9","post_id":"5a404d849c9605113d0a49e9","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793ea","post_id":"5a418a419c9605113d0a49f0","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793eb","post_id":"5a46ddb19c9605113d0a49f9","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793ec","post_id":"5a48c8229c9605113d0a4a03","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793ed","post_id":"5a4d38e29c9605113d0a4a0b","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793ee","post_id":"5a4d5fde9c9605113d0a4a12","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793ef","post_id":"5b094d19234d9f6a63ff360c","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793f0","post_id":"5b0a7d44234d9f6a63ff3616","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793f1","post_id":"5d113c8e7dda560778de2bb0","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793f2","post_id":"5d126d037dda560778de2bb9","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793f3","post_id":"5d1bce627dda560778de2bce","author_id":"1","sort_order":0},{"id":"5d2db814e9550a73056793f4","post_id":"5d21fa9a7dda560778de2be2","author_id":"1","sort_order":0},{"id":"5edac1394d1d5c09a4c0c9b8","post_id":"5edac1384d1d5c09a4c0c9b7","author_id":"1","sort_order":0},{"id":"5ff1df307ced540c8c44c363","post_id":"5ff1df307ced540c8c44c362","author_id":"1","sort_order":0},{"id":"60d8f3a403d91a1964d010e3","post_id":"60d8f3a403d91a1964d010e2","author_id":"1","sort_order":0},{"id":"610dc78dc8337633942e438f","post_id":"610dc78dc8337633942e438e","author_id":"1","sort_order":0}],"posts_meta":[{"id":"5edacf874d1d5c09a4c0ca4e","post_id":"5edac1384d1d5c09a4c0c9b7","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":"A write up of the game I designed in Needy Cats' Game Jam in support of Feline and Wildlife Rescue Nottingham","email_subject":null,"frontmatter":null}],"posts_tags":[{"id":"59dccc6d33f8721992d35a2e","post_id":"59dcc98533f8721992d35a2d","tag_id":"59dbffa433f8721992d35a26","sort_order":1},{"id":"59dccc6d33f8721992d35a2f","post_id":"59dcc98533f8721992d35a2d","tag_id":"59dc010733f8721992d35a29","sort_order":0},{"id":"59dccf2833f8721992d35a34","post_id":"59dbffdd33f8721992d35a27","tag_id":"59dc010733f8721992d35a29","sort_order":0},{"id":"59dccf2833f8721992d35a35","post_id":"59dbffdd33f8721992d35a27","tag_id":"59dbffa433f8721992d35a26","sort_order":1},{"id":"59dccf5733f8721992d35a37","post_id":"59dbffdd33f8721992d35a27","tag_id":"59dccf5733f8721992d35a36","sort_order":2},{"id":"59dcd3ef33f8721992d35a38","post_id":"59dcc98533f8721992d35a2d","tag_id":"59dccf5733f8721992d35a36","sort_order":2},{"id":"59dd391e33f8721992d35a3c","post_id":"59dd35d933f8721992d35a3b","tag_id":"59dc010733f8721992d35a29","sort_order":0},{"id":"59dd391f33f8721992d35a3d","post_id":"59dd35d933f8721992d35a3b","tag_id":"59dbffa433f8721992d35a26","sort_order":1},{"id":"59dd391f33f8721992d35a3e","post_id":"59dd35d933f8721992d35a3b","tag_id":"59dccf5733f8721992d35a36","sort_order":2},{"id":"5a2d9ae8d39b4937e727d70f","post_id":"5a2d994ad39b4937e727d70d","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a2d9ae8d39b4937e727d711","post_id":"5a2d994ad39b4937e727d70d","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a2d9ae8d39b4937e727d713","post_id":"5a2d994ad39b4937e727d70d","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a2e50e09136d71a373352c7","post_id":"5a2e503c9136d71a373352c6","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a2e50e09136d71a373352c9","post_id":"5a2e503c9136d71a373352c6","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a2e50e09136d71a373352cc","post_id":"5a2e503c9136d71a373352c6","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a30892f9136d71a373352d3","post_id":"5a3088e09136d71a373352d2","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a30892f9136d71a373352d5","post_id":"5a3088e09136d71a373352d2","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a30892f9136d71a373352d8","post_id":"5a3088e09136d71a373352d2","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a31affe9136d71a373352db","post_id":"5a31af2a9136d71a373352da","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a31affe9136d71a373352dd","post_id":"5a31af2a9136d71a373352da","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a31affe9136d71a373352e0","post_id":"5a31af2a9136d71a373352da","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a31bbc39136d71a373352e2","post_id":"5a31b3959136d71a373352e1","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a31bbc39136d71a373352e4","post_id":"5a31b3959136d71a373352e1","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a31bbc39136d71a373352e7","post_id":"5a31b3959136d71a373352e1","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a32ef779136d71a373352eb","post_id":"5a32ef0f9136d71a373352ea","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a32ef779136d71a373352ed","post_id":"5a32ef0f9136d71a373352ea","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a32ef779136d71a373352f0","post_id":"5a32ef0f9136d71a373352ea","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a32f2e59c9605113d0a4987","post_id":"5a32f2959c9605113d0a4986","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a32f2e59c9605113d0a4989","post_id":"5a32f2959c9605113d0a4986","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a32f2e59c9605113d0a498c","post_id":"5a32f2959c9605113d0a4986","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a330a049c9605113d0a498e","post_id":"5a3309939c9605113d0a498d","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a330a049c9605113d0a4990","post_id":"5a3309939c9605113d0a498d","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a330a049c9605113d0a4993","post_id":"5a3309939c9605113d0a498d","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3319259c9605113d0a4995","post_id":"5a33186f9c9605113d0a4994","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3319259c9605113d0a4997","post_id":"5a33186f9c9605113d0a4994","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3319259c9605113d0a499a","post_id":"5a33186f9c9605113d0a4994","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3473bf9c9605113d0a499e","post_id":"5a34731e9c9605113d0a499d","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3473bf9c9605113d0a49a0","post_id":"5a34731e9c9605113d0a499d","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3473bf9c9605113d0a49a3","post_id":"5a34731e9c9605113d0a499d","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a35a3429c9605113d0a49a5","post_id":"5a35a28a9c9605113d0a49a4","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a35a3429c9605113d0a49a7","post_id":"5a35a28a9c9605113d0a49a4","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a35a3429c9605113d0a49aa","post_id":"5a35a28a9c9605113d0a49a4","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a39aa559c9605113d0a49b4","post_id":"5a39a9969c9605113d0a49b3","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a39aa559c9605113d0a49b6","post_id":"5a39a9969c9605113d0a49b3","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a39aa559c9605113d0a49b9","post_id":"5a39a9969c9605113d0a49b3","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a39b0c19c9605113d0a49bb","post_id":"5a39b0549c9605113d0a49ba","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a39b0c19c9605113d0a49bd","post_id":"5a39b0549c9605113d0a49ba","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a39b0c19c9605113d0a49c0","post_id":"5a39b0549c9605113d0a49ba","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3a9e609c9605113d0a49c4","post_id":"5a3a8a539c9605113d0a49c3","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":0},{"id":"5a3b05889c9605113d0a49c7","post_id":"5a3b04e59c9605113d0a49c6","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3b05889c9605113d0a49c9","post_id":"5a3b04e59c9605113d0a49c6","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3b05889c9605113d0a49cc","post_id":"5a3b04e59c9605113d0a49c6","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3c419c9c9605113d0a49ce","post_id":"5a3c411b9c9605113d0a49cd","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3c419c9c9605113d0a49d0","post_id":"5a3c411b9c9605113d0a49cd","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3c419c9c9605113d0a49d3","post_id":"5a3c411b9c9605113d0a49cd","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3db39b9c9605113d0a49d9","post_id":"5a3db3339c9605113d0a49d8","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3db39b9c9605113d0a49db","post_id":"5a3db3339c9605113d0a49d8","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3db39b9c9605113d0a49de","post_id":"5a3db3339c9605113d0a49d8","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a3ee1339c9605113d0a49e0","post_id":"5a3ee0de9c9605113d0a49df","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a3ee1339c9605113d0a49e2","post_id":"5a3ee0de9c9605113d0a49df","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a3ee1339c9605113d0a49e5","post_id":"5a3ee0de9c9605113d0a49df","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a404ec49c9605113d0a49ea","post_id":"5a404d849c9605113d0a49e9","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a404ec49c9605113d0a49ec","post_id":"5a404d849c9605113d0a49e9","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a404ec49c9605113d0a49ef","post_id":"5a404d849c9605113d0a49e9","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a418ac99c9605113d0a49f1","post_id":"5a418a419c9605113d0a49f0","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a418ac99c9605113d0a49f3","post_id":"5a418a419c9605113d0a49f0","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a418ac99c9605113d0a49f6","post_id":"5a418a419c9605113d0a49f0","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a46ddfc9c9605113d0a49fa","post_id":"5a46ddb19c9605113d0a49f9","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a46ddfc9c9605113d0a49fc","post_id":"5a46ddb19c9605113d0a49f9","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a46ddfc9c9605113d0a49ff","post_id":"5a46ddb19c9605113d0a49f9","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a48c8b99c9605113d0a4a04","post_id":"5a48c8229c9605113d0a4a03","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a48c8b99c9605113d0a4a06","post_id":"5a48c8229c9605113d0a4a03","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a48c8b99c9605113d0a4a09","post_id":"5a48c8229c9605113d0a4a03","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a4d39589c9605113d0a4a0c","post_id":"5a4d38e29c9605113d0a4a0b","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a4d39589c9605113d0a4a0e","post_id":"5a4d38e29c9605113d0a4a0b","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a4d39589c9605113d0a4a11","post_id":"5a4d38e29c9605113d0a4a0b","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5a4d60279c9605113d0a4a13","post_id":"5a4d5fde9c9605113d0a4a12","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5a4d60279c9605113d0a4a15","post_id":"5a4d5fde9c9605113d0a4a12","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5a4d60279c9605113d0a4a18","post_id":"5a4d5fde9c9605113d0a4a12","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5b094db7234d9f6a63ff360d","post_id":"5b094d19234d9f6a63ff360c","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5b094db7234d9f6a63ff360f","post_id":"5b094d19234d9f6a63ff360c","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5b094db7234d9f6a63ff3612","post_id":"5b094d19234d9f6a63ff360c","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5b0a7dbb234d9f6a63ff3617","post_id":"5b0a7d44234d9f6a63ff3616","tag_id":"5a2d9ae8d39b4937e727d70e","sort_order":0},{"id":"5b0a7dbb234d9f6a63ff3619","post_id":"5b0a7d44234d9f6a63ff3616","tag_id":"5a2d9ae8d39b4937e727d710","sort_order":1},{"id":"5b0a7dbb234d9f6a63ff361c","post_id":"5b0a7d44234d9f6a63ff3616","tag_id":"5a2d9ae8d39b4937e727d712","sort_order":2},{"id":"5d11407f7dda560778de2bb2","post_id":"5d113c8e7dda560778de2bb0","tag_id":"5d11407f7dda560778de2bb1","sort_order":1},{"id":"5d11f25e7dda560778de2bb6","post_id":"5d113c8e7dda560778de2bb0","tag_id":"5d11565c7dda560778de2bb3","sort_order":0},{"id":"5d18d6227dda560778de2bc4","post_id":"5d126d037dda560778de2bb9","tag_id":"5d11565c7dda560778de2bb3","sort_order":0},{"id":"5d18d6227dda560778de2bc6","post_id":"5d126d037dda560778de2bb9","tag_id":"5d11407f7dda560778de2bb1","sort_order":1},{"id":"5d21e7337dda560778de2bdf","post_id":"5d1bce627dda560778de2bce","tag_id":"5d11565c7dda560778de2bb3","sort_order":0},{"id":"5d21e7337dda560778de2be1","post_id":"5d1bce627dda560778de2bce","tag_id":"5d11407f7dda560778de2bb1","sort_order":1},{"id":"5d2d0b397dda560778de2bf7","post_id":"5d21fa9a7dda560778de2be2","tag_id":"5d11565c7dda560778de2bb3","sort_order":0},{"id":"5d2d0b397dda560778de2bf9","post_id":"5d21fa9a7dda560778de2be2","tag_id":"5d11407f7dda560778de2bb1","sort_order":1},{"id":"5edacf874d1d5c09a4c0ca4b","post_id":"5edac1384d1d5c09a4c0c9b7","tag_id":"5edacf874d1d5c09a4c0ca48","sort_order":0},{"id":"5edacf874d1d5c09a4c0ca4c","post_id":"5edac1384d1d5c09a4c0c9b7","tag_id":"5edacf874d1d5c09a4c0ca49","sort_order":1},{"id":"5edadd0e4d1d5c09a4c0caa4","post_id":"5edac1384d1d5c09a4c0c9b7","tag_id":"5edadd0e4d1d5c09a4c0caa2","sort_order":2},{"id":"5edadd0e4d1d5c09a4c0caa5","post_id":"5edac1384d1d5c09a4c0c9b7","tag_id":"5edadd0e4d1d5c09a4c0caa3","sort_order":3},{"id":"5ff1e0357ced540c8c44c368","post_id":"5d21fa9a7dda560778de2be2","tag_id":"5ff1e0357ced540c8c44c367","sort_order":2},{"id":"5ff1e0657ced540c8c44c36f","post_id":"5d113c8e7dda560778de2bb0","tag_id":"5ff1e0357ced540c8c44c367","sort_order":2},{"id":"5ff1e73c7ced540c8c44c376","post_id":"5d126d037dda560778de2bb9","tag_id":"5ff1e0357ced540c8c44c367","sort_order":2},{"id":"5ff1e7487ced540c8c44c379","post_id":"5d1bce627dda560778de2bce","tag_id":"5ff1e0357ced540c8c44c367","sort_order":2},{"id":"5ff1fcd87ced540c8c44c37f","post_id":"5ff1df307ced540c8c44c362","tag_id":"5ff1fcd87ced540c8c44c37c","sort_order":0},{"id":"5ff1fcd87ced540c8c44c380","post_id":"5ff1df307ced540c8c44c362","tag_id":"5ff1fcd87ced540c8c44c37d","sort_order":1},{"id":"60c5405703d91a1964d01082","post_id":"5ff1df307ced540c8c44c362","tag_id":"5ff1e0357ced540c8c44c367","sort_order":2}],"roles":[{"id":"59dbf650e4e54e191f41839a","name":"Administrator","description":"Administrators","created_at":"2017-10-09T22:21:04.000Z","updated_at":"2017-10-09T22:21:04.000Z"},{"id":"59dbf650e4e54e191f41839b","name":"Editor","description":"Editors","created_at":"2017-10-09T22:21:04.000Z","updated_at":"2017-10-09T22:21:04.000Z"},{"id":"59dbf650e4e54e191f41839c","name":"Author","description":"Authors","created_at":"2017-10-09T22:21:04.000Z","updated_at":"2017-10-09T22:21:04.000Z"},{"id":"59dbf650e4e54e191f41839d","name":"Owner","description":"Blog Owner","created_at":"2017-10-09T22:21:04.000Z","updated_at":"2017-10-09T22:21:04.000Z"},{"id":"5d2db814e9550a73056793c1","name":"Contributor","description":"Contributors","created_at":"2019-07-16T11:42:12.000Z","updated_at":"2019-07-16T11:42:12.000Z"},{"id":"5d2db8b5d32be7747bc25d7c","name":"Admin Integration","description":"External Apps","created_at":"2019-07-16T11:44:53.000Z","updated_at":"2019-07-16T11:44:53.000Z"},{"id":"5e0dca475eb0361fba7c5e44","name":"DB Backup Integration","description":"Internal DB Backup Client","created_at":"2020-01-02T10:47:35.000Z","updated_at":"2020-01-02T10:47:35.000Z"},{"id":"5e0dca485eb0361fba7c5e4d","name":"Scheduler Integration","description":"Internal Scheduler Client","created_at":"2020-01-02T10:47:36.000Z","updated_at":"2020-01-02T10:47:36.000Z"}],"roles_users":[{"id":"59dbf651e4e54e191f4183d1","role_id":"59dbf650e4e54e191f41839c","user_id":"5951f5fca366002ebd5dbef7"},{"id":"59dbf652e4e54e191f41843d","role_id":"59dbf650e4e54e191f41839d","user_id":"1"}],"settings":[{"id":"59dbf6a833f8721992d35a08","key":"db_hash","value":"070b9fee-dd89-4e03-b6cd-caa16eafab82","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-09T22:22:32.000Z","group":"core","flags":null},{"id":"59dbf6a833f8721992d35a09","key":"next_update_check","value":"1647196011","type":"number","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2022-03-12T18:26:50.000Z","group":"core","flags":null},{"id":"59dbf6a833f8721992d35a0c","key":"title","value":"Jeff Horton","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"site","flags":"PUBLIC"},{"id":"59dbf6a833f8721992d35a0d","key":"description","value":"Web developer, LARPer, board gamer, geek with a love of mountains. He/Him.","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2020-12-10T15:57:20.000Z","group":"site","flags":"PUBLIC"},{"id":"59dbf6a833f8721992d35a0e","key":"logo","value":null,"type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"site","flags":"PUBLIC"},{"id":"59dbf6a833f8721992d35a0f","key":"cover_image","value":"__GHOST_URL__/content/images/2017/10/tumblr_ncaquoETcZ1rxvcd4o3_1280.jpg","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"site","flags":null},{"id":"59dbf6a833f8721992d35a10","key":"icon","value":"__GHOST_URL__/content/images/2017/10/favicon.ico","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"site","flags":null},{"id":"59dbf6a833f8721992d35a15","key":"amp","value":"false","type":"boolean","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2020-01-01T23:40:27.000Z","group":"amp","flags":null},{"id":"59dbf6a833f8721992d35a18","key":"facebook","value":null,"type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"site","flags":null},{"id":"59dbf6a833f8721992d35a19","key":"twitter","value":"@KamiOfTea","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2020-12-10T15:57:20.000Z","group":"site","flags":null},{"id":"59dbf6a833f8721992d35a1b","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"/\"},{\"label\":\"Coding\",\"url\":\"/tag/coding/\"},{\"label\":\"Tabletop Roleplay\",\"url\":\"/tag/ttrpg/\"}]","type":"array","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2021-06-12T23:45:30.000Z","group":"site","flags":null},{"id":"59dbf6a833f8721992d35a1d","key":"unsplash","value":"true","type":"boolean","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"unsplash","flags":null},{"id":"59dbf6a833f8721992d35a1e","key":"active_theme","value":"casper","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2019-07-16T11:45:40.000Z","group":"theme","flags":"RO"},{"id":"59dbf6a833f8721992d35a21","key":"is_private","value":"false","type":"boolean","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"private","flags":null},{"id":"59dbf6a833f8721992d35a22","key":"password","value":null,"type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"private","flags":null},{"id":"59dbf6a833f8721992d35a23","key":"public_hash","value":"a87c81e1f52f4175e93acd29a4227f","type":"string","created_at":"2017-10-09T22:22:32.000Z","updated_at":"2017-10-10T18:23:18.000Z","group":"private","flags":null},{"id":"5d2db81b4d34b27355387b24","key":"notifications","value":"[{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"130f7c24-113a-4768-a698-12a8b34223f5\",\"custom\":true,\"createdAt\":\"2021-03-16T12:55:20.000Z\",\"type\":\"info\",\"top\":true,\"message\":\"<strong>Ghost 4.0 is now available</strong> - You are using an old version of Ghost, which means you don't have access to the latest features. <a href=\\\"https://ghost.org/changelog/4/\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">Read more!</a>\",\"seen\":false,\"addedAt\":\"2021-06-12T12:09:23.700Z\"},{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"dc9d2a40-f484-11eb-9822-9716424d2a07\",\"custom\":false,\"createdAt\":\"2021-08-03T17:01:43.000Z\",\"type\":\"info\",\"top\":false,\"message\":\"Ghost <a href=\\\"https://github.com/TryGhost/Ghost/releases\\\">4.11.0</a> has been released, <a href=\\\"https://ghost.org/update/?v=4.7.0\\\">click here</a> to upgrade.\",\"seen\":false,\"addedAt\":\"2021-08-06T22:22:25.889Z\"},{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"097719ca-a700-41aa-8188-2cd76149b6fe\",\"custom\":true,\"createdAt\":\"2021-09-23T10:33:50.000Z\",\"type\":\"alert\",\"top\":false,\"message\":\"Critical security update available  please update Ghost as soon as possible. <a href=\\\"https://github.com/TryGhost/Ghost/security/advisories/GHSA-65p7-pjj8-ggmr\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">Details here.</a>\",\"seen\":false,\"addedAt\":\"2021-09-29T15:21:13.015Z\"}]","type":"array","created_at":"2019-07-16T11:42:19.000Z","updated_at":"2021-09-29T15:21:13.000Z","group":"core","flags":null},{"id":"5d2db8b2d32be7747bc25d76","key":"session_secret","value":"ad00f53eec95db9493b52de9e313e8bacf702a8f7fea02635b200a4066eb300e","type":"string","created_at":"2019-07-16T11:44:50.000Z","updated_at":"2019-07-16T11:44:50.000Z","group":"core","flags":null},{"id":"5d2db8b2d32be7747bc25d77","key":"theme_session_secret","value":"3af3260ad50ef5a33fa43222154e74bea857c2a5460df71abfd94b6363feba79","type":"string","created_at":"2019-07-16T11:44:50.000Z","updated_at":"2019-07-16T11:44:50.000Z","group":"core","flags":null},{"id":"5d2db8b2d32be7747bc25d78","key":"members_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAIoAEEdnavFWOAB2KFI8sgbEH3wb8oYXm1NBuvLCWrT2fSQgOKJTkibQKBHijtKG\nXFIc7pxjIETATRJYBBrQyUeoYsuc/sPfFEOF92qOJU/QIb5Qcp+64lOUyOj9P5EveWli8lC0\nIb/nyXT0LuzSV61aDIX8ejBdcxj1BHhxTyjNAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","created_at":"2019-07-16T11:44:50.000Z","updated_at":"2019-07-16T11:44:50.000Z","group":"core","flags":null},{"id":"5d2db8b2d32be7747bc25d79","key":"members_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCKABBHZ2rxVjgAdihSPLIGxB98G/KGF5tTQbrywlq09n0kIDiiU5Im0CgR\n4o7ShlxSHO6cYyBEwE0SWAQa0MlHqGLLnP7D3xRDhfdqjiVP0CG+UHKfuuJTlMjo/T+RL3lp\nYvJQtCG/58l09C7s0letWgyF/HowXXMY9QR4cU8ozQIDAQABAoGARzF1NIEj6NGEHqjWcGaj\nqV3wqER6v7baCP+2BJtD1Gv9b2+4B/Z5RdDJe0CYUf/DDRGj/8Yb1ZwnprkFlRf1XmHukk9i\n26dNeCU9VQUbxDU4mvRwWd/bHqYSPiO1MGzDvxWxsSJqdPR2EAG6fsuy5kQty6G3UP/wFQob\n8l6LoHkCQQDLsgFDbYITPNoiLGZSu8VjsrDeVrwdUBFxYh8q23SYVjsO/xIEO71PhnqtaIsd\napKkp/I0TC7XP9RujxvHGX3jAkEArW+Q1dsiT9LAbdJrck0jBEF/7BwdKLeJptrkP15PjGZA\noB2nyCVvh6BdHozVJM7sd6rvZ0zFozT4s1YOjR59jwJAZYqg8pn+g9SL8QktIQUVyzNi1BNs\nxzgI2frOCrFHmEE0Q6+HrbCSGLizIwrAfrOH0qkeJk/r8cWSAmM4t7HPfQJBAAm2U7AGI3fA\n35HG1MmD1FAqstUwBdn/3S+A1oNN7rp4B2pv/rNQlVxM+Kn7TPxQsiFJazqnq/Glx7+TNCFm\n8bUCQChBY4iiS6cuqVFPL9AXRDM7KDoBBUCjdwKmtLxa41xUorAV/PrGayeaVJa+erqVu9I0\npWDwoQKFUm1/uCeYe6E=\n-----END RSA PRIVATE KEY-----\n","type":"string","created_at":"2019-07-16T11:44:50.000Z","updated_at":"2019-07-16T11:44:50.000Z","group":"core","flags":null},{"id":"5e0dca425eb0361fba7c5e38","key":"secondary_navigation","value":"[]","type":"array","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e39","key":"meta_title","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3a","key":"meta_description","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3b","key":"og_image","value":"__GHOST_URL__/content/images/2020/12/cadair-cover-v2-1.jpg","type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-12-10T15:57:20.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3c","key":"og_title","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3d","key":"og_description","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3e","key":"twitter_image","value":"__GHOST_URL__/content/images/2020/12/cadair-cover-v2.jpg","type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-12-10T15:57:20.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e3f","key":"twitter_title","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e40","key":"twitter_description","value":null,"type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"site","flags":null},{"id":"5e0dca425eb0361fba7c5e41","key":"members_email_auth_secret","value":"daa4bfb315aa14f4e64269b0c85eab9089fb541fa3c1f87984cb06144c8d54b2bf3a6321ff0c10519a5a60537e299e9e915eff9dfe746c3f1fce2403e51a8fbc","type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"core","flags":null},{"id":"5e0dca425eb0361fba7c5e42","key":"default_content_visibility","value":"public","type":"string","created_at":"2020-01-02T10:47:30.000Z","updated_at":"2020-01-02T10:47:30.000Z","group":"members","flags":null},{"id":"5fd24b567ced540c8c44c302","key":"routes_hash","value":"3d180d52c663d173a6be791ef411ed01","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:53.000Z","group":"core","flags":null},{"id":"5fd24b577ced540c8c44c303","key":"ghost_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAKNC6jMdLYbdfVKG8FzMWpQX38POfMl3L/0z/Iz9GpuAOaRdK5ThkK6wSDRskNOf\nBvH3+VXJOnSPI+yWyXz9D+k9PnfCF1V7RIs470H+BeZ9W3je6u7LFulmUu+c/pgDqyVj4Acb\ngcRgIDpPQb+hkjO6i+/sJfdTmPKfcJPwWUplAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"core","flags":null},{"id":"5fd24b577ced540c8c44c304","key":"ghost_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCjQuozHS2G3X1ShvBczFqUF9/DznzJdy/9M/yM/RqbgDmkXSuU4ZCusEg0\nbJDTnwbx9/lVyTp0jyPslsl8/Q/pPT53whdVe0SLOO9B/gXmfVt43uruyxbpZlLvnP6YA6sl\nY+AHG4HEYCA6T0G/oZIzuovv7CX3U5jyn3CT8FlKZQIDAQABAoGAGrHqUYlH1HGK+F+QFdxk\nQyrUL9Qnm1mdwy0o8nTAUQTaaAHECogHfEjexZOq6q9qF06QunI42K4/FYRiVcmbPCjrV1Mj\ngdZb1BqkQcItZJeIWmg+8wl3vR2lEYhfKMjNCXsvlc+BxK1i+ndgBCvaMHcRbSU5ZVhnR0h3\nBlTzEdECQQDeatnvoH2sEry2fIBkAy8g8mxftEvUUgCn66NbuuWUvxJ2KLNUBGsWE1ARE0Gd\n4Tvy4ZXcblaxKvei8GXY3CHzAkEAu+l+UwSIQq83LqKfDAgYzt3GP1kmcRzbPK3W4BC8qLD2\n7LwtSoKBKDsrKohsVt2udPZpMRoWIL4Qx5oa4pygRwJAFdQmz33Q17J/EunlL+ugFHu2Zy4q\nwwvJRLG7tqUBIzgdd7tG3lgQqnn6wbJCHlycpZm+O4QYvgqZg0RUupPgQQJAGC92PdMggoyw\nqoTtuYu1PbLXmEGuK/LN2OJ6/H3K+l9EeLXDkop3eykaZjAG2atQj+dDJLm5zV8JI9eWzEHi\ncwJBAAnbbEsWbpQMndHcqdD85Uf0gsCJVI02IF9sIS3tNlpdofobMHFcNCEJ+H5I4nl4g+Dd\nNY1PJzyCdxwof84k9OI=\n-----END RSA PRIVATE KEY-----\n","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"core","flags":null},{"id":"5fd24b577ced540c8c44c307","key":"accent_color","value":"#658025","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2021-06-12T22:06:14.000Z","group":"site","flags":"PUBLIC"},{"id":"5fd24b577ced540c8c44c308","key":"lang","value":"en","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"site","flags":null},{"id":"5fd24b577ced540c8c44c309","key":"timezone","value":"Europe/Dublin","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"site","flags":null},{"id":"5fd24b577ced540c8c44c30a","key":"codeinjection_head","value":"<!-- Edit -->","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2021-06-12T18:49:21.000Z","group":"site","flags":null},{"id":"5fd24b577ced540c8c44c30b","key":"codeinjection_foot","value":null,"type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"site","flags":null},{"id":"5fd24b577ced540c8c44c30d","key":"members_from_address","value":"noreply@blog.goblinoid.co.uk","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":"RO"},{"id":"5fd24b577ced540c8c44c30e","key":"members_support_address","value":"noreply@blog.goblinoid.co.uk","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":"PUBLIC,RO"},{"id":"5fd24b577ced540c8c44c30f","key":"members_reply_address","value":"newsletter","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":null},{"id":"5fd24b577ced540c8c44c310","key":"members_free_signup_redirect","value":"/","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":null},{"id":"5fd24b577ced540c8c44c311","key":"members_paid_signup_redirect","value":"/","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":null},{"id":"5fd24b577ced540c8c44c312","key":"stripe_product_name","value":"Ghost Subscription","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":""},{"id":"5fd24b577ced540c8c44c315","key":"stripe_plans","value":"[{\"name\":\"Monthly\",\"currency\":\"usd\",\"interval\":\"month\",\"amount\":0},{\"name\":\"Yearly\",\"currency\":\"usd\",\"interval\":\"year\",\"amount\":0}]","type":"array","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":""},{"id":"5fd24b577ced540c8c44c318","key":"stripe_connect_livemode","value":null,"type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":""},{"id":"5fd24b577ced540c8c44c319","key":"stripe_connect_display_name","value":null,"type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"members","flags":""},{"id":"5fd24b577ced540c8c44c31b","key":"portal_name","value":"true","type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c31c","key":"portal_button","value":"false","type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c31d","key":"portal_plans","value":"[\"free\",\"monthly\",\"yearly\"]","type":"array","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2021-06-12T18:32:39.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c31e","key":"portal_button_style","value":"icon-and-text","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c31f","key":"portal_button_icon","value":null,"type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c320","key":"portal_button_signup_text","value":"Subscribe","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"portal","flags":null},{"id":"5fd24b577ced540c8c44c321","key":"mailgun_domain","value":"","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"email","flags":null},{"id":"5fd24b577ced540c8c44c322","key":"mailgun_api_key","value":"","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"email","flags":null},{"id":"5fd24b577ced540c8c44c323","key":"mailgun_base_url","value":"","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"email","flags":null},{"id":"5fd24b577ced540c8c44c324","key":"email_track_opens","value":"false","type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2021-06-12T22:45:04.000Z","group":"email","flags":null},{"id":"5fd24b577ced540c8c44c325","key":"amp_gtag_id","value":null,"type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"amp","flags":null},{"id":"5fd24b577ced540c8c44c326","key":"shared_views","value":"[]","type":"array","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"views","flags":null},{"id":"5fd24b577ced540c8c44c327","key":"newsletter_show_badge","value":"true","type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"newsletter","flags":null},{"id":"5fd24b577ced540c8c44c328","key":"newsletter_show_header","value":"true","type":"boolean","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"newsletter","flags":null},{"id":"5fd24b577ced540c8c44c329","key":"newsletter_body_font_category","value":"sans_serif","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"newsletter","flags":null},{"id":"5fd24b577ced540c8c44c32a","key":"newsletter_footer_content","value":"","type":"string","created_at":"2020-12-10T16:22:47.000Z","updated_at":"2020-12-10T16:22:47.000Z","group":"newsletter","flags":null},{"id":"60c4fb4d16b9b7020339e5ef","key":"firstpromoter","value":"false","type":"boolean","created_at":"2021-06-12T18:22:05.000Z","updated_at":"2021-06-12T18:22:05.000Z","group":"firstpromoter","flags":null},{"id":"60c4fb4d16b9b7020339e5f0","key":"firstpromoter_id","value":null,"type":"string","created_at":"2021-06-12T18:22:05.000Z","updated_at":"2021-06-12T18:22:05.000Z","group":"firstpromoter","flags":null},{"id":"60c4fd813ba81e0369e212fd","key":"slack_url","value":"","type":"string","created_at":"2021-06-12T18:31:29.000Z","updated_at":"2021-06-12T23:45:30.000Z","group":"slack","flags":null},{"id":"60c4fd813ba81e0369e212fe","key":"slack_username","value":"Ghost","type":"string","created_at":"2021-06-12T18:31:29.000Z","updated_at":"2021-06-12T23:45:30.000Z","group":"slack","flags":null},{"id":"60c4fd823ba81e0369e21319","key":"members_signup_access","value":"none","type":"string","created_at":"2021-06-12T18:31:30.000Z","updated_at":"2021-06-12T22:45:34.000Z","group":"members","flags":null},{"id":"60c4fd833ba81e0369e2131c","key":"labs","value":"{}","type":"object","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"labs","flags":null},{"id":"60c4fd833ba81e0369e2131d","key":"members_free_price_name","value":"Free","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"members","flags":null},{"id":"60c4fd833ba81e0369e2131e","key":"members_free_price_description","value":"Free preview","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"members","flags":null},{"id":"60c4fd833ba81e0369e2131f","key":"members_monthly_price_id","value":null,"type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"members","flags":null},{"id":"60c4fd833ba81e0369e21320","key":"members_yearly_price_id","value":null,"type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"members","flags":null},{"id":"60c4fd833ba81e0369e21321","key":"newsletter_header_image","value":null,"type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21322","key":"newsletter_show_header_icon","value":"true","type":"boolean","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21323","key":"newsletter_show_header_title","value":"true","type":"boolean","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21324","key":"newsletter_title_alignment","value":"center","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21325","key":"newsletter_title_font_category","value":"sans_serif","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21326","key":"newsletter_show_feature_image","value":"true","type":"boolean","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"newsletter","flags":null},{"id":"60c4fd833ba81e0369e21329","key":"editor_default_email_recipients","value":"visibility","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"editor","flags":null},{"id":"60c4fd833ba81e0369e2132a","key":"editor_default_email_recipients_filter","value":"all","type":"string","created_at":"2021-06-12T18:31:31.000Z","updated_at":"2021-06-12T18:31:31.000Z","group":"editor","flags":null}],"tags":[{"id":"59dbffa433f8721992d35a26","name":"Kings of War","slug":"kings-of-war","description":"Posts about Mantic's Kings of War tabletop wargaming system","feature_image":"__GHOST_URL__/content/images/2017/10/kow-badge.png","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-10-09T23:00:52.000Z","updated_at":"2017-10-10T14:04:32.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"59dc010733f8721992d35a29","name":"Edge of the Abyss","slug":"edge-of-the-abyss","description":"A series of post tracking my Dwarf army, Led by King Morrolan, through Manitic's Edge of the Abyss Summer Campaign.","feature_image":"__GHOST_URL__/content/images/2017/10/dwarf-art.jpg","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-10-09T23:06:47.000Z","updated_at":"2017-10-10T14:37:49.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"59dccf5733f8721992d35a36","name":"Wargaming","slug":"wargaming","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-10-10T13:47:03.000Z","updated_at":"2017-10-10T14:04:58.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5a2d9ae8d39b4937e727d70e","name":"Advent of Code 2017","slug":"advent-of-code-2017","description":"My Solutions For the Advent of Code 2017","feature_image":"__GHOST_URL__/content/images/2017/12/AoC-banner-2.png","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-12-10T20:36:56.000Z","updated_at":"2018-11-30T17:55:57.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5a2d9ae8d39b4937e727d710","name":"Coding","slug":"coding","description":null,"feature_image":"__GHOST_URL__/content/images/2021/06/coding.png","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-12-10T20:36:56.000Z","updated_at":"2021-06-12T23:45:06.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5a2d9ae8d39b4937e727d712","name":"scala","slug":"scala","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-12-10T20:36:56.000Z","updated_at":"2018-11-30T17:55:57.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5d11407f7dda560778de2bb1","name":"D&D","slug":"d-d","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2019-06-24T21:28:31.000Z","updated_at":"2019-07-15T23:25:02.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5d11565c7dda560778de2bb3","name":"Goblins of The Dragon's Tooth","slug":"goblins-of-the-dragons-tooth","description":"Collected articles for a D&D One Off I have written.","feature_image":"__GHOST_URL__/content/images/2019/06/guardians-rest-with-goblin-small-2.png","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2019-06-24T23:01:48.000Z","updated_at":"2019-10-20T16:03:25.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5edacf874d1d5c09a4c0ca48","name":"Board Games","slug":"board-games","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2020-06-05T23:04:39.000Z","updated_at":"2020-06-05T23:04:39.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5edacf874d1d5c09a4c0ca49","name":"Game Jam","slug":"game-jam","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2020-06-05T23:04:39.000Z","updated_at":"2020-06-05T23:04:39.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5edacf874d1d5c09a4c0ca4a","name":"Needy Cat Games","slug":"needy-cat-games","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2020-06-05T23:04:39.000Z","updated_at":"2020-06-05T23:04:39.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5edadd0e4d1d5c09a4c0caa2","name":"Game Design","slug":"game-design","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2020-06-06T00:02:22.000Z","updated_at":"2020-06-06T00:02:22.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5edadd0e4d1d5c09a4c0caa3","name":"Animal Rescue Game","slug":"animal-rescue-game","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2020-06-06T00:02:22.000Z","updated_at":"2020-06-06T00:02:22.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5ff1e0357ced540c8c44c367","name":"TTRPG","slug":"ttrpg","description":"All posts related to Tabletop Role Playing Games.","feature_image":"__GHOST_URL__/content/images/2021/01/DSC_0160.JPG","parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2021-01-03T15:18:13.000Z","updated_at":"2021-01-03T15:48:12.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":"#387A49"},{"id":"5ff1fcd87ced540c8c44c37c","name":"Cortex","slug":"cortex","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2021-01-03T17:20:24.000Z","updated_at":"2021-01-03T17:20:24.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"5ff1fcd87ced540c8c44c37d","name":"Hammerheads","slug":"hammerheads","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2021-01-03T17:20:24.000Z","updated_at":"2021-01-03T17:20:24.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null},{"id":"60c4e1cc7ced540c8c44c70b","name":"Cortex Confab","slug":"cortex-confab","description":null,"feature_image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2021-06-12T16:33:16.000Z","updated_at":"2021-06-12T16:33:16.000Z","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null}],"users":[{"id":"1","name":"Jeff Horton","slug":"jeff","password":"$2a$10$cRfdFWcYepRMTLckL77GOe7MZNOC3yYI7tcmHuV0QsmCIU2w0Alga","email":"jeff@goblinoid.co.uk","profile_image":"//www.gravatar.com/avatar/df0960bccdb25ed614c17633e5e9ce17?s=250&d=mm&r=x","cover_image":"__GHOST_URL__/content/images/2017/10/IMG_20140520_124818.jpg","bio":"Web developer, LARPer, board gamer, geek with a love of mountains.","website":"http://www.goblinoid.co.uk","location":"Sheffield, UK","facebook":null,"twitter":"@KamiOfTea","accessibility":"{\"nightShift\":true,\"whatsNew\":{\"lastSeenDate\":\"2021-12-17T15:25:10.000+00:00\"},\"launchComplete\":true}","status":"active","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"tour":"[\"getting-started\",\"upload-a-theme\",\"using-the-editor\",\"static-post\",\"featured-post\"]","last_seen":"2022-03-12T18:26:52.000Z","created_at":"2017-10-09T22:21:05.000Z","updated_at":"2022-03-12T18:31:34.000Z"}]}}]}
